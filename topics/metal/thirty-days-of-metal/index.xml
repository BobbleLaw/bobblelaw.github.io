<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Bobble Law</title><link>https://bobblelaw.github.io/topics/metal/thirty-days-of-metal/</link><description>Recent content on Bobble Law</description><generator>Hugo</generator><language>en-US</language><atom:link href="https://bobblelaw.github.io/topics/metal/thirty-days-of-metal/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://bobblelaw.github.io/topics/metal/thirty-days-of-metal/01-devices/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bobblelaw.github.io/topics/metal/thirty-days-of-metal/01-devices/</guid><description>&lt;h1 id="devices">Devices&lt;/h1>
&lt;p>To get started, we will learn about &lt;strong>devices&lt;/strong>.&lt;/p>
&lt;p>A device is an abstraction of the graphics processing unit, or GPU, inside your iPhone or Mac. The GPU is a separate processor from the CPU and is specialized for different kinds of work. A big part of our job here is learning what GPUs are good at and how to program them.&lt;/p>
&lt;p>In code, a device is an object that conforms to the MTLDevice protocol. This protocol includes methods for allocating GPU resources, as well as many other kinds of objects. We will see many of these as we progress through our exploration of Metal.&lt;/p></description></item><item><title/><link>https://bobblelaw.github.io/topics/metal/thirty-days-of-metal/02-buffer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bobblelaw.github.io/topics/metal/thirty-days-of-metal/02-buffer/</guid><description>&lt;h1 id="buffer">Buffer&lt;/h1>
&lt;p>In the previous article we got acquainted with Metal and learned a little about devices.&lt;/p>
&lt;p>In this article, we will start to allocate memory on the GPU in the form of &lt;em>buffers&lt;/em>. Buffers are essential to graphics programming, because they hold the data that the GPU operates on.&lt;/p>
&lt;h2 id="data">Data?&lt;/h2>
&lt;p>That’s a bit abstract, so let’s talk about &lt;em>what kinds&lt;/em> of data might be held in a buffer.&lt;/p>
&lt;p>In some graphics APIs, if you want to draw a line, there might be a function called &lt;code>drawLine&lt;/code> to draw a line segment, or perhaps a pair of functions called &lt;code>moveTo&lt;/code> and &lt;code>lineTo&lt;/code>, to specify where a line starts and ends.&lt;/p></description></item><item><title/><link>https://bobblelaw.github.io/topics/metal/thirty-days-of-metal/03-commands/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bobblelaw.github.io/topics/metal/thirty-days-of-metal/03-commands/</guid><description>&lt;h1 id="commands">Commands&lt;/h1>
&lt;p>So far in this series, we have talked about devices and buffers. Creating a device and asking it to allocate GPU memory are important tasks, but in order to put the GPU to work, we need to learn how to speak its language. We need to learn how to issue commands.&lt;/p>
&lt;h2 id="what-are-commands">What are Commands?&lt;/h2>
&lt;p>As mentioned in the previous article, Metal doesn’t have functions that let us simultaneously supply data and draw shapes. Providing data and issuing draw commands are separate operations, and they comprise the most common types of Metal commands.&lt;/p></description></item><item><title/><link>https://bobblelaw.github.io/topics/metal/thirty-days-of-metal/04-mtkview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bobblelaw.github.io/topics/metal/thirty-days-of-metal/04-mtkview/</guid><description>&lt;h1 id="mtkview">MTKView&lt;/h1>
&lt;p>In the previous article, we got acquainted with Metal’s command submission model, including command queues, command buffers, and command encoders. In this article, we will meet the &lt;code>MTKView&lt;/code> class, which allows us to display the pictures we draw with Metal on the screen.&lt;/p>
&lt;h2 id="introducing-mtkview">Introducing MTKView&lt;/h2>
&lt;p>The &lt;code>MTKView&lt;/code> class is provided by the MetalKit framework. MetalKit is a small framework that provides higher-level utility types that make working with Metal easier.&lt;/p></description></item><item><title/><link>https://bobblelaw.github.io/topics/metal/thirty-days-of-metal/05-shaders/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bobblelaw.github.io/topics/metal/thirty-days-of-metal/05-shaders/</guid><description>&lt;h1 id="shaders">Shaders&lt;/h1>
&lt;p>In the previous article, we looked at how to start and end render passes by creating a render command encoder from a view’s render pass descriptor. We also saw how the act of executing a render pass can clear the contents of a texture to a solid color. Finally, we discussed how to present the cleared texture in the view.&lt;/p>
&lt;p>We are now ready to start writing code that runs on the GPU.&lt;/p></description></item><item><title/><link>https://bobblelaw.github.io/topics/metal/thirty-days-of-metal/06-pipelines/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bobblelaw.github.io/topics/metal/thirty-days-of-metal/06-pipelines/</guid><description>&lt;h1 id="pipelines">Pipelines&lt;/h1>
&lt;p>Let’s recap what we’ve learned in the first five installments of this series.&lt;/p>
&lt;p>First, we learned about how to get a device object, which lets us allocate resources and create various other objects related to command submission. Then, we talked about creating buffers, a type of resource that holds the data to be used by the GPU in fulfilling our commands. Then, we talked about how to encode commands and submit them to the GPU for execution. Last time, we started to get acquainted with shaders, the programs we write that run on the GPU itself.&lt;/p></description></item><item><title/><link>https://bobblelaw.github.io/topics/metal/thirty-days-of-metal/07-drawing-in-2d/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bobblelaw.github.io/topics/metal/thirty-days-of-metal/07-drawing-in-2d/</guid><description>&lt;h1 id="drawing-in-2d">Drawing in 2D&lt;/h1>
&lt;p>Last time, we looked at how to create compute pipeline states from kernel functions so we can perform arbitrary computation on the GPU. This time, we’ll focus on a different kind of pipeline state: &lt;em>render pipeline states&lt;/em>.&lt;/p>
&lt;p>When you have to manage a lot of the moving parts yourself, rendering is a pretty complex task. By now, you probably appreciate just how much more work it is to do anything with Metal than other graphics APIs. Maybe you’ve also gotten a glimpse of how much more powerful and flexible Metal is as a GPU-oriented API. Or maybe not. But pretty soon, you’ll have a much better feel for your latent Metal superpowers.&lt;/p></description></item><item><title/><link>https://bobblelaw.github.io/topics/metal/thirty-days-of-metal/08-vertex-attributes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bobblelaw.github.io/topics/metal/thirty-days-of-metal/08-vertex-attributes/</guid><description>&lt;h1 id="vertex-attribute">Vertex Attribute&lt;/h1>
&lt;p>In the previous article, we crossed the threshold from learning foundational concepts of Metal into actually drawing shapes with the GPU. In this article, we will augment the previous example by adding a new &lt;em>attribute&lt;/em> to our vertices — color — and learn how to simplify our vertex function signatures by using &lt;em>vertex descriptors&lt;/em>.&lt;/p>
&lt;h2 id="attributes-beyond-vertex-positions">Attributes: Beyond Vertex Positions&lt;/h2>
&lt;p>When writing our first vertex function, we took two parameters: a pointer to a buffer containing two-element float vectors (positions), and a vertex ID:&lt;/p></description></item><item><title/><link>https://bobblelaw.github.io/topics/metal/thirty-days-of-metal/09-constants/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bobblelaw.github.io/topics/metal/thirty-days-of-metal/09-constants/</guid><description>&lt;h1 id="constants">Constants&lt;/h1>
&lt;p>Last time, we talked about how to add attributes to vertices so we could fill our triangle with smoothly shaded colors. In this article we will talk about how to pass constant data to shaders, which remains the same for all vertices in a draw call.&lt;/p>
&lt;h2 id="constant-data">Constant Data&lt;/h2>
&lt;p>We call this data &lt;em>constant&lt;/em> data because it doesn’t change between invocations of the shader function. This contrasts with both attribute data, which can change per-vertex, and interpolated data, which can change per-fragment. Some APIs (notably OpenGL) call these types of constant values &lt;em>uniforms&lt;/em>, while most others use the term &lt;em>constants&lt;/em>.&lt;/p></description></item></channel></rss>