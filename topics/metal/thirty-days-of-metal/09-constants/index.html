<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta http-equiv=Accept-CH content="DPR, Viewport-Width, Width"><link rel=icon href=/logo.png type=image/gif><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" media=print onload='this.media="all"'><noscript><link href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel=stylesheet></noscript><link rel=stylesheet href=/css/font.css media=all><meta property="og:url" content="https://bobblelaw.github.io/topics/metal/thirty-days-of-metal/09-constants/"><meta property="og:site_name" content="Bobble Law"><meta property="og:title" content="Bobble Law"><meta property="og:description" content="Constants Last time, we talked about how to add attributes to vertices so we could fill our triangle with smoothly shaded colors. In this article we will talk about how to pass constant data to shaders, which remains the same for all vertices in a draw call.
Constant Data We call this data constant data because it doesn’t change between invocations of the shader function. This contrasts with both attribute data, which can change per-vertex, and interpolated data, which can change per-fragment. Some APIs (notably OpenGL) call these types of constant values uniforms, while most others use the term constants."><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="article:section" content="topics"><meta name=twitter:card content="summary"><meta name=twitter:title content="Bobble Law"><meta name=twitter:description content="Constants Last time, we talked about how to add attributes to vertices so we could fill our triangle with smoothly shaded colors. In this article we will talk about how to pass constant data to shaders, which remains the same for all vertices in a draw call.
Constant Data We call this data constant data because it doesn’t change between invocations of the shader function. This contrasts with both attribute data, which can change per-vertex, and interpolated data, which can change per-fragment. Some APIs (notably OpenGL) call these types of constant values uniforms, while most others use the term constants."><link rel=stylesheet href=/bootstrap-5/css/bootstrap.min.css media=all><link rel=stylesheet href=/css/header.css media=all><link rel=stylesheet href=/css/footer.css media=all><link rel=stylesheet href=/css/theme.css media=all><style>:root{--text-color:#343a40;--text-secondary-color:#6c757d;--text-link-color:#007bff;--background-color:#eaedf0;--secondary-background-color:#64ffda1a;--primary-color:#007bff;--secondary-color:#f8f9fa;--text-color-dark:#e4e6eb;--text-secondary-color-dark:#b0b3b8;--text-link-color-dark:#ffffff;--background-color-dark:#18191a;--secondary-background-color-dark:#212529;--primary-color-dark:#ffffff;--secondary-color-dark:#212529}body{font-size:1rem;font-weight:400;line-height:1.5;text-align:left}html{background-color:var(--background-color)!important}body::-webkit-scrollbar{height:0;width:8px;background-color:var(--background-color)}::-webkit-scrollbar-track{border-radius:1rem}::-webkit-scrollbar-thumb{border-radius:1rem;background:#b0b0b0;outline:1px solid var(--background-color)}#search-content::-webkit-scrollbar{width:.5em;height:.1em;background-color:var(--background-color)}</style><meta name=description content><link rel=stylesheet href=/css/single.css><script defer src=/fontawesome-6/all-6.4.2.js></script><title>| Bobble Law</title></head><body class=light><script>let localStorageValue=localStorage.getItem("pref-theme"),mediaQuery=window.matchMedia("(prefers-color-scheme: dark)").matches;switch(localStorageValue){case"dark":document.body.classList.add("dark");break;case"light":document.body.classList.remove("dark");break;default:mediaQuery&&document.body.classList.add("dark");break}</script><script>var prevScrollPos=window.pageYOffset;window.addEventListener("scroll",function(){let s=document.getElementById("profileHeader"),t=window.pageYOffset,n=!1,o=!0,i=o?prevScrollPos>t:t>0;i?s.classList.add("showHeaderOnTop"):n=!0,t===0&&(n=!0),n&&s.classList.remove("showHeaderOnTop"),prevScrollPos=t})</script><header id=profileHeader><nav class="pt-3 navbar navbar-expand-lg animate"><div class="container-fluid mx-xs-2 mx-sm-5 mx-md-5 mx-lg-5"><a class="navbar-brand primary-font text-wrap" href=/><img src=/logo.png width=30 height=30 class="d-inline-block align-top">
Bob Law</a><div><input id=search autocomplete=off class="form-control mr-sm-2 d-none d-md-block" placeholder=Search... aria-label=Search oninput=searchOnChange(event)></div><button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarContent aria-controls=navbarContent aria-expanded=false aria-label="Toggle navigation"><svg aria-hidden="true" height="24" viewBox="0 0 16 16" width="24" data-view-component="true"><path fill-rule="evenodd" d="M1 2.75A.75.75.0 011.75 2h12.5a.75.75.0 110 1.5H1.75A.75.75.0 011 2.75zm0 5A.75.75.0 011.75 7h12.5a.75.75.0 110 1.5H1.75A.75.75.0 011 7.75zM1.75 12a.75.75.0 100 1.5h12.5a.75.75.0 100-1.5H1.75z"/></svg></button><div class="collapse navbar-collapse text-wrap primary-font" id=navbarContent><ul class="navbar-nav ms-auto text-center"><li class="nav-item navbar-text d-block d-md-none"><div class=nav-link><input id=search autocomplete=off class="form-control mr-sm-2" placeholder=Search... aria-label=Search oninput=searchOnChange(event)></div></li><li class="nav-item navbar-text"><a class=nav-link href=/#about aria-label=about>About</a></li><li class="nav-item navbar-text"><a class=nav-link href=/#experience aria-label=experience>Experience</a></li><li class="nav-item navbar-text"><a class=nav-link href=/#education aria-label=education>Education</a></li><li class="nav-item navbar-text"><a class=nav-link href=/posts title>Posts</a></li><li class="nav-item navbar-text"><a class=nav-link href=/tags title>Tags</a></li><li class="nav-item navbar-text"><a class=nav-link href=/topics title>Topics</a></li><li class="nav-item navbar-text"><div class=text-center><button id=theme-toggle><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></li></ul></div></div></nav></header><div id=content><section id=single><div class=container><div class="row justify-content-center"><div class="col-sm-12 col-md-12 col-lg-9"><div class=pr-lg-4><div class="title mb-5"><h1 class="text-center mb-4"></h1><div class=text-center>Jan 1, 1010
<span id=readingTime>min read</span></div></div><article class="page-content p-2"><h1 id=constants>Constants</h1><p>Last time, we talked about how to add attributes to vertices so we could fill our triangle with smoothly shaded colors. In this article we will talk about how to pass constant data to shaders, which remains the same for all vertices in a draw call.</p><h2 id=constant-data>Constant Data</h2><p>We call this data <em>constant</em> data because it doesn’t change between invocations of the shader function. This contrasts with both attribute data, which can change per-vertex, and interpolated data, which can change per-fragment. Some APIs (notably OpenGL) call these types of constant values <em>uniforms</em>, while most others use the term <em>constants</em>.</p><p>Like vertices, constant shader parameters can be ordinary types like <code>float</code>, <code>float2</code>, etc.; or they can be structs. It is often useful to collect together the constants that change at the same “frequency”—per frame, per draw call, etc.—so as to minimize the number of times you need to set buffers on the command encoder.</p><h2 id=getting-constants-into-shaders>Getting Constants into Shaders</h2><p>Suppose we want to animate the triangle we have been drawing in the past several articles. One of the simplest things we could do is provide a vector that we use to offset the position of each vertex. By updating this vector over time, we could make the triangle move around the screen.</p><p>We can achieve this effect by using a dynamic constant in our vertex shader. The phrase “dynamic constant” might seem like a contradiction in terms, but it really just refers to constants that change over time and less often than once per draw call.</p><p>We modify the vertex function to take a constant reference to <code>float2</code> and indicate that it will be available in buffer 1, since buffer 0 holds our vertex data:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Swift data-lang=Swift><span style=display:flex><span>vertex VertexOut vertex_main(
</span></span><span style=display:flex><span>    VertexIn <span style=color:#66d9ef>in</span> [[stage_in]],
</span></span><span style=display:flex><span>    constant float2 &amp;positionOffset [[buffer(<span style=color:#ae81ff>1</span>)]])
</span></span></code></pre></div><p>We update the body of the vertex function to add this offset vector to the current vertex’s position, moving by the specified amount in NDC space:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Swift data-lang=Swift><span style=display:flex><span>out.position = float4(<span style=color:#66d9ef>in</span>.position <span style=color:#f92672>+</span> positionOffset, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.0</span>);
</span></span></code></pre></div><p>To get the constant data into the shader, we use the exact same method to bind the constant buffer that we used to bind the vertex buffer. We bind it to buffer slot 1, corresponding to the <code>buffer(1)</code> in the shader code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Swift data-lang=Swift><span style=display:flex><span>renderCommandEncoder.setVertexBuffer(
</span></span><span style=display:flex><span>    constantBuffer, 
</span></span><span style=display:flex><span>    offset: currentConstantBufferOffset, 
</span></span><span style=display:flex><span>    index: <span style=color:#ae81ff>1</span>)
</span></span></code></pre></div><p>Notice that we supply an offset when binding the buffer, which we haven’t done before. To understand why, we need to talk a little about multiple buffering and data synchronization.</p><h2 id=triple-buffering>Triple Buffering</h2><p>Recall that the CPU and GPU work in parallel: the GPU might be running previously-encoded commands while we’re encoding the next frame on the CPU. For this reason, we need to ensure that we don’t change data out from under the GPU, which could cause corruption or even a crash.</p><p>By default, a Metal layer has three drawables available. Since we need a drawable (and the texture it contains) in order to encode a frame, say that a view can have up to three frames “in flight” at a time.</p><p>We declare a global constant to indicate that we allow up to three frames to be processing at once (this is called “triple buffering”):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Swift data-lang=Swift><span style=display:flex><span><span style=color:#66d9ef>let</span> MaxOutstandingFrameCount = <span style=color:#ae81ff>3</span>
</span></span></code></pre></div><p>To help keep track of which frame we’re rendering, we’ll add a frame count member to the renderer class, which we’ll increment once we’re done encoding each frame:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Swift data-lang=Swift><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> frameIndex: Int
</span></span></code></pre></div><p>Since we can have three frames in flight, we also allocate three memory regions for our constants, to ensure that the constants we wrote for a previous frame don’t get overwritten before the GPU is done with them.</p><p>We don’t need to allocate three separate buffers to hold our per-frame constants. Instead, we can allocate a buffer that is three times the necessary size, and use a per-frame offset to determine the correct region to write into.</p><p>We’ll add several members to our renderer class to keep track of the constant buffer, the size and stride of the constant data, and the offset into the constant buffer that corresponds to the current frame:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Swift data-lang=Swift><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> constantsBuffer: MTLBuffer!
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>let</span> constantsSize: Int
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>let</span> constantsStride: Int
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> constantsBufferOffset: Int
</span></span></code></pre></div><p>We set up these values in our initializer:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Swift data-lang=Swift><span style=display:flex><span><span style=color:#66d9ef>self</span>.frameIndex = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>self</span>.constantsSize = MemoryLayout&lt;SIMD2&lt;Float&gt;<span style=color:#f92672>&gt;</span>.size
</span></span><span style=display:flex><span><span style=color:#66d9ef>self</span>.constantsStride = align(constantsSize, upTo: <span style=color:#ae81ff>256</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>self</span>.constantsBufferOffset = <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>Note that we store the size and stride of the constants separately. Even though the constants themselves are quite small (only 8 bytes in total), some GPUs have a limit on how granular the buffer offset can be. Therefore, in this case, the stride is 256 bytes per constant vector.</p><p>Now that we know how big our constant buffer needs to be, we allocate it in the <code>makeResources()</code> method:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Swift data-lang=Swift><span style=display:flex><span>constantBuffer = device.makeBuffer(
</span></span><span style=display:flex><span>    length: constantsStride <span style=color:#f92672>*</span> MaxOutstandingFrameCount,
</span></span><span style=display:flex><span>    options: .storageModeShared)
</span></span></code></pre></div><h2 id=data-synchronization>Data Synchronization</h2><p>We know we have enough space to store three frames’ worth of constants, but how to we ensure that we access each region at the right time? We need some kind of synchronization primitive that lets us encode up to three frames, but then waits until one completes before beginning the next.</p><p>It turns out that the Dispatch framework has just the thing: <code>DispatchSemaphore</code>, which is a “counting semaphore” implementation.</p><p>We initialize a Dispatch semaphore with a value that will be decremented at the start of each frame and incremented at the end of each frame. Any time its value is zero, asking it to decrement will cause it to first block the current thread until it is incremented on another thread.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Swift data-lang=Swift><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> frameSemaphore = DispatchSemaphore(value: 
</span></span><span style=display:flex><span>    MaxOutstandingFrameCount)
</span></span></code></pre></div><p>We structure our draw method around this semaphore. Upon entry to the <code>draw(in:)</code> method, we wait on the semaphore, then we encode our rendering work, then we add a completed handler to the command buffer that will increment the semaphore (by calling <code>signal()</code>). Before returning we increment the frame count.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Swift data-lang=Swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>draw</span>(<span style=color:#66d9ef>in</span> view: MTKView) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// This blocks if three frames are already underway</span>
</span></span><span style=display:flex><span>    frameSemaphore.wait() 
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    updateConstants()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// … encode work …</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    commandBuffer.addCompletedHandler { [<span style=color:#66d9ef>weak</span> <span style=color:#66d9ef>self</span>] <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// This unblocks the waiting thread, if any</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>self</span>?.frameSemaphore.signal()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    frameIndex <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We already saw above how to bind the constant buffer prior to issuing our draw call; everything else about our render command encoding is the same.</p><h2 id=updating-per-frame-constants>Updating Per-Frame Constants</h2><p>Updating the constants consists of calculating the position offset vector from the current time, then writing the vector into the constant buffer at the current offset. We add an <code>updateConstants()</code> method to do this work.</p><p>First, the offset vector calculation. We take the current time, turn it into a rotation angle by multiplying it by a speed factor and taking the result mod 2π. Then we find the vector by taking the cosine and size of the angle as our x and y coordinates, respectively:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Swift data-lang=Swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>updateConstants</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> time = CACurrentMediaTime()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> speedFactor = <span style=color:#ae81ff>3.0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> rotationAngle = Float(fmod(speedFactor <span style=color:#f92672>*</span> time, .pi <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> rotationMagnitude: Float = <span style=color:#ae81ff>0.1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> positionOffset = 
</span></span><span style=display:flex><span>        rotationMagnitude <span style=color:#f92672>*</span> SIMD2&lt;Float&gt;(cos(rotationAngle), 
</span></span><span style=display:flex><span>                                         sin(rotationAngle))
</span></span><span style=display:flex><span>                 
</span></span><span style=display:flex><span>    <span style=color:#75715e>// …</span>
</span></span></code></pre></div><p>To determine where we will write the vector, we find the constant buffer offset. It is equal to the current frame index modulo the maximum frame index (3) multiplied by the constants stride:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Swift data-lang=Swift><span style=display:flex><span>constantsBufferOffset = 
</span></span><span style=display:flex><span>    (frameIndex <span style=color:#f92672>%</span> MaxOutstandingFrameCount) <span style=color:#f92672>*</span> constantsStride
</span></span></code></pre></div><p>The expression <code>frameIndex % MaxOutstandingFrameCount</code> cycles through the sequence 0, 1, 2, 0, 1, 2, etc., so after we write the constants for the third frame, we reuse the region of the buffer that was used for the first frame. This type of structure is called a <em>circular buffer</em> or <em>ring buffer</em>.</p><p>To get a pointer to the current constant buffer region, we use the <code>advanced(by:)</code> method on the <code>contents()</code> pointer of the buffer. We then copy the position offset vector into the buffer with the <code>copyMemory(from:byteCount:)</code> method.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Swift data-lang=Swift><span style=display:flex><span>    <span style=color:#66d9ef>let</span> constants = constantsBuffer.contents()
</span></span><span style=display:flex><span>        .advanced(by: constantsBufferOffset)
</span></span><span style=display:flex><span>    constants.copyMemory(from: &amp;positionOffset, 
</span></span><span style=display:flex><span>                         byteCount: constantsSize)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If we build and run our updated app, we can see the triangle gently circling the screen:</p><p><img src=sample.png alt=Result></p><p>Next time, we’ll look at some 2D math that will help us leverage the power of animation and interaction in the future.</p></article></div></div><div class="col-sm-12 col-md-12 col-lg-3"><div id=stickySideBar class=sticky-sidebar><aside class=toc><h5>Table Of Contents</h5><div class=toc-content><nav id=TableOfContents><ul><li><a href=#constant-data>Constant Data</a></li><li><a href=#getting-constants-into-shaders>Getting Constants into Shaders</a></li><li><a href=#triple-buffering>Triple Buffering</a></li><li><a href=#data-synchronization>Data Synchronization</a></li><li><a href=#updating-per-frame-constants>Updating Per-Frame Constants</a></li></ul></nav></div></aside><aside class=social><h5>Social</h5><div class=social-content><ul class=list-inline><li class="list-inline-item text-center"><a target=_blank href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fbobblelaw.github.io%2ftopics%2fmetal%2fthirty-days-of-metal%2f09-constants%2f"><i class="fab fa-linkedin"></i></a></li><li class="list-inline-item text-center"><a target=_blank href="https://twitter.com/share?text=&url=https%3a%2f%2fbobblelaw.github.io%2ftopics%2fmetal%2fthirty-days-of-metal%2f09-constants%2f"><i class="fab fa-twitter"></i></a></li><li class="list-inline-item text-center"><a target=_blank href="https://api.whatsapp.com/send?text=: https%3a%2f%2fbobblelaw.github.io%2ftopics%2fmetal%2fthirty-days-of-metal%2f09-constants%2f"><i class="fab fa-whatsapp"></i></a></li><li class="list-inline-item text-center"><a target=_blank href='mailto:?subject=&amp;body=Check%20out%20this%20site https%3a%2f%2fbobblelaw.github.io%2ftopics%2fmetal%2fthirty-days-of-metal%2f09-constants%2f'><i class="fa fa-envelope"></i></a></li></ul></div></aside></div></div></div><div class=row><div class="col-sm-12 col-md-12 col-lg-9 p-4"></div></div></div><button class="p-2 px-3" onclick=topFunction() id=topScroll>
<i class="fas fa-angle-up"></i></button></section><div class=progress><div id=scroll-progress-bar class=progress-bar role=progressbar aria-valuenow=0 aria-valuemin=0 aria-valuemax=100></div></div><script src=/js/scrollProgressBar.js></script><script>var topScroll=document.getElementById("topScroll");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?topScroll.style.display="block":topScroll.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}let stickySideBarElem=document.getElementById("stickySideBar"),stickyNavBar=!0;if(stickyNavBar){let e=document.getElementById("profileHeader"),t=e.offsetHeight+15;stickySideBarElem.style.top=t+"px"}else stickySideBarElem.style.top="50px"</script><script src=/js/readingTime.js></script></div><footer><div class="text-center pt-2"><span class=px-1><a href=https://github.com/BobbleLaw aria-label=github><svg width="2.7em" height="2.7em" viewBox="0 0 1792 1792"><path id="footer-socialNetworks-github-svg-path" d="M522 1352q-8 9-20-3-13-11-4-19 8-9 20 3 12 11 4 19zm-42-61q9 12 0 19-8 6-17-7t0-18q9-7 17 6zm-61-60q-5 7-13 2-10-5-7-12 3-5 13-2 10 5 7 12zm31 34q-6 7-16-3-9-11-2-16 6-6 16 3 9 11 2 16zm129 112q-4 12-19 6-17-4-13-15t19-7q16 5 13 16zm63 5q0 11-16 11-17 2-17-11 0-11 16-11 17-2 17 11zm58-10q2 10-14 14t-18-8 14-15q16-2 18 9zm964-956v960q0 119-84.5 203.5T1376 1664h-224q-16 0-24.5-1t-19.5-5-16-14.5-5-27.5v-239q0-97-52-142 57-6 102.5-18t94-39 81-66.5 53-105T1386 856q0-121-79-206 37-91-8-204-28-9-81 11t-92 44l-38 24q-93-26-192-26t-192 26q-16-11-42.5-27T578 459.5 492 446q-44 113-7 204-79 85-79 206 0 85 20.5 150t52.5 105 80.5 67 94 39 102.5 18q-40 36-49 103-21 10-45 15t-57 5-65.5-21.5T484 1274q-19-32-48.5-52t-49.5-24l-20-3q-21 0-29 4.5t-5 11.5 9 14 13 12l7 5q22 10 43.5 38t31.5 51l10 23q13 38 44 61.5t67 30 69.5 7 55.5-3.5l23-4q0 38 .5 103t.5 68q0 22-11 33.5t-22 13-33 1.5H416q-119 0-203.5-84.5T128 1376V416q0-119 84.5-203.5T416 128h960q119 0 203.5 84.5T1664 416z"/></svg>
</a></span><span class=px-1><a href=https://www.linkedin.com/in/boblzy aria-label=linkedin><svg width="2.4em" height="2.4em" fill="#fff" aria-label="LinkedIn" viewBox="0 0 512 512"><rect width="512" height="512" fill="#0077b5" rx="15%"/><circle cx="142" cy="138" r="37"/><path stroke="#fff" stroke-width="66" d="M244 194v198M142 194v198"/><path d="M276 282c0-20 13-40 36-40 24 0 33 18 33 45v105h66V279c0-61-32-89-76-89-34 0-51 19-59 32"/></svg></a></span></div><div class="container py-4"><div class="row justify-content-center"><div class="col-md-4 text-center"><div class=pb-2><a href=https://bobblelaw.github.io/ title="Bobble Law"><img alt="Footer logo" src=/logo.png height=40px width=40px></a></div>&copy; 2025 All rights reserved<div class=text-secondary>Made with
<span class=text-danger>&#10084;
</span>and
<a href=https://github.com/gurusabarish/hugo-profile target=_blank title="Designed and developed by gurusabarish">Hugo Profile</a></div></div></div></div></footer><script src=/bootstrap-5/js/bootstrap.bundle.min.js></script><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))});var tooltipTriggerList=[].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]')),tooltipList=tooltipTriggerList.map(function(e){return new bootstrap.Tooltip(e)})</script><script src=/js/search.js></script><section id=search-content class=py-2><div class=container id=search-results></div></section></body></html>