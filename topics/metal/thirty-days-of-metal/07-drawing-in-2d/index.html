<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta http-equiv=Accept-CH content="DPR, Viewport-Width, Width"><link rel=icon href=/logo.png type=image/gif><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" media=print onload='this.media="all"'><noscript><link href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel=stylesheet></noscript><link rel=stylesheet href=/css/font.css media=all><meta property="og:url" content="https://bobblelaw.github.io/topics/metal/thirty-days-of-metal/07-drawing-in-2d/"><meta property="og:site_name" content="Bobble Law"><meta property="og:title" content="Bobble Law"><meta property="og:description" content="Drawing in 2D Last time, we looked at how to create compute pipeline states from kernel functions so we can perform arbitrary computation on the GPU. This time, we’ll focus on a different kind of pipeline state: render pipeline states.
When you have to manage a lot of the moving parts yourself, rendering is a pretty complex task. By now, you probably appreciate just how much more work it is to do anything with Metal than other graphics APIs. Maybe you’ve also gotten a glimpse of how much more powerful and flexible Metal is as a GPU-oriented API. Or maybe not. But pretty soon, you’ll have a much better feel for your latent Metal superpowers."><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="article:section" content="topics"><meta name=twitter:card content="summary"><meta name=twitter:title content="Bobble Law"><meta name=twitter:description content="Drawing in 2D Last time, we looked at how to create compute pipeline states from kernel functions so we can perform arbitrary computation on the GPU. This time, we’ll focus on a different kind of pipeline state: render pipeline states.
When you have to manage a lot of the moving parts yourself, rendering is a pretty complex task. By now, you probably appreciate just how much more work it is to do anything with Metal than other graphics APIs. Maybe you’ve also gotten a glimpse of how much more powerful and flexible Metal is as a GPU-oriented API. Or maybe not. But pretty soon, you’ll have a much better feel for your latent Metal superpowers."><link rel=stylesheet href=/bootstrap-5/css/bootstrap.min.css media=all><link rel=stylesheet href=/css/header.css media=all><link rel=stylesheet href=/css/footer.css media=all><link rel=stylesheet href=/css/theme.css media=all><style>:root{--text-color:#343a40;--text-secondary-color:#6c757d;--text-link-color:#007bff;--background-color:#eaedf0;--secondary-background-color:#64ffda1a;--primary-color:#007bff;--secondary-color:#f8f9fa;--text-color-dark:#e4e6eb;--text-secondary-color-dark:#b0b3b8;--text-link-color-dark:#ffffff;--background-color-dark:#18191a;--secondary-background-color-dark:#212529;--primary-color-dark:#ffffff;--secondary-color-dark:#212529}body{font-size:1rem;font-weight:400;line-height:1.5;text-align:left}html{background-color:var(--background-color)!important}body::-webkit-scrollbar{height:0;width:8px;background-color:var(--background-color)}::-webkit-scrollbar-track{border-radius:1rem}::-webkit-scrollbar-thumb{border-radius:1rem;background:#b0b0b0;outline:1px solid var(--background-color)}#search-content::-webkit-scrollbar{width:.5em;height:.1em;background-color:var(--background-color)}</style><meta name=description content><link rel=stylesheet href=/css/single.css><script defer src=/fontawesome-6/all-6.4.2.js></script><title>| Bobble Law</title></head><body class=light><script>let localStorageValue=localStorage.getItem("pref-theme"),mediaQuery=window.matchMedia("(prefers-color-scheme: dark)").matches;switch(localStorageValue){case"dark":document.body.classList.add("dark");break;case"light":document.body.classList.remove("dark");break;default:mediaQuery&&document.body.classList.add("dark");break}</script><script>var prevScrollPos=window.pageYOffset;window.addEventListener("scroll",function(){let s=document.getElementById("profileHeader"),t=window.pageYOffset,n=!1,o=!0,i=o?prevScrollPos>t:t>0;i?s.classList.add("showHeaderOnTop"):n=!0,t===0&&(n=!0),n&&s.classList.remove("showHeaderOnTop"),prevScrollPos=t})</script><header id=profileHeader><nav class="pt-3 navbar navbar-expand-lg animate"><div class="container-fluid mx-xs-2 mx-sm-5 mx-md-5 mx-lg-5"><a class="navbar-brand primary-font text-wrap" href=/><img src=/logo.png width=30 height=30 class="d-inline-block align-top">
Bob Law</a><div><input id=search autocomplete=off class="form-control mr-sm-2 d-none d-md-block" placeholder=Search... aria-label=Search oninput=searchOnChange(event)></div><button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarContent aria-controls=navbarContent aria-expanded=false aria-label="Toggle navigation"><svg aria-hidden="true" height="24" viewBox="0 0 16 16" width="24" data-view-component="true"><path fill-rule="evenodd" d="M1 2.75A.75.75.0 011.75 2h12.5a.75.75.0 110 1.5H1.75A.75.75.0 011 2.75zm0 5A.75.75.0 011.75 7h12.5a.75.75.0 110 1.5H1.75A.75.75.0 011 7.75zM1.75 12a.75.75.0 100 1.5h12.5a.75.75.0 100-1.5H1.75z"/></svg></button><div class="collapse navbar-collapse text-wrap primary-font" id=navbarContent><ul class="navbar-nav ms-auto text-center"><li class="nav-item navbar-text d-block d-md-none"><div class=nav-link><input id=search autocomplete=off class="form-control mr-sm-2" placeholder=Search... aria-label=Search oninput=searchOnChange(event)></div></li><li class="nav-item navbar-text"><a class=nav-link href=/#about aria-label=about>About</a></li><li class="nav-item navbar-text"><a class=nav-link href=/#experience aria-label=experience>Experience</a></li><li class="nav-item navbar-text"><a class=nav-link href=/#education aria-label=education>Education</a></li><li class="nav-item navbar-text"><a class=nav-link href=/posts title>Posts</a></li><li class="nav-item navbar-text"><a class=nav-link href=/tags title>Tags</a></li><li class="nav-item navbar-text"><a class=nav-link href=/topics title>Topics</a></li><li class="nav-item navbar-text"><div class=text-center><button id=theme-toggle><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></li></ul></div></div></nav></header><div id=content><section id=single><div class=container><div class="row justify-content-center"><div class="col-sm-12 col-md-12 col-lg-9"><div class=pr-lg-4><div class="title mb-5"><h1 class="text-center mb-4"></h1><div class=text-center>Jan 1, 1010
<span id=readingTime>min read</span></div></div><article class="page-content p-2"><h1 id=drawing-in-2d>Drawing in 2D</h1><p>Last time, we looked at how to create compute pipeline states from kernel functions so we can perform arbitrary computation on the GPU. This time, we’ll focus on a different kind of pipeline state: <em>render pipeline states</em>.</p><p>When you have to manage a lot of the moving parts yourself, rendering is a pretty complex task. By now, you probably appreciate just how much more work it is to do anything with Metal than other graphics APIs. Maybe you’ve also gotten a glimpse of how much more powerful and flexible Metal is as a GPU-oriented API. Or maybe not. But pretty soon, you’ll have a much better feel for your latent Metal superpowers.</p><p>We will be building on the <code>MTKView</code> sample app from Day 4, so consider refreshing your memory on that before continuing.</p><h2 id=the-graphics-pipeline>The Graphics Pipeline</h2><p>We often use the phrase “graphics pipeline” to describe the series of stages data flows through to produce digital pictures. At the start of the pipeline, we have a set of geometric data (vertices) that represent the object(s) we want to draw. At the end of the pipeline, we have pixels in a texture.</p><p>Here is a greatly simplified diagram of the process:</p><p><img src=sample.png alt="Simplied rendering pipeline"></p><p>The light blue boxes in this figure represent “programmable” stages, portions of the pipeline where we are responsible for writing shader code. We have already seen examples of vertex and fragment functions, but have not really begun to use them in earnest.</p><p>In brief, the vertex shader reads vertex data and outputs the position of the vertex, along with any other per-vertex data needed by the rest of the pipeline. Vertices are then gathered together into primitives (points, lines, and triangles). Then, the rasterizer determines which pixels belong to each primitive and <em>interpolates</em> the values between the vertices. These interpolated vertex properties are fed into the fragment shader, which calculates the color of the fragment. That color is then combined with the existing color in the output color texture. Once this process has run for each vertex, primitive, and fragment, the picture is complete.</p><p>The rest of this article will cover what the jobs of the vertex and fragment shader are in more detail, as well as how we build render pipeline state objects from them and use those to encode draw commands.</p><p>We will reuse the vertex and fragment shader functions we wrote on Day 5. I’ve included them here for your convenience:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;metal_stdlib&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> metal;
</span></span><span style=display:flex><span>vertex float4 <span style=color:#a6e22e>vertex_main</span>(device float2 <span style=color:#66d9ef>const</span><span style=color:#f92672>*</span> positions [[buffer(<span style=color:#ae81ff>0</span>)]], uint vertexID <span style=color:#a6e22e>[[vertex_id]]</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    float2 position <span style=color:#f92672>=</span> positions[vertexID];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> float4(position, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.0</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fragment float4 <span style=color:#a6e22e>fragment_main</span>(float4 position <span style=color:#a6e22e>[[stage_in]]</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> float4(<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.0</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=coordinate-spaces-briefly>Coordinate Spaces, Briefly</h2><p>When we talk about positions, it is important to realize that positions are relative to some <em>coordinate system</em>.</p><p>A coordinate system consists of a point called the <em>origin</em> and a set of perpendicular unit-length <em>axes</em>. Given a coordinate system, a given point can be assigned a list of coordinates specifying how far away the point is from the origin along each axis. In 2D, we use x and y to denote these coordinates, while in 3D we add a z coordinate. So the point <code>(1, 3, 2)</code> is one unit (right) along the x axis, three units (up) along the y axis, and two units (toward us) along the z axis away from the origin. Because the origin is zero units away from itself, it is labeled <code>(0, 0, 0)</code>.</p><p>We will learn in future articles how to transform points from one coordinate system to another. For the time being, we won’t worry too much about that. Just know that sometimes, it’s easier to work in one system versus another, and there is a way to move between them.</p><h2 id=normalized-device-coordinates>Normalized Device Coordinates</h2><p>In graphics, it is often useful to use “normalized” coordinate systems, where some significance is attached to the positions that are one unit away from the origin. One such space is <em>normalized device coordinate</em> (NDC) space, illustrated here:</p><p><img src=ndc.png alt=NDC></p><p>What is the significance of the values -1 and 1 in NDC space? You can think of them as the boundaries of the picture we’re drawing. For example, the point (1, 1) is at the top right of NDC, while the point (-1, -1) is at the bottom left. This is true regardless of the resolution (size) of the image, which is what makes NDC space convenient to work in.</p><p>The main purpose of a vertex function is to determine the position of each vertex. But in what space are these positions defined? For now, you can think of them as being in normalized device coordinates. (This is a lie, but it’s one of those very useful lies.) This means that we’ll be defining our shapes to draw with points whose x and y values are all between -1 and 1.</p><h2 id=a-renderer-class>A Renderer Class</h2><p>Now that we are starting to write more code in our sample apps, it is convenient to refactor some of the rendering code into its own class.</p><p>We define a Renderer class that holds the various Metal objects. Here is the part of the class definition that declares these members:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Swift data-lang=Swift><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Renderer</span>: NSObject, MTKViewDelegate {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> device: MTLDevice
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> commandQueue: MTLCommandQueue
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> view: MTKView
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> renderPipelineState: MTLRenderPipelineState!
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> vertexBuffer: MTLBuffer!
</span></span></code></pre></div><p>By now, you know that we need a command queue to send commands to the GPU, and we need an <code>MTKView</code> to present our drawings to the screen. We also have a member of type <code>MTLRenderPipelineState</code>, which is a new pipeline state type we will introduce below.</p><p>To initialize a renderer, we provide it with a Metal device and a view to draw into. The renderer configures the view and assigns itself as the view’s delegate so it knows when to draw.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Swift data-lang=Swift><span style=display:flex><span><span style=color:#66d9ef>init</span>(device: MTLDevice, view: MTKView) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>self</span>.device = device
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>self</span>.commandQueue = device.makeCommandQueue()<span style=color:#f92672>!</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>self</span>.view = view
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#66d9ef>init</span>()
</span></span><span style=display:flex><span>    view.device = device
</span></span><span style=display:flex><span>    view.delegate = <span style=color:#66d9ef>self</span>
</span></span><span style=display:flex><span>    view.clearColor = MTLClearColor(red: <span style=color:#ae81ff>0.95</span>, 
</span></span><span style=display:flex><span>                                    green: <span style=color:#ae81ff>0.95</span>, 
</span></span><span style=display:flex><span>                                    blue: <span style=color:#ae81ff>0.95</span>, 
</span></span><span style=display:flex><span>                                    alpha: <span style=color:#ae81ff>1.0</span>)
</span></span><span style=display:flex><span>    makePipeline()
</span></span><span style=display:flex><span>    makeResources()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To see how this simplifies our view controller, here’s the complete updated definition of the <code>ViewController</code> class:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Swift data-lang=Swift><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ViewController</span>: NSViewController {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>@IBOutlet</span> <span style=color:#66d9ef>weak</span> <span style=color:#66d9ef>var</span> mtkView: MTKView!
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> renderer: Renderer!
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>viewDidLoad</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>.viewDidLoad()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> device = MTLCreateSystemDefaultDevice()<span style=color:#f92672>!</span>
</span></span><span style=display:flex><span>        renderer = Renderer(device: device, view: mtkView)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We will return shortly to the <code>Renderer</code> class, but now we turn to the central topic of this article: render pipeline states.</p><h2 id=render-pipeline-states>Render Pipeline States</h2><p>As we saw last time, we use pipeline state objects to tell our command encoder which shader function we want to run when executing subsequent commands. For example, we set the compute pipeline state containing our <code>add_two_values</code> kernel function when we wanted to add the values in two buffers, then dispatched a grid telling the GPU how many work items to execute.</p><p>When we want to encode drawing commands, we need to provide a render pipeline state. A render pipeline state encompasses a vertex function, a fragment function, and other values used to configure the GPU to our preferences. Any drawing commands (draw calls) we issue after setting the render pipeline state on the encoder will use that pipeline state’s shaders to process the vertices and fragments of the draw call.</p><p>As with compute pipeline states, we create render pipeline states by requesting them from a device. However, because render pipelines are more complex than compute pipelines, we first fill out a render pipeline descriptor.</p><p>Render pipeline descriptors are an example of the <a href>parameter object pattern</a>. They gather the various parameters needed to create a render pipeline state together, so they can be passed to the pipeline state creation method all at once.</p><p>You may have noticed a call to the renderer’s <code>makePipeline()</code> method in the initializer above. This is where we will configure and create our pipeline state:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Swift data-lang=Swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makePipeline</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>guard</span> <span style=color:#66d9ef>let</span> library = device.makeDefaultLibrary() <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        fatalError(<span style=color:#e6db74>&#34;Unable to create default Metal library&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> renderPipelineDescriptor = MTLRenderPipelineDescriptor()
</span></span><span style=display:flex><span>    <span style=color:#75715e>//…</span>
</span></span></code></pre></div><p>First, we make sure we’re able to get the app’s default Metal shader library. Then we instantiate the render pipeline descriptor.</p><p>The vertex and fragment functions to run during the vertex and fragment stages of the pipeline are essential for doing anything useful, so we retrieve each function from the library and set it on the descriptor:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Swift data-lang=Swift><span style=display:flex><span>renderPipelineDescriptor.vertexFunction = library.makeFunction(name: <span style=color:#e6db74>&#34;vertex_main&#34;</span>)<span style=color:#f92672>!</span>
</span></span><span style=display:flex><span>renderPipelineDescriptor.fragmentFunction = library.makeFunction(name: <span style=color:#e6db74>&#34;fragment_main&#34;</span>)<span style=color:#f92672>!</span>
</span></span></code></pre></div><p>There are many, many other possible variables we could set on the descriptor, but for now, the only other essential one is the color attachment’s pixel format. This tells Metal the layout of the texture we will be drawing into. We set it to the color pixel format of the MTKView, since that is where our drawing will be happening.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Swift data-lang=Swift><span style=display:flex><span>renderPipelineDescriptor.colorAttachments[<span style=color:#ae81ff>0</span>].pixelFormat = view.colorPixelFormat
</span></span></code></pre></div><p>Finally, we ask the device to create the render pipeline state by calling the <code>makeRenderPipelineState(descriptor:)</code> method. This operation can fail—for example, if the descriptor is invalid—so we wrap it in a <code>do…catch</code> block:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Swift data-lang=Swift><span style=display:flex><span><span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>        renderPipelineState = <span style=color:#66d9ef>try</span> device.makeRenderPipelineState(descriptor: renderPipelineDescriptor)
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>catch</span> {
</span></span><span style=display:flex><span>        fatalError(<span style=color:#e6db74>&#34;Error while creating render pipeline state: </span><span style=color:#e6db74>\(</span>error<span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=preparing-the-vertex-buffer>Preparing the Vertex Buffer</h2><p>We’re almost ready to start drawing, but first we need something to draw. Let’s define a few points and write them into a buffer. We can define a new method called <code>makeResources()</code> in our renderer class to encapsulate this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Swift data-lang=Swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeResources</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> positions = [
</span></span><span style=display:flex><span>        SIMD2&lt;Float&gt;(<span style=color:#f92672>-</span><span style=color:#ae81ff>0.8</span>,  <span style=color:#ae81ff>0.4</span>),
</span></span><span style=display:flex><span>        SIMD2&lt;Float&gt;( <span style=color:#ae81ff>0.4</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>0.8</span>),
</span></span><span style=display:flex><span>        SIMD2&lt;Float&gt;( <span style=color:#ae81ff>0.8</span>,  <span style=color:#ae81ff>0.8</span>)
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>    vertexBuffer = device.makeBuffer(bytes: &amp;positions,
</span></span><span style=display:flex><span>                                     length: MemoryLayout&lt;SIMD2&lt;Float&gt;<span style=color:#f92672>&gt;</span>.stride <span style=color:#f92672>*</span> positions.count,
</span></span><span style=display:flex><span>                                     options: .storageModeShared)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We use a different buffer creation method called <code>makeBuffer(bytes:length:options)</code> this time, since we have created the list of vertex positions in advance. This creates the buffer and copies the positions into it in one step. We could also have used the <code>makeBuffer(length:options:)</code> method as we did before, but then we’d have to copy the points in separately.</p><p>Note that the x and y coordinates of each point are between -1 and 1. This means that once they pass through the vertex function, they will be in NDC space already. If you can’t quite visualize where they are, consider drawing a graph and plotting them, then noticing that they can be joined into a large triangle.</p><h1 id=encoding-draw-calls>Encoding Draw Calls</h1><p>Since we have made our renderer the delegate of our <code>MTKView</code>, its <code>draw(in:) </code>method will be called each frame to update the view’s contents.</p><p>As we did when clearing the view on Day 4, we start our draw method by asking the view for its current render pass descriptor, then making a command buffer:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Swift data-lang=Swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>draw</span>(<span style=color:#66d9ef>in</span> view: MTKView) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>guard</span> <span style=color:#66d9ef>let</span> renderPassDescriptor = view.currentRenderPassDescriptor <span style=color:#66d9ef>else</span> { <span style=color:#66d9ef>return</span> }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>guard</span> <span style=color:#66d9ef>let</span> commandBuffer = commandQueue.makeCommandBuffer() <span style=color:#66d9ef>else</span> { <span style=color:#66d9ef>return</span> }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//…</span>
</span></span></code></pre></div><p>We know we’ll be issuing render commands, so we create a render command encoder from the pass descriptor:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Swift data-lang=Swift><span style=display:flex><span><span style=color:#66d9ef>let</span> renderCommandEncoder = commandBuffer.makeRenderCommandEncoder(descriptor: renderPassDescriptor)<span style=color:#f92672>!</span>
</span></span></code></pre></div><p>When we want to draw something, we do it in three steps:</p><ol><li>Set any state we want on the render command encoder, including the render pipeline state object.</li><li>Set any resources we want to use in our draw calls; in this case, that’s just the buffer containing the vertex positions</li><li>Encode draw calls, describing the types of primitive to draw and the number of vertices to use.</li></ol><p>Below, each of these steps is executed in turn. We’ll be drawing one triangle, so we specify <code>.triangle</code> as the primitive type and <code>3</code> as the vertex count:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Swift data-lang=Swift><span style=display:flex><span>renderCommandEncoder.setRenderPipelineState(renderPipelineState)
</span></span><span style=display:flex><span>renderCommandEncoder.setVertexBuffer(vertexBuffer, offset: <span style=color:#ae81ff>0</span>, index: <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>renderCommandEncoder.drawPrimitives(type: .triangle, vertexStart: <span style=color:#ae81ff>0</span>, vertexCount: <span style=color:#ae81ff>3</span>)
</span></span></code></pre></div><p>We can issue as many draw calls as we want in each encoder, even switching between render pipeline states between them if we want.</p><p>For now, we’re just trying to get our first triangle on the screen, so we do our usual work to end the frame: end encoding, present the drawable, and commit the command buffer.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Swift data-lang=Swift><span style=display:flex><span>renderCommandEncoder.endEncoding()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>commandBuffer.present(view.currentDrawable!)
</span></span><span style=display:flex><span>commandBuffer.commit()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If all has gone according to plan, we can build and run to see the results of our labors: the first triangle, with many more to come.</p><p><img src=result.png alt=Result></p><p>After learning a lot of concepts and writing a lot of code, we finally achieved our first milestone: drawing a triangle on the screen. In the next article, we’ll talk about how to extend the amount of data processed by our pipeline by adding more attributes to our vertices. Stay tuned!</p></article></div></div><div class="col-sm-12 col-md-12 col-lg-3"><div id=stickySideBar class=sticky-sidebar><aside class=toc><h5>Table Of Contents</h5><div class=toc-content><nav id=TableOfContents><ul><li><a href=#the-graphics-pipeline>The Graphics Pipeline</a></li><li><a href=#coordinate-spaces-briefly>Coordinate Spaces, Briefly</a></li><li><a href=#normalized-device-coordinates>Normalized Device Coordinates</a></li><li><a href=#a-renderer-class>A Renderer Class</a></li><li><a href=#render-pipeline-states>Render Pipeline States</a></li><li><a href=#preparing-the-vertex-buffer>Preparing the Vertex Buffer</a></li></ul></nav></div></aside><aside class=social><h5>Social</h5><div class=social-content><ul class=list-inline><li class="list-inline-item text-center"><a target=_blank href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fbobblelaw.github.io%2ftopics%2fmetal%2fthirty-days-of-metal%2f07-drawing-in-2d%2f"><i class="fab fa-linkedin"></i></a></li><li class="list-inline-item text-center"><a target=_blank href="https://twitter.com/share?text=&url=https%3a%2f%2fbobblelaw.github.io%2ftopics%2fmetal%2fthirty-days-of-metal%2f07-drawing-in-2d%2f"><i class="fab fa-twitter"></i></a></li><li class="list-inline-item text-center"><a target=_blank href="https://api.whatsapp.com/send?text=: https%3a%2f%2fbobblelaw.github.io%2ftopics%2fmetal%2fthirty-days-of-metal%2f07-drawing-in-2d%2f"><i class="fab fa-whatsapp"></i></a></li><li class="list-inline-item text-center"><a target=_blank href='mailto:?subject=&amp;body=Check%20out%20this%20site https%3a%2f%2fbobblelaw.github.io%2ftopics%2fmetal%2fthirty-days-of-metal%2f07-drawing-in-2d%2f'><i class="fa fa-envelope"></i></a></li></ul></div></aside></div></div></div><div class=row><div class="col-sm-12 col-md-12 col-lg-9 p-4"></div></div></div><button class="p-2 px-3" onclick=topFunction() id=topScroll>
<i class="fas fa-angle-up"></i></button></section><div class=progress><div id=scroll-progress-bar class=progress-bar role=progressbar aria-valuenow=0 aria-valuemin=0 aria-valuemax=100></div></div><script src=/js/scrollProgressBar.js></script><script>var topScroll=document.getElementById("topScroll");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?topScroll.style.display="block":topScroll.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}let stickySideBarElem=document.getElementById("stickySideBar"),stickyNavBar=!0;if(stickyNavBar){let e=document.getElementById("profileHeader"),t=e.offsetHeight+15;stickySideBarElem.style.top=t+"px"}else stickySideBarElem.style.top="50px"</script><script src=/js/readingTime.js></script></div><footer><div class="text-center pt-2"><span class=px-1><a href=https://github.com/BobbleLaw aria-label=github><svg width="2.7em" height="2.7em" viewBox="0 0 1792 1792"><path id="footer-socialNetworks-github-svg-path" d="M522 1352q-8 9-20-3-13-11-4-19 8-9 20 3 12 11 4 19zm-42-61q9 12 0 19-8 6-17-7t0-18q9-7 17 6zm-61-60q-5 7-13 2-10-5-7-12 3-5 13-2 10 5 7 12zm31 34q-6 7-16-3-9-11-2-16 6-6 16 3 9 11 2 16zm129 112q-4 12-19 6-17-4-13-15t19-7q16 5 13 16zm63 5q0 11-16 11-17 2-17-11 0-11 16-11 17-2 17 11zm58-10q2 10-14 14t-18-8 14-15q16-2 18 9zm964-956v960q0 119-84.5 203.5T1376 1664h-224q-16 0-24.5-1t-19.5-5-16-14.5-5-27.5v-239q0-97-52-142 57-6 102.5-18t94-39 81-66.5 53-105T1386 856q0-121-79-206 37-91-8-204-28-9-81 11t-92 44l-38 24q-93-26-192-26t-192 26q-16-11-42.5-27T578 459.5 492 446q-44 113-7 204-79 85-79 206 0 85 20.5 150t52.5 105 80.5 67 94 39 102.5 18q-40 36-49 103-21 10-45 15t-57 5-65.5-21.5T484 1274q-19-32-48.5-52t-49.5-24l-20-3q-21 0-29 4.5t-5 11.5 9 14 13 12l7 5q22 10 43.5 38t31.5 51l10 23q13 38 44 61.5t67 30 69.5 7 55.5-3.5l23-4q0 38 .5 103t.5 68q0 22-11 33.5t-22 13-33 1.5H416q-119 0-203.5-84.5T128 1376V416q0-119 84.5-203.5T416 128h960q119 0 203.5 84.5T1664 416z"/></svg>
</a></span><span class=px-1><a href=https://www.linkedin.com/in/boblzy aria-label=linkedin><svg width="2.4em" height="2.4em" fill="#fff" aria-label="LinkedIn" viewBox="0 0 512 512"><rect width="512" height="512" fill="#0077b5" rx="15%"/><circle cx="142" cy="138" r="37"/><path stroke="#fff" stroke-width="66" d="M244 194v198M142 194v198"/><path d="M276 282c0-20 13-40 36-40 24 0 33 18 33 45v105h66V279c0-61-32-89-76-89-34 0-51 19-59 32"/></svg></a></span></div><div class="container py-4"><div class="row justify-content-center"><div class="col-md-4 text-center"><div class=pb-2><a href=https://bobblelaw.github.io/ title="Bobble Law"><img alt="Footer logo" src=/logo.png height=40px width=40px></a></div>&copy; 2025 All rights reserved<div class=text-secondary>Made with
<span class=text-danger>&#10084;
</span>and
<a href=https://github.com/gurusabarish/hugo-profile target=_blank title="Designed and developed by gurusabarish">Hugo Profile</a></div></div></div></div></footer><script src=/bootstrap-5/js/bootstrap.bundle.min.js></script><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))});var tooltipTriggerList=[].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]')),tooltipList=tooltipTriggerList.map(function(e){return new bootstrap.Tooltip(e)})</script><script src=/js/search.js></script><section id=search-content class=py-2><div class=container id=search-results></div></section></body></html>