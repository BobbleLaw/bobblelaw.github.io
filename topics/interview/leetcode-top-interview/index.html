<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta http-equiv=Accept-CH content="DPR, Viewport-Width, Width"><link rel=icon href=/logo.png type=image/gif><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" media=print onload='this.media="all"'><noscript><link href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel=stylesheet></noscript><link rel=stylesheet href=/css/font.css media=all><meta property="og:url" content="https://bobblelaw.github.io/topics/interview/leetcode-top-interview/"><meta property="og:site_name" content="Bobble Law"><meta property="og:title" content="Bobble Law"><meta property="og:description" content="LeetCode Top Interview Questions Array & String 88. Merge Sorted Array Keyword: Two-Pointer
Steps
Two pointers, all start from two end (m-1 and n-1) Iteration pointer starts from the very (m+n-1) end If nums[i1] > nums[i2], use nums[i1], move i1 Else, use nums[i2], move i2 Move i Copy the rest from nums Time: O(m+n), Space: O(1)
27. Remove Item Keyword: Two-Pointer
two pointers, one tracks valid number, one iterates."><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="article:section" content="topics"><meta name=twitter:card content="summary"><meta name=twitter:title content="Bobble Law"><meta name=twitter:description content="LeetCode Top Interview Questions Array & String 88. Merge Sorted Array Keyword: Two-Pointer
Steps
Two pointers, all start from two end (m-1 and n-1) Iteration pointer starts from the very (m+n-1) end If nums[i1] > nums[i2], use nums[i1], move i1 Else, use nums[i2], move i2 Move i Copy the rest from nums Time: O(m+n), Space: O(1)
27. Remove Item Keyword: Two-Pointer
two pointers, one tracks valid number, one iterates."><link rel=stylesheet href=/bootstrap-5/css/bootstrap.min.css media=all><link rel=stylesheet href=/css/header.css media=all><link rel=stylesheet href=/css/footer.css media=all><link rel=stylesheet href=/css/theme.css media=all><style>:root{--text-color:#343a40;--text-secondary-color:#6c757d;--text-link-color:#007bff;--background-color:#eaedf0;--secondary-background-color:#64ffda1a;--primary-color:#007bff;--secondary-color:#f8f9fa;--text-color-dark:#e4e6eb;--text-secondary-color-dark:#b0b3b8;--text-link-color-dark:#ffffff;--background-color-dark:#18191a;--secondary-background-color-dark:#212529;--primary-color-dark:#ffffff;--secondary-color-dark:#212529}body{font-size:1rem;font-weight:400;line-height:1.5;text-align:left}html{background-color:var(--background-color)!important}body::-webkit-scrollbar{height:0;width:8px;background-color:var(--background-color)}::-webkit-scrollbar-track{border-radius:1rem}::-webkit-scrollbar-thumb{border-radius:1rem;background:#b0b0b0;outline:1px solid var(--background-color)}#search-content::-webkit-scrollbar{width:.5em;height:.1em;background-color:var(--background-color)}</style><meta name=description content><link rel=stylesheet href=/css/single.css><script defer src=/fontawesome-6/all-6.4.2.js></script><title>| Bobble Law</title></head><body class=light><script>let localStorageValue=localStorage.getItem("pref-theme"),mediaQuery=window.matchMedia("(prefers-color-scheme: dark)").matches;switch(localStorageValue){case"dark":document.body.classList.add("dark");break;case"light":document.body.classList.remove("dark");break;default:mediaQuery&&document.body.classList.add("dark");break}</script><script>var prevScrollPos=window.pageYOffset;window.addEventListener("scroll",function(){let s=document.getElementById("profileHeader"),t=window.pageYOffset,n=!1,o=!0,i=o?prevScrollPos>t:t>0;i?s.classList.add("showHeaderOnTop"):n=!0,t===0&&(n=!0),n&&s.classList.remove("showHeaderOnTop"),prevScrollPos=t})</script><header id=profileHeader><nav class="pt-3 navbar navbar-expand-lg animate"><div class="container-fluid mx-xs-2 mx-sm-5 mx-md-5 mx-lg-5"><a class="navbar-brand primary-font text-wrap" href=/><img src=/logo.png width=30 height=30 class="d-inline-block align-top">
Bob Law</a><div><input id=search autocomplete=off class="form-control mr-sm-2 d-none d-md-block" placeholder=Search... aria-label=Search oninput=searchOnChange(event)></div><button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarContent aria-controls=navbarContent aria-expanded=false aria-label="Toggle navigation"><svg aria-hidden="true" height="24" viewBox="0 0 16 16" width="24" data-view-component="true"><path fill-rule="evenodd" d="M1 2.75A.75.75.0 011.75 2h12.5a.75.75.0 110 1.5H1.75A.75.75.0 011 2.75zm0 5A.75.75.0 011.75 7h12.5a.75.75.0 110 1.5H1.75A.75.75.0 011 7.75zM1.75 12a.75.75.0 100 1.5h12.5a.75.75.0 100-1.5H1.75z"/></svg></button><div class="collapse navbar-collapse text-wrap primary-font" id=navbarContent><ul class="navbar-nav ms-auto text-center"><li class="nav-item navbar-text d-block d-md-none"><div class=nav-link><input id=search autocomplete=off class="form-control mr-sm-2" placeholder=Search... aria-label=Search oninput=searchOnChange(event)></div></li><li class="nav-item navbar-text"><a class=nav-link href=/#about aria-label=about>About</a></li><li class="nav-item navbar-text"><a class=nav-link href=/#experience aria-label=experience>Experience</a></li><li class="nav-item navbar-text"><a class=nav-link href=/#education aria-label=education>Education</a></li><li class="nav-item navbar-text"><a class=nav-link href=/posts title>Posts</a></li><li class="nav-item navbar-text"><a class=nav-link href=/tags title>Tags</a></li><li class="nav-item navbar-text"><a class=nav-link href=/topics title>Topics</a></li><li class="nav-item navbar-text"><div class=text-center><button id=theme-toggle><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></li></ul></div></div></nav></header><div id=content><section id=single><div class=container><div class="row justify-content-center"><div class="col-sm-12 col-md-12 col-lg-9"><div class=pr-lg-4><div class="title mb-5"><h1 class="text-center mb-4"></h1><div class=text-center>Jan 1, 1010
<span id=readingTime>min read</span></div></div><article class="page-content p-2"><h1 id=leetcode-top-interview-questions>LeetCode Top Interview Questions</h1><p><img src="https://img.shields.io/badge/Meta-%230467DF.svg?style=for-the-badge&amp;logo=Meta&amp;logoColor=white" alt=Meta><br><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS><br><img src="https://img.shields.io/badge/google-4285F4?style=for-the-badge&amp;logo=google&amp;logoColor=white" alt=Google><br><img src="https://img.shields.io/badge/Apple-%23000000.svg?style=for-the-badge&amp;logo=apple&amp;logoColor=white" alt=Apple></p><h2 id=array--string>Array & String</h2><h3 id=88-merge-sorted-array><a href=https://leetcode.com/problems/merge-sorted-array/>88. Merge Sorted Array</a></h3><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Steps</strong></p><ul><li>Two pointers, all start from two end (<code>m-1</code> and <code>n-1</code>)</li><li>Iteration pointer starts from the very (<code>m+n-1</code>) end<ul><li>If <code>nums[i1] > nums[i2]</code>, use <code>nums[i1]</code>, move i1</li><li>Else, use <code>nums[i2]</code>, move i2</li><li>Move i</li></ul></li><li>Copy the rest from <code>nums</code></li></ul><p>Time: O(m+n), Space: O(1)</p><h3 id=27-remove-item><a href=https://leetcode.com/problems/remove-element/>27. Remove Item</a></h3><p><strong>Keyword</strong>: Two-Pointer</p><p>two pointers, one tracks valid number, one iterates.</p><h3 id=26-remove-duplicates-from-sorted-array><a href=https://leetcode.com/problems/remove-duplicates-from-sorted-array/>26. Remove Duplicates from Sorted Array</a></h3><p><strong>Keyword</strong>: Two-Pointer</p><p>one tracks concecutive duplicated, one iterates.</p><h3 id=80-remove-duplicates-from-sorted-array-ii><a href=https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/>80. Remove Duplicates from Sorted Array II</a></h3><p>Similar to 26, the starting point and <code>if</code> condition are different. Generalize to max k duplicated.</p><ul><li>First k element always valid.</li></ul><h3 id=169-majority-element><a href=https://leetcode.com/problems/majority-element/>169. Majority Element</a></h3><ul><li>Appears more than n / 2</li><li>Sort and return the median</li></ul><h3 id=189-rotate-array><a href=https://leetcode.com/problems/rotate-array/>189. Rotate Array</a></h3><ul><li>Rotate all -> rotate first k -> rotate remaining</li></ul><h3 id=121-best-time-to-buy-and-sell-stock><a href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock/>121. Best Time to Buy and Sell Stock</a></h3><p><strong>Observations</strong></p><ul><li>Buy and sell should happen on different day</li><li>One operation</li></ul><p><strong>Intuition</strong></p><ul><li>Buy low, sell high</li></ul><p><strong>Steps</strong></p><ul><li>Track min price and max profit so far</li><li>Iterate prices<ul><li>Update min price</li><li>Update potential max profit</li></ul></li></ul><p>Time: O(N), Space: O(1)</p><h3 id=122-best-time-to-buy-and-sell-stock-ii><a href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/>122: Best Time to Buy and Sell Stock II</a></h3><p><strong>Observations</strong></p><ul><li>Buy and sell can happen in the same day</li><li>Hold at most one stock</li><li>Multiple operations</li></ul><p><strong>Intuition</strong></p><ul><li>Capture All Uptrends: buy at every valley, sell at every peak</li><li>Avoid Overlapping Trade<ul><li>Even it&rsquo;s possible stock increases for several day, but we should make use of the rule from the question</li></ul></li></ul><p><strong>Steps</strong></p><ul><li>Iterate prices<ul><li>Every increase is an oppotunity to make profit</li><li>Sum up all the increase</li></ul></li></ul><p>Time: O(N), Space: O(1)</p><h3 id=55-jump-game><a href=https://leetcode.com/problems/jump-game/>55. Jump Game</a></h3><ul><li>Track the max reachable index</li><li>Iterate the jumps<ul><li>If index > max reach -> return false</li><li>Update max reachable index from current index</li><li>If new max reachable index is over the total -> return true</li></ul></li></ul><h3 id=45-jump-game-ii><a href=https://leetcode.com/problems/jump-game-ii/>45. Jump Game II</a></h3><ul><li>The difference between this question and <a href=/topics/interview/leetcode-top-interview/#55-jump-game>Jump Game</a> is to <strong>return the minimum jump</strong></li><li><strong>Greedy</strong>: At each level, try to extend the jump range as far as possible</li><li>Steps:<ul><li>Track the farthest index we can reach by <code>farthest</code></li><li>Track the current range of jump by <code>currentRange</code></li><li>When we reach <code>currentRange</code>, we must jump, so increase the <code>jump</code> counter, and update <code>currentRange</code></li></ul></li><li><strong>BE CAREFUL</strong>: Iterate to the <strong>second last index</strong>, because as long as we can reach the second last index, we can jump</li></ul><h3 id=383-ransom-note><a href=https://leetcode.com/problems/ransom-note/>383. Ransom Note</a></h3><ul><li>Use hash table to count occurrence of each letter</li><li>Knowing all the characters are letter, we can use array instead of hash table</li></ul><h3 id=141-linked-list-cycle><a href=https://leetcode.com/problems/linked-list-cycle/>141. Linked List Cycle</a></h3><ul><li>Two pointer, slow and fast</li></ul><h2 id=intervals>Intervals</h2><h4 id=228-summary-ranges><a href=https://leetcode.com/problems/summary-ranges/>228. Summary Ranges</a></h4><ul><li>Two pointer, one point to the range start, one is iterating</li><li><strong>Be creaful of the condition</strong></li></ul><h2 id=stack>Stack</h2><h2 id=binary-tree-general>Binary Tree General</h2><h4 id=104-maximum-depth-of-binary-tree><a href=https://leetcode.com/problems/maximum-depth-of-binary-tree/>104. Maximum Depth of Binary Tree</a></h4><ul><li>Small tree use DFS, deep trees use <strong>BFS</strong>.</li></ul><h4 id=100-same-tree><a href=https://leetcode.com/problems/same-tree/>100. Same Tree</a></h4><ul><li>Try <strong>BFS</strong></li></ul><h3 id=graph-general>Graph General</h3><h4 id=200-number-of-islands><a href=https://leetcode.com/problems/number-of-islands/>200. Number of Islands</a></h4><ul><li>DFS. Traverse grid, mark (try to sink) visited cell</li></ul><h2 id=binary>Binary</h2><h4 id=67-add-binary><a href=https://leetcode.com/problems/add-binary/>67. Add Binary</a></h4><ul><li>Simulate binary addition (with two pointers)</li></ul><h2 id=binary-tree>Binary Tree</h2><h3 id=314-binary-tree-vertical-order-traversal><a href=https://leetcode.com/problems/binary-tree-vertical-order-traversal/>314. Binary Tree Vertical Order Traversal</a></h3><p><strong>PROBLEM STATEMENT</strong></p><p>Given the <code>root</code> of a binary tree, return its vertical order traversal.</p><ul><li>Nodes in the same vertical are ordered from top to bottom.</li><li>If multiple nodes are in the same position, they appear in left-to-right order.</li></ul><p><strong>Keyword</strong>: BFS</p><p><strong>Intuition</strong></p><ul><li>Top to bottom, left to right, so use BFS</li><li>During BFS, track the column</li><li><code>column = column_parent +/- 1</code>, and <code>root_column = 0</code></li></ul><p><strong>Approach</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Definition for a binary tree node.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// struct TreeNode {
</span></span></span><span style=display:flex><span><span style=color:#75715e>//     int val;
</span></span></span><span style=display:flex><span><span style=color:#75715e>//     TreeNode *left;
</span></span></span><span style=display:flex><span><span style=color:#75715e>//     TreeNode *right;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>//     TreeNode(int val = 0): TreeNode(val, nullptr, nullptr) {}
</span></span></span><span style=display:flex><span><span style=color:#75715e>//     TreeNode(int x, TreeNode *left, TreeNode *right): val(x), left(left), right(right) {}
</span></span></span><span style=display:flex><span><span style=color:#75715e>// };
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Intuition: BFS with column tracking
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> verticalTraversal(TreeNode<span style=color:#f92672>*</span> root) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> {};
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// We need a ordered map to store Column -&gt; Nodes&#39; value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> col_nodes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// For the BFS queue, we store Node -&gt; Column
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>queue<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>pair<span style=color:#f92672>&lt;</span>TreeNode<span style=color:#f92672>*</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> q;
</span></span><span style=display:flex><span>        q.push({root, <span style=color:#ae81ff>0</span>});
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// BFS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>q.empty()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>auto</span> [node, column] <span style=color:#f92672>=</span> q.front();
</span></span><span style=display:flex><span>            q.pop();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            col_nodes[column].push_back(node<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>auto</span> left <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>left) {
</span></span><span style=display:flex><span>                q.push({left, column <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>});
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>auto</span> right <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>right) {
</span></span><span style=display:flex><span>                q.push({right, column <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>});
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> res;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> [_, nodes]<span style=color:#f92672>:</span> col_nodes) {
</span></span><span style=display:flex><span>            res.push_back(nodes);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Time: O($Nlog(N)$), Space: O(N)</p><h3 id=987-vertical-order-traversal-of-a-binary-tree><a href=https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/>987. Vertical Order Traversal of a Binary Tree</a></h3><p><strong>HARD</strong></p><p><strong>Keyword</strong>: BFS</p><p><strong>Intuitions</strong></p><ul><li>The different with <a href=/topics/interview/leetcode-top-interview/#314-binary-tree-vertical-order-traversal>314. Binary Tree Vertical Order Traversal</a> is that if there multiple nodes in the same row and same column, sort these nodes by their values.</li><li>We could reuse the same structure, but change <code>std::vector&lt;int></code> to <code>std::map&lt;int, std::multiset&lt;int>></code>, meaning &ldquo;row -> sorted nodes&rdquo;</li><li>Optionally we can use DFS with sorting</li></ul><p><strong>Approach: DFS with Sorting</strong></p><ul><li>DFS to traverse all nodes with (col, row)</li><li>Sort the nodes by, with the container of map&lt;col, map&lt;row, multiset<val>&#187;<ul><li>Column(left->right)</li><li>Row(top->bottom)</li><li>Value(ascending)</li></ul></li><li>Build the result</li></ul><p>Time: O($Nlog(N)$), Space: O(N)</p><h3 id=236-lowest-common-ancestor-of-a-binary-tree><a href=https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/>236. Lowest Common Ancestor of a Binary Tree</a></h3><p><strong>Keyword</strong>: DFS</p><p><strong>Steps</strong></p><ul><li>DFS recursion<ul><li><code>p</code> and <code>q</code> are on different sides of the <code>node</code>, LCA is <code>node</code></li><li>Either <code>p</code> or <code>q</code> on one side of the <code>node</code>, LCA should be in that side of the <code>node</code></li></ul></li><li>Use DFS on left and right</li></ul><p><strong>Notes</strong></p><ul><li>Even we can reuse the <code>lowestCommonAncestor()</code> function, its intention is confusing(we can&rsquo;t always find LCA in the subtree!), we better use a new <code>dfs()</code> function to define what to do in DFS recursion</li></ul><h4 id=1644-lowest-common-ancestor-of-a-binary-tree-ii><a href=https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/>1644. Lowest Common Ancestor of a Binary Tree II</a></h4><p><strong>PROBLEM STATEMENT</strong></p><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes <code>p</code> and <code>q</code>. However, this version of the problem has a special requirement:</p><ul><li>If either <code>p</code> or <code>q</code> is missing from the tree, return <code>nullptr</code> instead of the LCA.</li></ul><p><strong>Keyword</strong>: DFS</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Reuse the structure of basic LCA, but in dfs(), we carry the result if q and p exist in the tree, 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> lowestCommonAncestor(Node<span style=color:#f92672>*</span> root, Node<span style=color:#f92672>*</span> p, Node<span style=color:#f92672>*</span> q) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> findP{false}, findQ{false};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> lca <span style=color:#f92672>=</span> dfs(root, p, q, findP, findQ);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (findP <span style=color:#f92672>&amp;&amp;</span> findQ) <span style=color:#f92672>?</span> lca : <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> dfs(Node<span style=color:#f92672>*</span> node, Node<span style=color:#f92672>*</span> p, Node<span style=color:#f92672>*</span> q, <span style=color:#66d9ef>bool</span><span style=color:#f92672>&amp;</span> findP, <span style=color:#66d9ef>bool</span><span style=color:#f92672>&amp;</span> findQ) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>node) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> leftFindP{false}, leftFindQ{false};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> left <span style=color:#f92672>=</span> dfs(node<span style=color:#f92672>-&gt;</span>left, p, q, leftFindP, leftFindQ);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> rightFindP{false}, rightFindQ{false};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> right <span style=color:#f92672>=</span> dfs(node<span style=color:#f92672>-&gt;</span>right, p, q, rightFindP, rightFindQ);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        findP <span style=color:#f92672>=</span> leftFindP <span style=color:#f92672>||</span> rightFindP <span style=color:#f92672>||</span> node <span style=color:#f92672>==</span> p;
</span></span><span style=display:flex><span>        findQ <span style=color:#f92672>=</span> leftFindQ <span style=color:#f92672>||</span> rightFindQ <span style=color:#f92672>||</span> node <span style=color:#f92672>==</span> q;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (node <span style=color:#f92672>==</span> p <span style=color:#f92672>||</span> node <span style=color:#f92672>==</span> q) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> node;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (left <span style=color:#f92672>&amp;&amp;</span> right) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> node;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> left <span style=color:#f92672>?</span> left : right;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=1650-lowest-common-ancestor-of-a-binary-tree-iii><a href=https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/>1650. Lowest Common Ancestor of a Binary Tree III</a></h3><p><strong>PROBLEM STATEMENT</strong></p><p>Given two nodes in a binary tree where each node contains a parent pointer, find their lowest common ancestor (LCA).</p><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Steps</strong></p><ul><li>Use two pointers, start at <code>p</code> and <code>q</code></li><li>Move each pointer upward to its parent until they meet</li><li>If a pointer reaches the root (<code>parent = nullptr</code>), restart at the other node<ul><li>Both pointers would traverse the same height in the end</li></ul></li><li>The first common node encountered is the LCA</li></ul><p><strong>Solution</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Node definition
</span></span></span><span style=display:flex><span><span style=color:#75715e>// class Node {
</span></span></span><span style=display:flex><span><span style=color:#75715e>//     int val;
</span></span></span><span style=display:flex><span><span style=color:#75715e>//     Node* left;
</span></span></span><span style=display:flex><span><span style=color:#75715e>//     Node* right;
</span></span></span><span style=display:flex><span><span style=color:#75715e>//     Node* parent;
</span></span></span><span style=display:flex><span><span style=color:#75715e>// };
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> lowestCommonAncestor(Node<span style=color:#f92672>*</span> p, Node<span style=color:#f92672>*</span> q) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Two pointers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>auto</span> p1{p};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> p2{q};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (p1 <span style=color:#f92672>!=</span> p2) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 1. Move pointer upward to parent
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 2. If pointer reaches nullptr, restart at the other&#39;s position
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            p1 <span style=color:#f92672>=</span> p1 <span style=color:#f92672>?</span> p1<span style=color:#f92672>-&gt;</span>parent : q;
</span></span><span style=display:flex><span>            p2 <span style=color:#f92672>=</span> p2 <span style=color:#f92672>?</span> p2<span style=color:#f92672>-&gt;</span>parent : p;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> p1;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Time: O(H), Space: O(1)</p><h3 id=199-binary-tree-right-side-view><a href=https://leetcode.com/problems/binary-tree-right-side-view>199. Binary Tree Right Side View</a></h3><p><strong>Keyword</strong>: BFS</p><p><strong>Intuition</strong></p><ul><li>Because we need to iterate the tree by layer, so BFS</li><li>The last node is the right most node in current layer</li><li>Optional: DFS. Add the right node first, so when list size is same as the depth, that&rsquo;s the right most node</li></ul><p><strong>Steps</strong></p><ul><li>Classic BFS pattern, declare queue (of Node), push root, start loop</li><li>Track the last element in this layer</li><li>Insert left and right if neccessary</li></ul><p>Time: O(N), Space: O(N)</p><p><strong>Variants</strong></p><ul><li>Left Side View: Same structure, but save the first node of the layer</li></ul><h3 id=543-diameter-of-binary-tree><a href=https://leetcode.com/problems/diameter-of-binary-tree/>543. Diameter of Binary Tree</a></h3><p><strong>Keyword</strong>: DFS</p><p><strong>Intuition</strong></p><ul><li>Diameter of a node is the longest path goes through the node<ul><li>In other words, <strong>the largest sum of left and right subtree height</strong></li></ul></li><li>Because we need to calculate the height from bottom up, so use DFS</li></ul><p><strong>Steps</strong></p><ul><li>DFS recursion<ul><li>Calculate the sum of left and right subtring height</li><li>Update the max diameter</li><li>Return height</li></ul></li><li>Start recursion with root</li></ul><p>Time: O(N), Space: O(H)</p><h3 id=863-all-nodes-distance-k-in-binary-tree><a href=https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/>863. All Nodes Distance K in Binary Tree</a></h3><p><strong>MEDIUM BUT HARD!</strong></p><ul><li>Because we need to go up and down, and the binary tree node doesn&rsquo;t have parent, so we <strong>build a undirected graph from tree</strong></li><li>Use BFS to traverse the graph from target node to level <code>K</code></li><li>Return the elements in level K</li></ul><h3 id=124-binary-tree-maximum-path-sum><a href=https://leetcode.com/problems/binary-tree-maximum-path-sum/>124. Binary Tree Maximum Path Sum</a></h3><p><strong>HARD</strong></p><ul><li>Traverse the tree with DFS, while tracking<ul><li>The accumulate <code>maxSum</code> so far</li><li>The maxPath return to parent node (single path)</li></ul></li><li>While traversing, ignore path has negative sum</li></ul><h3 id=297-serialize-and-deserialize-binary-tree><a href=https://leetcode.com/problems/serialize-and-deserialize-binary-tree/>297. Serialize and Deserialize Binary Tree</a></h3><p><strong>HARD</strong></p><ul><li>We can use BFS to solver handle serialization and deserialization</li><li>Serialization<ul><li>Check <code>node</code> is <code>nullptr</code> instead of <code>node->left</code> and <code>node->right</code></li></ul></li><li>Deserialization<ul><li>Get familiar with <code>int std::getline(std::stringstream, std::string, char)</code></li></ul></li></ul><h3 id=129-sum-root-to-leaf-numbers><a href=https://leetcode.com/problems/sum-root-to-leaf-numbers/>129. Sum Root to Leaf Numbers</a></h3><p><strong>Keyword</strong>: DFS</p><p><strong>Intuition</strong></p><ul><li>Because we need to reach the leaf to build up a number, so DFS</li></ul><p><strong>Steps</strong></p><ul><li>DFS, while tracking the sum<ul><li>Calculate current number</li><li>If meet leaf, return current number as sum</li><li>Else, return the sum of left and right node</li></ul></li></ul><p>Time: O(N), Space: O(H)</p><h2 id=binary-search-treebst>Binary Search Tree(BST)</h2><h3 id=938-range-sum-of-bst><a href=https://leetcode.com/problems/range-sum-of-bst/>938. Range Sum of BST</a></h3><p><strong>Keyword</strong>: DFS on DFS</p><p><strong>Steps</strong></p><ul><li>DFS function: Return sum<ul><li>If current val smaller than low, return sum of right branch</li><li>If current val larger than high, return sum of left branch</li><li>If current val in range, return the sum of left and rigth branches, and current value</li></ul></li></ul><p>Time: O(N), Space: O(H)</p><h2 id=string>String</h2><h3 id=20-valid-parentheses><a href=https://leetcode.com/problems/valid-parentheses/>20. Valid Parentheses</a></h3><ul><li>Use stack to hold the iterated characters</li><li>Closing bracket at the front, e.g. {&rsquo;}&rsquo;, &lsquo;{&rsquo;}</li></ul><h3 id=22-generate-parentheses><a href=https://leetcode.com/problems/generate-parentheses/>22. Generate Parentheses</a></h3><p><strong>Keyword</strong>: Backtrack</p><p><strong>Intuition</strong></p><ul><li>Add open as much as possible (less than n)</li><li>Add close when close is less than open</li></ul><p><strong>Steps</strong></p><ul><li>Define <code>backtrack</code> function<ul><li>Parameters: current string, open count, close count, total parenthese need, combination so far</li><li>If current string size is equal to <code>2*n</code><ul><li>Append current string and return</li></ul></li><li>If open count is less than total need, append open</li><li>If close count is less than open count, append close</li></ul></li></ul><h3 id=1249-minimum-remove-to-make-valid-parentheses><a href=https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses>1249. Minimum Remove to Make Valid Parentheses</a></h3><p><strong>Approach I: Two-Pass with Stack</strong></p><ol><li>Use stack to store &lsquo;(&rsquo;, and unordered_set for invalid indices for quick access</li><li>1st pass: locate the unpaired &lsquo;)&rsquo; indices</li><li>2nd pass: Add the left &lsquo;(&rsquo; (unpaired) indices into invalid indices</li><li>Build new string by removing invalid indices</li></ol><p>Time: O(N), Space: O(N)</p><h3 id=921-minimum-add-to-make-parentheses-valid><a href=https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/>921. Minimum Add to Make Parentheses Valid</a></h3><p><strong>Approach: Simulate Stack</strong></p><ul><li>Traverse from left to right</li><li>When encountering &lsquo;(&rsquo;, increase left counter</li><li>When encountering &lsquo;)&rsquo;<ul><li>There&rsquo;s &lsquo;(&rsquo; left, decrease counter</li><li>Otherwise, increase right counter</li></ul></li></ul><h3 id=408-valid-word-abbreviation><a href=https://leetcode.com/problems/valid-word-abbreviation/>408. Valid Word Abbreviation</a></h3><p><strong>PROBLEM STATEMENT</strong></p><p>Given a string <code>word</code> and an abbreviation <code>abbr</code>, return <code>true</code> if <code>abbr</code> is a valid abbreviation for <code>word</code>, otherwise return <code>false</code>.</p><p>A valid abbreviation follows these rules:</p><ul><li>A number in <code>abbr</code> represents skipping that many characters in word.</li><li>Numbers cannot have leading zeros (e.g., &ldquo;01&rdquo; is invalid).</li><li>The skipped characters must match the length indicated by the number.</li></ul><p>Examples</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Input
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>word <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;internationalization&#34;</span>
</span></span><span style=display:flex><span>abbr <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;i12iz4n&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>true
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Input
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>word <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;apple&#34;</span>
</span></span><span style=display:flex><span>abbr <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;a2e&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>false
</span></span></code></pre></div><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Solution</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> validWordAbbreviation(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> word, <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> abbr) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Two pointer: one for word, one for abbr
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        size_t i{<span style=color:#ae81ff>0</span>}, j{<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> word.size() <span style=color:#f92672>&amp;&amp;</span> j <span style=color:#f92672>&lt;</span> abbr.size()) {            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// match digit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> ch_a <span style=color:#f92672>=</span> abbr[j]; std<span style=color:#f92672>::</span>isdigit(ch_a)) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// No leading &#39;0&#39; 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> (ch_a <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;0&#39;</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// read number
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>auto</span> num{<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (j <span style=color:#f92672>&lt;</span> abbr.size() <span style=color:#f92672>&amp;&amp;</span> std<span style=color:#f92672>::</span>isdigit(abbr[j])) {
</span></span><span style=display:flex><span>                    num <span style=color:#f92672>=</span> num <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span> <span style=color:#f92672>+</span> (abbr[j] <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;0&#39;</span>);
</span></span><span style=display:flex><span>                    j<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// move forward
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                i <span style=color:#f92672>+=</span> num;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> { <span style=color:#75715e>// match word
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// Mismatch
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> (ch_a <span style=color:#f92672>!=</span> word[i]) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                j<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Fully processed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> i <span style=color:#f92672>==</span> word.size() <span style=color:#f92672>&amp;&amp;</span> j <span style=color:#f92672>==</span> abbr.size();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Time: O(len(word) + len(abbr)), Space: O(1)</p><h3 id=791-custom-sort-string><a href=https://leetcode.com/problems/custom-sort-string/>791. Custom Sort String</a></h3><p><strong>Intuition</strong></p><ul><li><code>order</code> has less character, and it defines the order, so build final string from <code>order</code> based on <code>s</code> frequency</li></ul><p><strong>Steps</strong></p><ul><li>Declare hash map to count occurance in <code>s</code></li><li>Count occurance</li><li>Build result by iterating through <code>order</code></li><li>Append the remaining letters at the end</li></ul><p>Time: O(N), Space: O(N)</p><h3 id=215-kth-largest-element-in-an-array><a href=https://leetcode.com/problems/kth-largest-element-in-an-array/>215. Kth Largest Element in an Array</a></h3><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Approach I: Sort</strong></p><ul><li>Sort the array in descending order</li><li>Return kth element</li></ul><p>Time: O($Nlog(N)$), Space: O(1). Good for small N</p><p><strong>Approach II: Min Heap</strong></p><ul><li>Define min heap to maintain the k largest elements</li><li>Iterate array<ul><li>Pop (the smallest) when the heap size exceeds k</li></ul></li><li>Return the top element</li></ul><p>Time: O($Nlog(K)$), Space: O(K). Good for big K, or streaming data</p><p><strong>Approach III: Quickselect</strong></p><p>TODO</p><p>Time: O(N) average, O($N^2$) worst, Space: O(1)</p><h3 id=227-basic-calculator-ii><a href=https://leetcode.com/problems/basic-calculator-ii/>227. Basic Calculator II</a></h3><p><strong>Keyword</strong>: Stack</p><p><strong>Intuition</strong></p><ul><li>If there are only &lsquo;+&rsquo; and &lsquo;-&rsquo;, then process the numbers in sequence</li><li>But we have &lsquo;*&rsquo; and &lsquo;/&rsquo;, upcoming number should be processed immediately</li><li>So we use stack to achieve this</li></ul><p><strong>Steps</strong></p><ul><li>Iterate the string while tracking the current number and last operator<ul><li>If digit, convert to number</li><li>If operator, or last digit<ul><li>+: Push number to stack</li><li>-: Push neg number to stack</li><li>*: Calculate stack.top() * num, pop, and push result</li><li>/: Calculate stack.top() / num, pop, and push result</li><li>Update last operator, clear number</li></ul></li></ul></li><li>Sum up the elements in stack</li></ul><p>Time: O(N), Space: O(N)</p><h3 id=528-random-pick-with-weight><a href=https://leetcode.com/problems/random-pick-with-weight/>528. Random Pick with Weight</a></h3><p><strong>Keyword</strong>: Prefix Sum, Binary Search</p><p><strong>Intuition</strong></p><ul><li>Prefix sum can map the range into prefix sum array</li><li>Use binary search to quickly find the valid index</li></ul><p><strong>Steps</strong></p><ul><li>Build a prefix sum array, and total sum) from the input array in constructor</li><li>Pick random value x between [1, total]</li><li>Use binary search to find the lowerbound where prefixSum[i] >= x</li></ul><p><strong>Note</strong></p><p>How to randomly pick a number in a range with modern C++?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>rndom_device rd;
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>mt19937 rng{rd()};
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>uniform_int_distribution<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dist{kLow, kHigh};
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> num <span style=color:#f92672>=</span> dist(rd);a
</span></span></code></pre></div><h3 id=162-find-peak-element><a href=https://leetcode.com/problems/find-peak-element/>162. Find Peak Element</a></h3><p><strong>IMPORTANT!!!</strong></p><p><strong>Keyword</strong>: Binary Search</p><p><strong>Intuition</strong></p><ul><li>We are guaranteed to find a peak, and we can return any peak.</li><li>Use binary search</li></ul><p><strong>Steps</strong></p><ul><li>Start at <code>0</code> and <code>n-1</code></li><li>Loop, condition: Not cross (left &lt; right)<ul><li>Calculate <code>mid</code>, and compare <code>nums[mid]</code> and <code>nums[mid+1]</code><ul><li><code>nums[mid]</code> > <code>nums[mid+1]</code>, move <code>right</code> to <code>mid</code></li><li><code>nums[mid]</code> &lt; <code>nums[mid+1]</code>, move <code>left</code> to <code>mid + 1</code></li></ul></li></ul></li><li>Return left (because <code>left == right</code> in the end)</li></ul><p>Time: O($log(N)$), Space: O(1)</p><h3 id=50-powx-n><a href=https://leetcode.com/problems/powx-n/>50. Pow(x, n)</a></h3><p><strong>Keyword</strong>: Divide and Conquer</p><p><strong>Observations</strong></p><ul><li>If n is even, $x^n = (x^2)^{n/2}$</li><li>If n is odd, $x^n = x \times x^{n-1}$</li></ul><p><strong>Steps</strong></p><ul><li>Corner case n == 0, return 1</li><li>Inverse <code>x</code> and <code>n</code>, if the exponent is negative<ul><li>Be careful, range of <code>int</code> is $[-2^{31} - 1, 2^{31}]$, so $[2^{31} + 1]$ would overflow, either use <code>long long</code>, or calculate $x * myPow(x, -(n + 1))$</li></ul></li><li>Use recursive/iteration.<ul><li>If <code>n</code> is even, $x^n = (x^2)^{n / 2}$</li><li>If <code>n</code> is odd, $x^n = x * x^{n-1}$</li></ul></li></ul><p>Time: O($Log(N)$), Space: recursive O($Log(N)$); Iteration: O(1)</p><h3 id=71-simplify-path><a href=https://leetcode.com/problems/simplify-path/>71. Simplify Path</a></h3><p><strong>Keyword</strong>: Stack</p><p><strong>Observations</strong></p><ul><li>Similar to <a href=/topics/interview/leetcode-top-interview/#227-basic-calculator-ii>227. Basic Calculator II</a></li></ul><p><strong>Steps</strong></p><ul><li>Split the input path with &lsquo;/&rsquo;<ul><li>Use <code>std::getline()</code></li></ul></li><li>Process each part<ul><li>&ldquo;.&rdquo; and "" -> ignore</li><li>&ldquo;..&rdquo; -> move up one by pop stack</li><li>Other are valid name, push stack</li></ul></li><li>Build output string.<ul><li>Always startsWith &lsquo;/&rsquo;, try not to use condition in the loop</li></ul></li></ul><p>Time: O(N), Space: O(N)</p><h3 id=1091-shortest-path-in-binary-matrix><a href=https://leetcode.com/problems/shortest-path-in-binary-matrix/>1091. Shortest Path in Binary Matrix</a></h3><p><strong>Keyword</strong>: BFS</p><p><strong>Intuition</strong></p><ul><li>Since we want to find a shortest path, use BFS</li><li>Explore 8 directions</li><li>Track visited nodes to avoid cycles</li></ul><p><strong>Steps</strong></p><ul><li>If the top-left or bottom-right cell is 1, return false</li><li>Element in BFS queue is [row, col],<ul><li>Push root</li><li>Update grid to visited</li><li>Init length to 1</li></ul></li><li>BFS Loop<ul><li>Iterate each layer (8 directions)<ul><li>If reach bottom-right, return length</li><li>Try all 8 directions<ul><li>If still in bound, and not visited<ul><li>Push into layer</li><li>Update visited</li></ul></li></ul></li></ul></li><li>Increase path</li></ul></li><li>Default not found, return -1</li></ul><p>Time: O($N^2$), Space: O($N^2$), Worst case: visit all the nodes</p><h3 id=1570-dot-product-of-two-sparse-vectors><a href=https://leetcode.com/problems/dot-product-of-two-sparse-vectors/>1570. Dot Product of Two Sparse Vectors</a></h3><p><strong>PROBLEM STATEMENT</strong></p><p>Given two sparse vectors, implement their dot product efficiently.</p><p>A sparse vector contains mostly 0s, so storing and computing all elements naively is inefficient.</p><p>Implement a class <code>SparseVector</code> with:</p><ul><li>Constructor: <code>SparseVector(vector&lt;int>& nums)</code></li><li>Dot product function: <code>int dotProduct(SparseVector& vec)</code></li></ul><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Intuition</strong></p><ul><li>Store the SparseVector as list of non-zero numbers&rsquo; index and value</li><li>Use two pointers to iterate both SparseVector</li></ul><p><strong>Solution</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SparseVector</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Store Non-Zero element: {index: value}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>pair<span style=color:#f92672>&lt;</span>size_t, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> nonzeros;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> <span style=color:#a6e22e>SparseVector</span>(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (size_t i{<span style=color:#ae81ff>0</span>}; i <span style=color:#f92672>&lt;</span> nums.size(); <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> num <span style=color:#f92672>=</span> nums[i]; num <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                nonzeros.push_back({i, num});
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dotProduct</span>(<span style=color:#66d9ef>const</span> SparseVector<span style=color:#f92672>&amp;</span> o) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> res{<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>        size_t i{<span style=color:#ae81ff>0</span>}, j{<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> nonzeros.size() <span style=color:#f92672>&amp;&amp;</span> j <span style=color:#f92672>&lt;</span> o.nonzeros.size()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>auto</span> i1 <span style=color:#f92672>=</span> nonzeros[i].first, i2 <span style=color:#f92672>=</span> nonzeros[j].first; i1 <span style=color:#f92672>==</span> i2) {
</span></span><span style=display:flex><span>                res <span style=color:#f92672>+=</span> nonzeros[i].second <span style=color:#f92672>*</span> nonzeros[j].second;
</span></span><span style=display:flex><span>                i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                j<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (i1 <span style=color:#f92672>&lt;</span> i2) {
</span></span><span style=display:flex><span>                i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                j<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Time: O(N), Space: O(K), where K is non zero element count.</p><h3 id=125-valid-palindrome><a href=https://leetcode.com/problems/valid-palindrome/>125. Valid Palindrome</a></h3><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Steps</strong></p><ul><li>Two pointers start from the start and end</li><li>Loop unitl <code>left</code> and <code>right</code> cross<ul><li>Ignore the non-alnum characters on both sides</li><li>Convert to lowercase and compare</li><li>Move closer</li></ul></li></ul><p>Time: O(N), Space: O(1)</p><h3 id=680-valid-palindrome-ii><a href=https://leetcode.com/problems/valid-palindrome-ii/>680. Valid Palindrome II</a></h3><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Approach: Two Pointer with (at most) one skip</strong></p><ul><li>Write a function to check if a string between range is palindrome</li><li>Two pointers start from the start and end</li><li>Loop unitl <code>left</code> and <code>right</code> cross<ul><li>If not match, try to move either <code>left</code> or <code>right</code></li><li>Move closer</li></ul></li></ul><p>Time: O(N), Space: O(1)</p><h4 id=647-palindromic-substrings><a href=https://leetcode.com/problems/palindromic-substrings/>647. Palindromic Substrings</a></h4><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Steps</strong></p><ul><li>Expand string from center of each character, and count valid palindrome<ul><li>Consider both odd number (<code>i, i</code>) and even number (<code>i, i + 1</code>)</li></ul></li></ul><p>Time: O($N^2$), Space: O(1)</p><h3 id=5-longest-palindromic-substring><a href=https://leetcode.com/problems/longest-palindromic-substring/>5. Longest Palindromic Substring</a></h3><p><strong>Steps</strong></p><ul><li>Iterate all characters<ul><li>Expand string from center of each character from both odd number (<code>i, i</code>) and even number (<code>i, i + 1</code>)</li><li>Get the longer substring</li><li>Update maxLen (and start index) if neccessary</li></ul></li><li>Return substring</li></ul><p>Time: O(N^2), Space: O(1)</p><h3 id=767-reorganize-string><a href=https://leetcode.com/problems/reorganize-string/>767. Reorganize String</a></h3><p><strong>Keyword</strong>: Greedy, Max-Heap</p><p><strong>Steps</strong></p><ul><li>Count frequency of each character. (Use hash map or array)</li><li>Prepare max heap to track the two most frequent characters</li><li>Always keep two, start loop<ul><li>Retrive the most count two characters</li><li>Push them back</li><li>Decrementing count</li></ul></li><li>If at the end, there&rsquo;s a character with <code>count > 1</code>, it&rsquo;s impossible</li></ul><h3 id=49-group-anagrams><a href=https://leetcode.com/problems/group-anagrams/>49. Group Anagrams</a></h3><p><strong>Keyword</strong>: Character Stats</p><p><strong>Steps</strong></p><ul><li>Sort the key. Or use a 26 length array to count frequency, turn frequency to string as key</li><li>Value is the string matched that key</li></ul><p>Time: O(N * K), Space: O(N * K), K is string length</p><h3 id=3-longest-substring-without-repeating-characters><a href=https://leetcode.com/problems/longest-substring-without-repeating-characters/>3. Longest Substring Without Repeating Characters</a></h3><p><strong>Keyword</strong>: Sliding Window</p><p><strong>Intuition</strong><br>Use the sliding window technique to maintain a substring without repeating characters while iterating through the string.<br>If a character is repeated, move the left pointer of the window forward to exclude the previous occurrence.</p><p><strong>Steps</strong></p><ul><li>Use two points, <code>left</code> and <code>right</code> start at <code>0</code></li><li>Declare hash map to record the last seen character index</li><li>Iterate the string (with <code>right</code>)<ul><li>If current character is seen and in range of the window<ul><li>Update <code>left</code> to next index of seen</li></ul></li><li>Update <code>lastSeen</code> to current position(<code>right</code>)</li><li>Update max length</li></ul></li><li>Return max length</li></ul><p>Time: O(N), Space: O(A), where A is the size of the character size</p><h3 id=560-subarray-sum-equals-k><a href=https://leetcode.com/problems/subarray-sum-equals-k/>560. Subarray Sum Equals K</a></h3><p><strong>Keyword</strong>: Prefix Sum</p><p><strong>Intuition</strong></p><ul><li>Because we want to find <em>subarray</em> sum, think of prefix sum<ul><li>If $sum[j] - sum[i] = k$, then subarray <code>nums[i+1: j]</code> sums to k</li></ul></li></ul><p><strong>Steps</strong></p><ul><li>Use a hash table to store Prefix Sum Value -> Indices Count<ul><li>Base case: Prefix 0 occurs once</li></ul></li><li>Iterate numbers<ul><li>If find <code>Current prefix sum - k</code> in the hash table, accumulate count</li><li>Update Prefix Sum hash table</li></ul></li></ul><p>Time: O(N), Space: O(N)</p><h3 id=116-populating-next-right-pointers-in-each-node><a href=https://leetcode.com/problems/populating-next-right-pointers-in-each-node/>116. Populating Next Right Pointers in Each Node</a></h3><ul><li>Use BFS, traverse from top to bottom, left to right, ignore the right most node in each layer</li><li>Make use of <code>next</code> pointer. Two while loop, outer use leftMost, inner use head</li></ul><h3 id=56-merge-intervals><a href=https://leetcode.com/problems/merge-intervals/>56. Merge Intervals</a></h3><p><strong>Keyword</strong>: Intervals</p><p><strong>Steps</strong></p><ul><li>Sort the input intervals <strong>by the mins</strong></li><li>Iterate the sorted intervals and merge based on overlapping between the last interval in result and the current interval</li></ul><p>Time: O(NLog(N)), Space: O(N)</p><h3 id=146-lru-cache><a href=https://leetcode.com/problems/lru-cache>146. LRU Cache</a></h3><p><img src="https://img.shields.io/badge/Meta-%230467DF.svg?style=for-the-badge&amp;logo=Meta&amp;logoColor=white" alt=Meta><br><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Linked-List</p><p><strong>Observations</strong></p><ul><li>Both <code>get()</code> and <code>put()</code> are considered &ldquo;used&rdquo;, So we use doubly linked list for efficient ordering</li><li>We can&rsquo;t use index to manipulate value in linked list, so we create a hash map {key, iterator}</li></ul><p><strong>Steps</strong></p><ul><li>Declare a doubly linked list for the main underlying container</li><li>Declare a hash map {key, iterator} to fast access data</li><li><code>get()</code><ul><li>If not exist in map, return -1</li><li>If exist<ul><li>Use the iterator to get value</li><li>Remove the iterator</li><li>Push new node to the front</li><li>Update map</li></ul></li></ul></li><li><code>put()</code><ul><li>If exist in map<ul><li>Use iterator to remove</li><li>Push new node to the front</li><li>Update map</li></ul></li><li>If not exist<ul><li>If exceed<ul><li>Get the last key</li><li>Pop last element</li><li>Remove from map</li><li>Push new node to the front</li><li>Update map</li></ul></li><li>If not exceed<ul><li>Push new node to the front</li><li>Update map</li></ul></li></ul></li></ul></li></ul><p>Time: O(1), Space: O(N)</p><h3 id=347-top-k-frequent-elements><a href=https://leetcode.com/problems/top-k-frequent-elements>347. Top K Frequent Elements</a></h3><p><strong>Keyword</strong>: Min-Heap</p><p><strong>Steps</strong></p><ul><li>Use hashtable to store the frequency</li><li>Use min heap to track top k largest elements (pop when size exceeds k)</li><li>Build results</li></ul><p>Time: O(NLog(K)), Space: O(N)</p><h3 id=973-k-closest-points-to-origin><a href=https://leetcode.com/problems/k-closest-points-to-origin/>973. K Closest Points to Origin</a></h3><p><strong>Keyword</strong>: Max-Heap</p><p><strong>Intuition</strong></p><ul><li>&ldquo;K Closest Points to Origin&rdquo;, meaning the smallest K distances, use max heap</li></ul><p><strong>Steps: Max-Heap</strong></p><ul><li>Declare max heap: Element is [distance -> point]</li><li>Iterate points<ul><li>Push new distance</li><li>If exceed k, pop heap</li></ul></li></ul><p>Time: O(NLog(K)), Space: O(K)</p><p><strong>Steps: Quick-Select</strong></p><ul><li>Use std::nth_element</li></ul><p>Time: O(N) for average, O($N^2$), Space: O(1)</p><h3 id=1762-buildings-with-an-ocean-view><a href=https://leetcode.com/problems/buildings-with-an-ocean-view/>1762. Buildings With an Ocean View</a></h3><p><strong>PROBLEM STATEMENT</strong></p><p>There are <code>n</code> buildings in a row, indexed from <code>0</code> to <code>n-1</code>. Each building has a height represented by <code>heights[i]</code>.</p><p>A building has an ocean view if all buildings to its right have a smaller height.</p><p>Return a list of indices of buildings that have an ocean view in increasing order.</p><p><strong>Observations</strong></p><ul><li>Start from the rightmost building, which guaranteed ocean view.</li></ul><p><strong>Steps</strong></p><ul><li>Iterate from the right, and track the so far tallest<ul><li>If <code>newHeight > maxHeight</code>, update max, save index</li></ul></li><li>Reverse result</li></ul><p><strong>Solution</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> findBuildings(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> heights) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Track the highest building seen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>auto</span> maxHeight{<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Start from the right most building (gurantee ocean view)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> heights.size() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> height <span style=color:#f92672>=</span> heights[i]; height <span style=color:#f92672>&gt;</span> maxHeight) {
</span></span><span style=display:flex><span>                res.push_back(i);
</span></span><span style=display:flex><span>                maxHeight <span style=color:#f92672>=</span> height;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>reverse(res.begin(), res.end());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Time: O(N), Space: O(1)</p><h3 id=986-interval-list-intersections><a href=https://leetcode.com/problems/interval-list-intersections/>986. Interval List Intersections</a></h3><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Steps</strong></p><ul><li>Declare two pointers, start from the begining</li><li>Loop<ul><li>An intersection exists if $max(start_1, start_2) \leq min(end_1, end_2)$</li><li>Move the pointer from the list where the interval ends first (smaller ending).</li></ul></li></ul><p>Time: O(N+M), Space: O(1)</p><h3 id=138-copy-list-with-random-pointer><a href=https://leetcode.com/problems/copy-list-with-random-pointer/>138. Copy List with Random Pointer</a></h3><p><strong>WARNING</strong></p><p><strong>Intuition</strong></p><ul><li>The easiest way is to use an extra hash map to store {Old Node -> New Node}<ul><li>1st pass: Create the mapping from {Old Node -> New Node}</li><li>2nd pass: Based on the hash map, link the new nodes</li></ul></li><li>The optimal solution is not easy to come up</li></ul><p><strong>Approah: Interleaving</strong></p><ul><li>1st pass: Copy each node right after the original node (don&rsquo;t care random pointer)</li><li>2nd pass: Link random pointer in the copied nodes</li><li>3rd pass: Separate the copied nodes and original nodes, and recover the original nodes links.<ul><li>Use dummy header</li></ul></li></ul><p>Time: O(N), Space: O(1)</p><h3 id=23-merge-k-sorted-lists><a href=https://leetcode.com/problems/merge-k-sorted-lists/>23. Merge k Sorted Lists</a></h3><p><strong>Keyword</strong>: Min-Heap</p><p><strong>Steps</strong></p><ul><li>Declare a min heap</li><li>Iterate lists, insert starting nodes into min heap, so smallest node starts first</li><li>Use dummy node</li><li>Loop<ul><li>Pop the smallest (pop)</li><li>Link to this node</li><li>Move to this node</li><li>Push to current next (if there is)</li></ul></li><li>Return dummy&rsquo;s next</li></ul><p>Time: O(NLog(K)), Space: O(k)</p><h3 id=339-nested-list-weight-sum><a href=https://leetcode.com/problems/nested-list-weight-sum/>339. Nested List Weight Sum</a></h3><p><strong>PROBLEM STATEMENT</strong></p><p>You are given a nested list of integers. Each element is either:</p><ul><li>An integer, or</li><li>A list containing other integers and/or nested lists.</li></ul><p>The depth of an integer is the number of lists it is inside.</p><p>Return the sum of all integers, weighted by their depth.</p><p>Example 1</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Input
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>nestedList <span style=color:#f92672>=</span> <span style=color:#a6e22e>[[1, 1], 2, [1, 1]]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Explanation
</span></span></span><span style=display:flex><span><span style=color:#75715e>// The &#39;1&#39;s are at depth 2, contributing 4*2=8
</span></span></span><span style=display:flex><span><span style=color:#75715e>// The &#39;2&#39; is at depth 1, contributing 2*1=2
</span></span></span></code></pre></div><p><strong>Keyword</strong>: DFS</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// LeetCode provided interface
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NestedInteger</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> isInteger() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getInteger</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>NestedInteger<span style=color:#f92672>&gt;&amp;</span> getList() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// DFS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> depthSum(std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>NestedInteger<span style=color:#f92672>&gt;&amp;</span> nestedList, <span style=color:#66d9ef>int</span> depth <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> sum{<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> nested: nestedList) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (nested.isInteger()) {
</span></span><span style=display:flex><span>                sum <span style=color:#f92672>+=</span> nested.getInteger() <span style=color:#f92672>*</span> depth;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                sum <span style=color:#f92672>+=</span> depthSum(nested.getList(), depth <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> sum;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Time: O(N), Space: O(Depth)</p><h3 id=346-moving-average-from-data-stream><a href=https://leetcode.com/problems/moving-average-from-data-stream/>346. Moving Average from Data Stream</a></h3><p><strong>PROBLEM STATEMENT</strong></p><p>You need to implement a class <code>MovingAverage</code> that calculates the moving average of the last <code>size</code> elements in a data stream.</p><p><strong>Keyword</strong>: Sliding Window</p><p><strong>Intuition</strong></p><ul><li>Classic sliding window, use queue</li><li>Track current sum while manipulating(add/remove) data</li></ul><p><strong>Solution</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;queue&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MovingAverage</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> MovingAverage(<span style=color:#66d9ef>int</span> size)<span style=color:#f92672>:</span> _size(size), _sum(<span style=color:#ae81ff>0.</span>) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>next</span>(<span style=color:#66d9ef>int</span> val) {
</span></span><span style=display:flex><span>        q.push(val);
</span></span><span style=display:flex><span>        sum <span style=color:#f92672>+=</span> val;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (q.size() <span style=color:#f92672>&gt;</span> _size) {
</span></span><span style=display:flex><span>            sum <span style=color:#f92672>-=</span> q.front();
</span></span><span style=display:flex><span>            q.pop();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> sum <span style=color:#f92672>/</span> q.size();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> _q;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> _sum;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> _size;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Time: O(1), Space: O(capacity)</p><h3 id=282-expression-add-operators><a href=https://leetcode.com/problems/expression-add-operators/>282. Expression Add Operators</a></h3><p><strong>HARD!!!</strong></p><h3 id=670-maximum-swap><a href=https://leetcode.com/problems/maximum-swap/>670. Maximum Swap</a></h3><p><strong>Keyword</strong>: Greedy</p><p><strong>Observations</strong></p><ul><li>Swap <strong>at most once</strong></li><li>For each digit, we want to <strong>swap with the largest on the right</strong></li><li>Among all the largest one the right, we want <strong>the rightmost digit</strong></li></ul><p><strong>Steps</strong></p><ul><li>Convert the number to string</li><li>Declare a std::array to store <em>last occured index of digit</em></li><li>Iterate string<ul><li>From biggest digit (9) to current digit<ul><li>If last occurred to the right (last occur index > i), swap and return</li></ul></li></ul></li></ul><p>Time: O(N), Capacity: O(1)</p><p><strong>Variant</strong></p><ul><li>Buil the second largest number<ul><li>Declare list of 10 to calculate the freqs</li><li>Build the largest number first</li><li>Iterate from right to left, swap the first number pair that&rsquo;s not equal, similar to <a href=/topics/interview/leetcode-top-interview/#31-next-permutation>31. Next Permutation</a></li></ul></li></ul><h3 id=31-next-permutation><a href=https://leetcode.com/problems/next-permutation/>31. Next Permutation</a></h3><p><strong>MEDIUM, BUT HARD</strong></p><p><strong>Intuition</strong></p><ul><li>Convert the digits to number is better to understand</li><li>The problem is equivalent to &ldquo;<strong>Find the next larger number</strong>&rdquo;</li><li>The digits on the right contribute less to the final number, so <strong>iterate from right to left</strong></li></ul><p><strong>Steps</strong></p><ul><li>Traverse from right to left to find the valley where $nums[i] &lt; nums[i-1]$</li><li>Traverse again from right to left to find the <strong>next higher digit</strong> after the valley, then swap.</li><li>Reverse the sequence from <code>i+1</code> to the end</li></ul><p><strong>Variant</strong></p><ul><li>Previous Permutation<ul><li>Reuse the code structure, change the following<ul><li>Instead of finding a valley, we find a peak</li><li>Instead of finding next higher to the right, we <strong>find next lower after the peak</strong></li></ul></li></ul></li></ul><h4 id=76-minimum-window-substring><a href=https://leetcode.com/problems/minimum-window-substring/>76. Minimum Window Substring</a></h4><p><strong>HARD</strong></p><p><strong>Keyword</strong>: Two-Pointer, Sliding Window</p><p><strong>Intuition</strong></p><ul><li>Count the frequency in <code>template</code></li><li>Using sliding window to expand and contract as needed</li><li>Track how many characters have met required count</li></ul><p><strong>Steps</strong></p><ul><li>Declare template frequency map: {char -> int}</li><li>Count the frequency in <code>template</code></li><li>Declare sliding window<ul><li>Window frequency map: {char -> int}</li><li>Window start</li><li>Window length</li></ul></li><li>Two pointers loop. <code>right</code> as expand iterator, <code>left</code> as contract iterator<ul><li>Get current <code>right</code>, and move on (expand)<ul><li>If this character is needed<ul><li>Window frequency increase</li><li>If the frequency is same, match counter increase</li></ul></li></ul></li><li>If match counter is same as need (meaning we have all the characters, but frequency may not correct), try to contract<ul><li>If current length is smaller, update min window length</li><li>Get current <code>left</code>, and move on (expand)<ul><li>If this character is needed<ul><li>If the frequency is same, match counter decrease</li><li>Window frequency decrease</li></ul></li></ul></li></ul></li></ul></li><li>Return substring</li></ul><p>Time: O(len(string), len(template)), Space: O(len(template))</p><h4 id=42-trapping-rain-water><a href=https://leetcode.com/problems/trapping-rain-water/>42. Trapping Rain Water</a></h4><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Observations</strong></p><ul><li>Water that can be trapping at index i is <code>std::min(leftMax, rightMax) - h[i]</code></li></ul><p><strong>Steps</strong></p><ul><li>Two pointers start at begining and end</li><li>When the two pointers not cross, loop<ul><li>If left is smaller, check left side<ul><li>Check if need to update <code>leftMax</code></li><li>Calculate water at current index</li><li>Move left pointer</li></ul></li><li>If right is small, check right side<ul><li>Check if need to update <code>rightMax</code></li><li>Calculate water at current index</li><li>Move right pointer</li></ul></li></ul></li></ul><p>Time: O(N), Space: O(1)</p><h3 id=meeting-rooms>Meeting Rooms</h3><h4 id=252-meeting-rooms-i><a href=https://leetcode.com/problems/meeting-rooms/>252. Meeting Rooms I</a></h4><p><strong>PROBLEM STATEMENT</strong></p><p>Given an array of meeting time intervals <code>intervals</code> where <code>intervals[i] = [start_i, end_i]</code>, determine if a person can attend all meetings (i.e., no overlapping meetings).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> canAttendMeetings(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> intervals) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Sort based on the starting time
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>sort(intervals.begin(), intervals.end());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Iterate if any start smaller than previous end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (size_t i{<span style=color:#ae81ff>1</span>}};i <span style=color:#f92672>&lt;</span> intervals.size(); <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (intervals[i][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;</span> intervals[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>]) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=253-meeting-rooms-ii><a href=https://leetcode.com/problems/meeting-rooms-ii/>253. Meeting Rooms II</a></h4><p><strong>PROBLEM STATEMENT</strong></p><p>Given an array of meeting time intervals <code>intervals</code> where <code>intervals[i] = [start_i, end_i]</code>, return the minimum number of conference rooms required.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> minMeetingRooms(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> intervals) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (intervals.empty()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Sort based on starting point
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>sort(intervals.begin(), intervals.end());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Use min heap to track the ending, as well as the ongoing meetings
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>priority_queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>, std<span style=color:#f92672>::</span>greater<span style=color:#f92672>&gt;</span> minHeap;
</span></span><span style=display:flex><span>        minHeap.push(intervals[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (size_t i{<span style=color:#ae81ff>1</span>}; i <span style=color:#f92672>&lt;</span> intervals.size(); <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If current meeting starts after (larger than) the earliest ending time
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (intervals[i][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&gt;=</span> minHeap.top()) {
</span></span><span style=display:flex><span>                minHeap.pop();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            minHeap.push(intervals[i][<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> minHeap.size();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=2402-meeting-rooms-iii><a href=https://leetcode.com/problems/meeting-rooms-iii/>2402. Meeting Rooms III</a></h4><p><strong>HARD</strong></p><h4 id=75-sort-colors><a href=https://leetcode.com/problems/sort-colors/>75. Sort Colors</a></h4><ul><li>We need to partition the array into 3 parts</li><li>Because in-place sort, so we need to swap</li><li>Use two pointers<ul><li><code>low</code> tracks 0s, <code>mid</code> tracks 1s, <code>high</code> tracks 2s</li><li><code>mid</code> traverse</li><li>check <code>nums[mid]</code></li></ul></li><li>Terminate when <code>mid</code> surpasses <code>high</code></li></ul><h4 id=825-friends-of-appropriate-ages><a href=https://leetcode.com/problems/friends-of-appropriate-ages/>825. Friends Of Appropriate Ages</a></h4><ul><li>Read the condition, and narrow down the real condition<ul><li>Condition 1 defines the min age</li><li>Condition 2 defines the max age</li><li>Special case is when max and min equal, $age = age * 0.5 + 7$, so min valid age is 14 + 1</li></ul></li><li>age is between 1&mldr;120</li><li>Use age range to try Condition 3, find out it&rsquo;s useless</li><li>For each age, we need to find the people count in valid range</li><li>Use count and prefix sum on ages</li></ul><h4 id=51-n-queens><a href=https://leetcode.com/problems/n-queens/>51. N-Queens</a></h4><p><strong>HARD</strong></p><h4 id=79-word-search><a href=https://leetcode.com/problems/word-search/>79. Word Search</a></h4><ul><li>Because we need to search to the end of the word to find a word, so use DFS</li><li>Iterate through <code>board</code>, search from the first letter</li><li>Use DFS to explore four directions</li><li>Mark visited cell before DFS (temporarily)</li><li>If index is equal to word len (iterate all characters)</li></ul><h4 id=283-move-zeroes><a href=https://leetcode.com/problems/move-zeroes/>283. Move Zeroes</a></h4><ul><li>Move in place, so we need to use two pointers, and swap</li><li><code>slow</code> tracks where the next non zero pointer should go</li><li><code>fast</code> find the non-zero elements</li><li>If found, swap</li></ul><h3 id=two-sums>Two Sums</h3><h4 id=1-two-sums><a href=https://leetcode.com/problems/two-sum/>1. Two Sums</a></h4><p><strong>Steps</strong></p><ul><li>Use hashtable to store the visited value and its index</li><li>Iterate the numbers<ul><li>If <code>target - nums[i]</code> exists in hashtable, append to result</li><li>Else insert new pair</li></ul></li></ul><h4 id=167-two-sums-ii><a href=https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/>167. Two Sums II</a></h4><ul><li>The difference with previous question is input array is sorted</li><li>Use two pointers, starts from the beginning and end</li><li>If sum is less than <code>target</code>, move left; greater than <code>target</code> move right, or return index pair</li></ul><h4 id=15-3sums><a href=https://leetcode.com/problems/3sum/>15. 3Sums</a></h4><ul><li>Sort the values</li><li>The rest is similar to <a href=/topics/interview/leetcode-top-interview/#two-sums-ii>Two Sums II</a></li><li>Be careful about the duplicated numbers, skip them in the outer loop as well as the inner loop after find one combination</li></ul><h4 id=827-making-a-large-island><a href=https://leetcode.com/problems/making-a-large-island/>827. Making A Large Island</a></h4><p><strong>HARD</strong></p><p><strong>Keywords</strong>: DFS</p><p><strong>Intuition</strong></p><ul><li>When we change a cell from sea into land, it also connect the neighbor lands together</li><li>Label all islands with unique ids, and save their size<ul><li>ID should starts from 2, because 0 is for water, 1 is for OG land(a.k.a. unvisited land)</li></ul></li><li>Try to turn each water into land, and calculate the new island size, update max island size<ul><li>Use <code>set</code> to avoid duplicated</li></ul></li></ul><p><strong>Steps</strong></p><ul><li>Declare hash map, {Island Id -> Island Size}<ul><li>Id starts from 2</li></ul></li><li>1st pass: Iterate cells, use DFS calculate size.</li><li>DFS function: return size, log visited (with Id), carry the Island size map<ul><li>If not in bound, or not unvisited land, return 0</li><li>If in bound<ul><li>Update Id</li><li>Explore 4 directions, (size from 1)</li></ul></li></ul></li><li>2nd pass: Find current max island size</li><li>3rd pass: Iterate cells, locate water and try to fill<ul><li>Explore 4 directions, and add neighbor</li><li>Sum up to calculate new size</li><li>Update new max size</li></ul></li></ul><p>Time: O($N^2$), Space: O($N^2$)</p><h4 id=1004-max-consecutive-ones-iii><a href=https://leetcode.com/problems/max-consecutive-ones-iii/>1004. Max Consecutive Ones III</a></h4><p><strong>Keywords</strong>: Sliding Windows</p><p><strong>Intuition</strong></p><ul><li>The problem is equivalent to <strong>find the widest window with at most <code>k</code> zeros</strong></li></ul><p><strong>Steps</strong></p><ul><li>Two pointers, iterate <code>right</code>, slide control with <code>left</code></li><li><code>zeroCount</code> to count zeros, <code>maxLen</code> to track current max length</li><li>Iterate numbers<ul><li>If zero, count up</li><li>If more than <code>k</code> zeros in the window, move <code>left</code></li><li>Update window length</li></ul></li></ul><p>Time: O(N), Space: O(1)</p><h4 id=65-valid-number><a href=https://leetcode.com/problems/valid-number/>65. Valid Number</a></h4><p><strong>HARD</strong></p><p><strong>Intuition</strong></p><ul><li>Nothing special, consider the following<ul><li>Start with optional sign?</li><li>Integer or decimal?</li><li>Optional <strong>exponent followed by an integer(even it&rsquo;s legit in math, not here)</strong></li></ul></li></ul><p><strong>Steps</strong></p><ul><li>If start with sign, move on</li><li>Iterate the following<ul><li>Is numberic? Log, and move on</li><li>Is dot? Met dot or exponent before?<ul><li>Yes -> Quit</li><li>No -> Log, and move on</li></ul></li><li>Is exp? Met exponent or no numberic before?<ul><li>Yes -> Quit</li><li>No -> Log, and <strong>reset meet numberic</strong>, and move on.<ul><li>Move on if followed by a sign</li></ul></li></ul></li><li>Other -> Quit</li></ul></li><li>Return Meet numberic or not</li></ul><h4 id=34-find-first-and-last-position-of-element-in-sorted-array><a href=https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/>34. Find First and Last Position of Element in Sorted Array</a></h4><p><strong>Keyword</strong>: Binary search</p><p><strong>Intuition</strong></p><ul><li>We can do a binary search to land in the target set, then expand outward</li><li><strong>BUT!!!</strong> That works only when we know targets is a small cluster, The worst cast is that, all the values are target, then time complexity is O(N)</li><li>So a more general solution would be <strong>binary search twice</strong>, don&rsquo;t stop after we find the target, continue search left and right half</li></ul><p><strong>Steps: Binary Search Twice</strong></p><ul><li>Custom binary search<ul><li>When target is found<ul><li>If want to find low bound, <code>right = mid - 1</code></li><li>If want to find high bound, <code>left = mid + 1</code></li></ul></li><li>We could even use template</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span> _isLow<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> findBound(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums, <span style=color:#66d9ef>int</span> target) {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Use case
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>auto</span> kLow{true};
</span></span><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>auto</span> kHigh{false};
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>constexpr</span> (kLow) {
</span></span><span style=display:flex><span>    right <span style=color:#f92672>=</span> mid <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    left <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>return</span> {findBound<span style=color:#f92672>&lt;</span>kLow<span style=color:#f92672>&gt;</span>(...), findBound<span style=color:#f92672>&lt;</span>kHigh<span style=color:#f92672>&gt;</span>(...)};
</span></span></code></pre></div><h4 id=249-group-shifted-strings><a href=https://leetcode.com/problems/group-shifted-strings/>249. Group Shifted Strings</a></h4><p><strong>PROBLEM STATEMENT</strong></p><p>We are given an array of strings. Two strings are shifted versions of each other if:</p><ul><li>You can shift each character in one string by the same number of positions in the alphabet to get the other string.</li><li>For example, &ldquo;abc&rdquo;  &ldquo;bcd&rdquo;  &ldquo;cde&rdquo; are all shifted versions.</li><li>More example, &ldquo;ace&rdquo;  &ldquo;ceg&rdquo;</li></ul><p>Task: Group all strings that are shifted versions of each other.</p><p><strong>Intuition</strong></p><ul><li>All the strings in a same group share same &ldquo;pattern&rdquo;</li><li>&ldquo;Shift pattern&rdquo; can be calculated by a vector of shift from the first character<ul><li>&ldquo;abc&rdquo; -> <code>[1, 1](by b-a, c-b)</code></li><li>&ldquo;bcd&rdquo; -> <code>[1, 1](by c-b, d-c)</code></li></ul></li><li>We can make it more robust, if we shift all the strings to &ldquo;a&rdquo;</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;&gt;</span> groupStrings(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;&amp;</span> strings) {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>unordered_map<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string, std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;&gt;</span> patternToStrings;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> str: strings) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> pattern <span style=color:#f92672>=</span> calcPattern(str);
</span></span><span style=display:flex><span>            patternToStrings[pattern].push_back(str);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;&gt;</span> res;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> [_, strings]<span style=color:#f92672>:</span> patternToStrings) {
</span></span><span style=display:flex><span>            res.push_back(strings);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string calcPattern(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> s) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Normalize to start from &#39;a&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> shift <span style=color:#f92672>=</span> s[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;a&#39;</span>;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>string pattern;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> ch: s) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Normalize -&gt; calculate diff -&gt; convert to char
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            pattern <span style=color:#f92672>+=</span> (ch <span style=color:#f92672>-</span> shift <span style=color:#f92672>+</span> <span style=color:#ae81ff>26</span>) <span style=color:#f92672>%</span> <span style=color:#ae81ff>26</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;a&#39;</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> pattern;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=2-add-two-numbers><a href=https://leetcode.com/problems/add-two-numbers/>2. Add Two Numbers</a></h4><p><strong>Intuition</strong></p><ul><li>Since numbers are stored in reverse order, adding them from head to tail is same as adding numbers</li></ul><p><strong>Steps</strong></p><ul><li>Declare a dummy pointer</li><li>Delcare <code>curr</code> and <code>carrier</code></li><li>Loop while <code>l1</code> and <code>l2</code> both valid</li><li>Loop either <code>l1</code> or <code>l2</code> valid</li><li>Append carrier node if it exists</li></ul><h4 id=33-search-in-rotated-sorted-array><a href=https://leetcode.com/problems/search-in-rotated-sorted-array/>33. Search in Rotated Sorted Array</a></h4><p><strong>Keyword</strong>: Binary Search</p><p><strong>Intuition</strong></p><ul><li>Modified binart search. Even though rotated, on each side, the arrays are still sorted</li></ul><p><strong>Steps</strong></p><ul><li>Binary search loop</li><li>Check which side is sorted<ul><li>Classic binary search</li></ul></li></ul><h4 id=19-remove-nth-node-from-end-of-list><a href=https://leetcode.com/problems/remove-nth-node-from-end-of-list/>19. Remove Nth Node From End of List</a></h4><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Intuition</strong></p><ul><li>For singly linked link, we can&rsquo;t access element by index, instead we have to count the move.</li><li>The distance between the earlier pointer and the later pointer keeps constant</li></ul><p><strong>Steps</strong></p><ul><li><code>first</code> and <code>second</code> pointer start from <code>dummy</code> node</li><li>Move <code>first</code> for <code>n+1</code> steps forward</li><li>Then move both together until <code>first</code> hits the end</li><li><code>second->next</code> is the one to remove</li></ul><p><strong>Note</strong></p><ul><li>Why <code>dummy</code> node?</li><li>Why move <code>n+1</code> steps?<ul><li>To remove the nth from the end, we need to arrive at the one before last nth node</li><li>The <code>first</code> pointer stops at pos n</li></ul></li></ul><h4 id=282-expression-add-operators-1><a href=https://leetcode.com/problems/expression-add-operators/>282. Expression Add Operators</a></h4><p><strong>HARD</strong></p><h3 id=498-diagonal-traverse><a href=https://leetcode.com/problems/diagonal-traverse/>498. Diagonal Traverse</a></h3><p><strong>Observation</strong></p><ul><li>The <code>row + col</code> of element on diagonal is the same.<ul><li>Origin at top left corner, x-axis to leftward, y-axis downward so diagonal is y = -x + k</li></ul></li><li>There are in total <code>m + n - 1</code> directions (Easy to visualize)</li></ul><p><strong>Steps</strong></p><ul><li>Iterate <code>m + n - 1</code> directions, <strong>from top to bottom, left to right</strong><ul><li>If even, go up-right<ul><li>Locate start point (left/bottom edge), move</li></ul></li><li>If odd, go down-left<ul><li>Locate start point (right/top edge), move</li></ul></li></ul></li></ul><p><strong>Note</strong></p><ul><li>How to understand <code>d</code>? e.g. $m=5, n=7$</li></ul><pre tabindex=0><code class=language-math data-lang=math>\begin{matrix}
0 &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 \\
1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 \\
2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 \\
3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 &amp; 9 \\
4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 &amp; 9 &amp; 10
\end{matrix}
</code></pre><h4 id=1539-kth-missing-positive-number><a href=https://leetcode.com/problems/kth-missing-positive-number/>1539. Kth Missing Positive Number</a></h4><p><strong>Keyword</strong>: Binary search</p><p><strong>Observations</strong></p><ul><li>For index <code>i</code>, the num of missing number before arr[i] is <code>arr[i] - i - 1</code><ul><li>If no missing, number <code>arr[i]</code> should be at index <code>arr[i] - 1</code>, but now at index <code>i</code>, so missing <code>arr[i] - i - 1</code></li></ul></li><li>We could use line scan. In case of large n, we use binary search</li></ul><p><strong>Steps</strong></p><ul><li><code>left</code> at 0, <code>right</code> at n</li><li>Calculate <code>mid</code>, and missing at <code>mid</code><ul><li>If less than <code>k</code>, move <code>left</code></li><li>Else, move <code>right</code></li></ul></li></ul><p><strong>Notes</strong></p><ul><li><code>while</code> condition, and how to update <code>left</code> and <code>right</code></li></ul><h4 id=708-insert-into-a-sorted-circular-linked-list><a href=https://leetcode.com/problems/insert-into-a-sorted-circular-linked-list/>708. Insert into a Sorted Circular Linked List</a></h4><p><strong>PROBLEM STATEMENT</strong></p><h4 id=636-exclusive-time-of-functions><a href=https://leetcode.com/problems/exclusive-time-of-functions/>636. Exclusive Time of Functions</a></h4><p><strong>Keyword</strong>: Stack</p><p><strong>Steps</strong></p><ul><li>Write a log parser</li><li>Iterate the logs while tracking the previous timestamp to know how much time the top function on the stack run since last event<ul><li>If it&rsquo;s a &ldquo;start&rdquo;, push into the stack, calculate the running time of current function (if there&rsquo;s any), update <code>prevTime</code></li><li>If it&rsquo;s a &ldquo;start&rdquo;, calculate the running time of current function, and pop stack, update <code>prevTime</code></li></ul></li></ul><p>Time: O(N), Space: O(N)</p><h4 id=523-continuous-subarray-sum><a href=https://leetcode.com/problems/continuous-subarray-sum/>523. Continuous Subarray Sum</a></h4><p><strong>Keyword</strong>: Prefix Sum</p><p><strong>Intuition</strong></p><ul><li>&ldquo;Subarray sum&rdquo;, probably use prefix sum</li><li><code>sum[i:j] = sum[j] - sum [i]</code> is divisible by <code>k</code>, that means <code>sum[i] % k == sum[j] % k</code></li></ul><p><strong>Steps</strong></p><ul><li>Use a hash table to store the Index -> mod<ul><li>Remember to add edge case {0: -1} <strong>!!!</strong></li></ul></li><li>Iterate the array<ul><li>If <code>mod % k</code> in the hash table<ul><li>Yes, return if the distance is more than 2</li><li>No, insert result</li></ul></li></ul></li></ul><p>Time: O(N), Space: O(N)</p><h4 id=270-closest-binary-search-tree-value><a href=https://leetcode.com/problems/closest-binary-search-tree-value/>270. Closest Binary Search Tree Value</a></h4><p><strong>PROBLEM STATEMENT</strong></p><h4 id=426-convert-binary-search-tree-to-sorted-doubly-linked-list><a href=https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/>426. Convert Binary Search Tree to Sorted Doubly Linked List</a></h4><p><strong>PROBLEM STATEMENT</strong></p><h4 id=14-longest-common-prefix><a href=https://leetcode.com/problems/longest-common-prefix/>14. Longest Common Prefix</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Steps</strong></p><ul><li>Use the first string as reference to scan other strings</li><li>Iterate character of the first string<ul><li>Compare to all other strings<ul><li>If not the same character at same index or new string is too small, return current substring</li></ul></li></ul></li><li>Return first string</li></ul><h3 id=graph>Graph</h3><h4 id=133-clone-graph><a href=https://leetcode.com/problems/clone-graph/>133. Clone Graph</a></h4><p><strong>Keyword</strong>: DFS on Graph</p><p><strong>Intuition</strong></p><ul><li>Use DFS to traverse the graph</li><li>Use one hash table to store cloned nodes {Old -> New} to avoid cycles</li><li>Cycles for graph is like leaf of tree but connected</li></ul><p><strong>Steps</strong></p><ul><li>The DFS function: Return cloned node, carrying (or cache) hash map<ul><li>If <code>nullptr</code> return <code>nullptr</code></li><li>If node is cloned, return the cloned node</li><li>Otherwise<ul><li>Clone new node</li><li>Recursively clone its neigbor</li></ul></li></ul></li><li>Start DFS from <code>root</code></li></ul><p>Time: O(N + E), Space: O(N)</p><h4 id=130-surrounded-regions><a href=https://leetcode.com/problems/surrounded-regions/>130. Surrounded Regions</a></h4><p><strong>Keyword</strong>: BFS</p><h4 id=207-course-schedule><a href=https://leetcode.com/problems/course-schedule/>207. Course Schedule</a></h4><p><strong>Keyword</strong>: BFS on Graph</p><p><strong>Key Idea</strong></p><ul><li>&ldquo;In Degree&rdquo;<ul><li>Definition: In a directed graph, the in-degree of a node is the number of edges pointing into it. The out-degree is the number of edges leaving it.</li><li>In topological sort, we<ul><li>Start with the node that have 0 in-degree</li><li>Then process and reduce the in-degree of the neighbor nodes</li></ul></li></ul></li></ul><p><strong>Steps</strong></p><ul><li>Iterate the prerequisites, to<ul><li>Build a graph, from pre course point to course</li><li>Track in-degree of the course</li></ul></li><li>Start with the course having 0 in-degree</li><li>BFS<ul><li>Process: Count up the taken course</li><li>Reduce the in-degree of the next courses</li></ul></li><li>The taken courses count should be equal to number of courses</li></ul><p>Time: O(N + E), Space: O(N + E)</p><h4 id=210-course-schedule-ii><a href=https://leetcode.com/problems/course-schedule-ii/>210. Course Schedule II</a></h4><p><strong>Intuition</strong></p><ul><li>Same as <a href=/topics/interview/leetcode-top-interview/#207-course-schedule>207. Course Schedule</a></li><li>Change BFS Process: append course</li></ul><h4 id=721-accounts-merge><a href=https://leetcode.com/problems/accounts-merge/>721. Accounts Merge</a></h4><h4 id=398-random-pick-index><a href=https://leetcode.com/problems/random-pick-index/>398. Random Pick Index</a></h4><h4 id=415-add-strings><a href=https://leetcode.com/problems/add-strings/>415. Add Strings</a></h4><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Intuition</strong></p><ul><li>Simulate adding operation from the end of two strings with a carrier</li><li>char -> digit: ch - &lsquo;0&rsquo;, digit -> char: d + &lsquo;0&rsquo;</li></ul><h4 id=824-goat-latin><a href=https://leetcode.com/problems/goat-latin/>824. Goat Latin</a></h4><p><strong>Keyword</strong>: String</p><p><strong>Intuition</strong></p><ul><li>Follow the instruction</li><li>Move first letter to the end: <code>s = s.substr(1) + s[0]</code></li></ul><h4 id=1768-merge-strings-alternately><a href=https://leetcode.com/problems/merge-strings-alternately/>1768. Merge Strings Alternately</a></h4><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Intuition</strong></p><ul><li><strong>Don&rsquo;t need to use extra variable</strong> to decide which letter to append<ul><li>Add one by one from word1 to word2 will do the job</li></ul></li></ul><h4 id=219-contains-duplicate-ii><a href=https://leetcode.com/problems/contains-duplicate-ii/>219. Contains Duplicate II</a></h4><p><strong>Intuition</strong></p><ul><li>Use a hash map to track <strong>the latest index where each number appeared</strong></li></ul><h4 id=173-binary-search-tree-iterator><a href=https://leetcode.com/problems/binary-search-tree-iterator/>173. Binary Search Tree Iterator</a></h4><h4 id=224-basic-calculator><a href=https://leetcode.com/problems/basic-calculator/>224. Basic Calculator</a></h4><h4 id=4-median-of-two-sorted-arrays><a href=https://leetcode.com/problems/median-of-two-sorted-arrays/>4. Median of Two Sorted Arrays</a></h4><h4 id=1047-remove-all-adjacent-duplicates-in-string><a href=https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/>1047. Remove All Adjacent Duplicates In String</a></h4><h4 id=1152-analyze-user-website-visit-pattern><a href=https://leetcode.com/problems/analyze-user-website-visit-pattern/>1152. Analyze User Website Visit Pattern</a></h4><p><strong>PROBLEM STATEMENT</strong></p><h4 id=994-rotting-oranges><a href=https://leetcode.com/problems/rotting-oranges/>994. Rotting Oranges</a></h4><p><strong>Keyword</strong>: BFS, Flood-Fill</p><p><strong>Intuition</strong></p><ul><li>Classic BFS flood-fill problem<ul><li>Multi sources, starts from rotten oranges</li><li>Process layer by layer (min by min)</li><li>Count min as BFS depth</li></ul></li></ul><p><strong>Steps</strong></p><ul><li>Traverse grid to prepare BFS<ul><li>Push rotten pos into queue</li><li>Count fresh count</li></ul></li><li>BFS loop<ul><li>Iterate all the rotten oranges in this layer<ul><li>Try 4 directions<ul><li>If out of range or not fresh, skip</li><li>Else rotten, push back to queue, decrease fresh count</li></ul></li></ul></li><li>Minute add up</li></ul></li><li>Return if no fresh left or not</li></ul><h4 id=128-longest-consecutive-sequence><a href=https://leetcode.com/problems/longest-consecutive-sequence/>128. Longest Consecutive Sequence</a></h4><p><strong>Intuition</strong></p><ul><li>Since the time complexity should be O(n), so we can&rsquo;t sort</li><li>We try to use hash set to make the query faster O(1)</li></ul><p><strong>Steps</strong></p><ul><li>Declare hash set, transform the nums into hash set</li><li>Iterate the <strong>set</strong> (IMPORTANT!!! As the test case may contain a lots of duplicated values)<ul><li>Start only when current number is start (<code>num - 1</code> not inside hash set)<ul><li>Count the length of the sequence starts with this number</li><li>Update longest length</li></ul></li></ul></li></ul><h4 id=735-asteroid-collision><a href=https://leetcode.com/problems/asteroid-collision/>735. Asteroid Collision</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Stack</p><p><strong>Intuition</strong></p><h4 id=380-insert-delete-getrandom-o1><a href=https://leetcode.com/problems/insert-delete-getrandom-o1/>380. Insert Delete GetRandom O(1)</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Data Structure</p><p><strong>Intuition</strong></p><ul><li>Because we need to random access element, so the underlying container should be vector</li><li>Because the <code>insert</code> and <code>remove</code> work O(1), we need to use hash map to fast query value, and access index</li></ul><p><strong>Steps</strong></p><ul><li>Under lying container <code>std::vector</code>, use hash map to track Value -> Index</li><li><code>insert</code><ul><li>If exist, return</li><li>Append to vector, and insert new Value -> Index</li></ul></li><li><code>remove</code><ul><li>If not exist, return</li><li>Get value&rsquo;s index</li><li>Swap <em>value&rsquo;s index</em> and <em>last index</em></li><li>Update new Value -> Index</li><li>Remove last value, and old Value -> Index</li></ul></li></ul><h4 id=3371-identify-the-largest-outlier-in-an-array><a href=https://leetcode.com/problems/identify-the-largest-outlier-in-an-array/>3371. Identify the Largest Outlier in an Array</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Intuition</strong></p><ul><li>Total Sum = Outlier + Sum of Special Numbers + [Special Numbers] = Outlier + 2 * Sum of Special Numbers</li><li>So we can iterate the <code>nums</code>, and find if outlier exists in <code>nums</code>, and find the max possible outlier</li><li>Be careful, the sum of special numbers should be on different index of outlier</li></ul><h4 id=322-coin-change><a href=https://leetcode.com/problems/coin-change/>322. Coin Change</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Dynamic Programming</p><h4 id=78-subsets><a href=https://leetcode.com/problems/subsets/>78. Subsets</a></h4><p><strong>Keyword</strong>: Backtrack</p><h4 id=54-spiral-matrix><a href=https://leetcode.com/problems/spiral-matrix/>54. Spiral Matrix</a></h4><p><strong>Intuition</strong></p><ul><li>Simulate the process</li></ul><p><strong>Steps</strong></p><h4 id=36-valid-sudoku><a href=https://leetcode.com/problems/valid-sudoku/>36. Valid Sudoku</a></h4><p><strong>Intuition</strong></p><ul><li>Simulate how human check Sudoku valid</li></ul><p><strong>Steps</strong></p><ul><li>Declare three <code>int[9][9]</code> to track if number occurance in rows, cols, and boxes</li><li>Iterate the elements<ul><li>If char is &lsquo;.&rsquo;, skip</li><li>If number exists in any row, col, or boxes, return false</li><li>Update number occurance</li></ul></li><li>Return true</li></ul><hr><h2 id=amazon>Amazon</h2><h3 id=bit-manipulation>Bit Manipulation</h3><h4 id=190-reverse-bits><a href=https://leetcode.com/problems/reverse-bits/>190. Reverse Bits</a></h4><p><strong>Steps</strong></p><ul><li>Declare the result value</li><li>Shift result left</li><li>Add the LSB of the input, <code>res |= (n & 1)</code></li><li>Shift input right</li></ul><h4 id=191-number-of-1-bits><a href=https://leetcode.com/problems/number-of-1-bits/>191. Number of 1 Bits</a></h4><p><strong>Approach I: Iterate through</strong></p><ul><li>Iterate the input bits</li><li>Count the LSB of the input, <code>count += (n & 1)</code></li><li>Shift input right</li></ul><p><strong>Approach II: Brian Kernighan&rsquo;s Algorithm</strong></p><ul><li>While input still exists<ul><li>Remove the lowest set bit</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hammingWeight</span>(<span style=color:#66d9ef>uint32_t</span> n) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (n) {
</span></span><span style=display:flex><span>    n <span style=color:#f92672>&amp;=</span> (n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#f92672>++</span>count;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> count;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=136-single-number><a href=https://leetcode.com/problems/single-number/>136. Single Number</a></h4><p><strong>Key Idea</strong></p><ul><li>Use <strong>XOR</strong> cancels out the pairs</li><li>XOR of a number with itself is 0</li><li>XOR with 0 leaves the number unchanged</li></ul><h4 id=137-single-number-ii><a href=https://leetcode.com/problems/single-number-ii/>137. Single Number II</a></h4><h4 id=2357-make-array-zero-by-subtracting-equal-amounts><a href=https://leetcode.com/problems/make-array-zero-by-subtracting-equal-amounts/>2357. Make Array Zero by Subtracting Equal Amounts</a></h4><p><strong>Intuition</strong></p><ul><li>Each operation removes <strong>one unique non-zero number</strong> from the set of values in the array.</li><li>Since subtracting the smallest non-zero value will eventually turn elements zero, <strong>the number of unique non-zero values</strong> in the array is exactly the number of operations needed.</li></ul><p><strong>Steps</strong></p><ul><li>Declare a set to track unique numbers</li><li>Return size</li></ul><h4 id=238-product-of-array-except-self><a href=https://leetcode.com/problems/product-of-array-except-self/>238. Product of Array Except Self</a></h4><p><strong>Intuition</strong></p><ul><li>We can&rsquo;t use divide</li><li>We compute the product of at index i from left product and right product</li></ul><h4 id=53-maximum-subarray><a href=https://leetcode.com/problems/maximum-subarray/>53. Maximum Subarray</a></h4><p><strong>Intuition</strong></p><ul><li>Similar to <a href=/topics/interview/leetcode-top-interview/#121-best-time-to-buy-and-sell-stock>Best Time to Buy and Sell Stock</a></li></ul><p><strong>Steps</strong></p><ul><li>Declare <code>curSum</code> as the first element, and <code>maxSum</code> as <code>curSum</code></li><li>Loop from the second element<ul><li>Update <code>curSum</code> based on append element or start new subarray</li><li>Update <code>maxSum</code></li></ul></li></ul><h2 id=leetcode-roadmap>LeetCode Roadmap</h2><p>Reference: <a href=https://neetcode.io/roadmap>neetcode</a></p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>graph TD;
    A(Array &amp; Hashing)--&gt;B(Two Pointers);
    A--&gt;C(Stack);
    B--&gt;D(Binary Search);
    B--&gt;E(Sliding Window);
    B--&gt;F(Linked List);
    D--&gt;G(Tree);
    F--&gt;G;
    G--&gt;H(Trie);
    G--&gt;I(Heap/Priority Queue);
    G--&gt;J(Backtracking)
    I--&gt;K(Intervals);
    I--&gt;L(Greedy);
    I--&gt;M(Advanced Graph);
    J--&gt;O(Graph);
    J--&gt;P(1D DP);
    O--&gt;Q(2D DP);
    P--&gt;Q;
    P--&gt;R(Bit Manipulation);
    R--&gt;S(Math &amp; Geometry);
    O--&gt;S;
    O--&gt;M
</code></pre><h2 id=leetcode-learn-by-roi>LeetCode Learn by ROI</h2><table><thead><tr><th style=text-align:center>Topic</th><th style=text-align:center>Difficulty</th><th style=text-align:center>ROI</th></tr></thead><tbody><tr><td style=text-align:center>Basic</td><td style=text-align:center>Easy</td><td style=text-align:center>Very High</td></tr><tr><td style=text-align:center>Two Pointers</td><td style=text-align:center>Easy</td><td style=text-align:center>High</td></tr><tr><td style=text-align:center>Sliding Window</td><td style=text-align:center>Easy</td><td style=text-align:center>High</td></tr><tr><td style=text-align:center>BFS</td><td style=text-align:center>Easy</td><td style=text-align:center>High</td></tr><tr><td style=text-align:center>DFS</td><td style=text-align:center>Medium</td><td style=text-align:center>High</td></tr><tr><td style=text-align:center>Backtracking</td><td style=text-align:center>High</td><td style=text-align:center>High</td></tr><tr><td style=text-align:center>Heap</td><td style=text-align:center>Medium</td><td style=text-align:center>Medium</td></tr><tr><td style=text-align:center>Binary Search</td><td style=text-align:center>Easy</td><td style=text-align:center>Medium</td></tr><tr><td style=text-align:center>Dynamic Programming</td><td style=text-align:center>High</td><td style=text-align:center>Medium</td></tr><tr><td style=text-align:center>Divide and Conquer</td><td style=text-align:center>Medium</td><td style=text-align:center>Low</td></tr><tr><td style=text-align:center>Trie</td><td style=text-align:center>Medium</td><td style=text-align:center>Low</td></tr><tr><td style=text-align:center>Union Find</td><td style=text-align:center>Medium</td><td style=text-align:center>Low</td></tr><tr><td style=text-align:center>Greedy</td><td style=text-align:center>Medium</td><td style=text-align:center>Low</td></tr></tbody></table><h2 id=useful-templates>Useful Templates</h2><p>Reference: <a href=https://algo.monster/templates>AlgoMonster</a></p><h3 id=backtracking---aggregation>Backtracking - Aggregation</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> startIndex, std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&amp;</span> target) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (isValid(target[startIndex:])) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> edge : getEdges(startIndex, [...additional states])) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (additional states) {
</span></span><span style=display:flex><span>            update([...additional states]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ans <span style=color:#f92672>=</span> aggregate(ans, dfs(startIndex <span style=color:#f92672>+</span> edge.length(), [...additional states])
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (additional states) {
</span></span><span style=display:flex><span>            revert([...additional states]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=backtracking---basic>Backtracking - Basic</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> startIndex, std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&amp;</span> target) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (isValid(target[startIndex:])) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> edge : getEdges(startIndex, [...additional states])) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (additional states) {
</span></span><span style=display:flex><span>            update([...additional states]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        ans <span style=color:#f92672>=</span> aggregate(ans, dfs(startIndex <span style=color:#f92672>+</span> edge.length(), [...additional states])
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (additional states) {
</span></span><span style=display:flex><span>            revert([...additional states]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=binary-search>Binary Search</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>binary_search</span>(std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> arr, <span style=color:#66d9ef>int</span> target) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> right <span style=color:#f92672>=</span> arr.size() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> firstTrueIndex <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (left <span style=color:#f92672>&lt;=</span> right) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> left <span style=color:#f92672>+</span> (right <span style=color:#f92672>-</span> left) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (feasible(mid)) {
</span></span><span style=display:flex><span>            firstTrueIndex <span style=color:#f92672>=</span> mid;
</span></span><span style=display:flex><span>            right <span style=color:#f92672>=</span> mid <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            left <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> firstTrueIndex;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=bfs-on-tree>BFS on Tree</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;*</span> bfs(Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;*</span> root) {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>queue<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;*&gt;</span> q;
</span></span><span style=display:flex><span>    q.push(root);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (q.size() <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;*</span> node <span style=color:#f92672>=</span> queue.front();
</span></span><span style=display:flex><span>        q.pop();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;*</span> child : node<span style=color:#f92672>-&gt;</span>children) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (is_goal(child)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>FOUND</span>(child);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            q.push(child);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> NOT_FOUND;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=dfs-on-tree>DFS on Tree</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;*</span> dfs(Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;*</span> root, <span style=color:#66d9ef>int</span> target) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (root<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>==</span> target) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> root;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;*</span> left <span style=color:#f92672>=</span> dfs(root<span style=color:#f92672>-&gt;</span>left, target);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (left) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> left;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dfs(root<span style=color:#f92672>-&gt;</span>right, target)  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=bfs-on-graph>BFS on Graph</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>bfs</span>(Node<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;*</span> root) {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>queue<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;*&gt;</span> q;
</span></span><span style=display:flex><span>    q.push(root);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>unordered_set<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;*&gt;</span> visited;
</span></span><span style=display:flex><span>    visited.emplace(root);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (q.size() <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;*</span> node <span style=color:#f92672>=</span> q.front();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (Node<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;*</span> neighbor : get_neighbors(node)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (visited.count(neighbor)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            q.push(neighbor);
</span></span><span style=display:flex><span>            visited.emplace(neighbor);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        q.pop();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=dfs-on-graph>DFS on Graph</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dfs</span>(Node<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;*</span> root, std<span style=color:#f92672>::</span>unordered_set<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;*&gt;&amp;</span> visited) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (Node<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;*</span> neighbor : node<span style=color:#f92672>-&gt;</span>neighbors) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (visited.count(neighbor)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        visited.emplace(neighbor);
</span></span><span style=display:flex><span>        dfs(neighbor, visited);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=bfs-on-matrix>BFS on Matrix</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> num_rows <span style=color:#f92672>=</span> grid.size();
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> num_cols <span style=color:#f92672>=</span> grid[<span style=color:#ae81ff>0</span>].size();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Coordinate<span style=color:#f92672>&gt;</span> get_neighbors(Coordinate coord) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> row <span style=color:#f92672>=</span> coord.row;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> col <span style=color:#f92672>=</span> coord.col;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> delta_row[<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> {<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> delta_col[<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Coordinate<span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> neighbor_row <span style=color:#f92672>=</span> row <span style=color:#f92672>+</span> delta_row[i];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> neighbor_col <span style=color:#f92672>=</span> col <span style=color:#f92672>+</span> delta_col[i];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#ae81ff>0</span> <span style=color:#f92672>&lt;=</span> neighbor_row <span style=color:#f92672>&amp;&amp;</span> neighbor_row <span style=color:#f92672>&lt;</span> num_rows <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>0</span> <span style=color:#f92672>&lt;=</span> neighbor_col <span style=color:#f92672>&amp;&amp;</span> neighbor_col <span style=color:#f92672>&lt;</span> num_cols) {
</span></span><span style=display:flex><span>            res.emplace_back(Coordinate(neighbor_row, neighbor_col));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>bfs</span>(Coordinate starting_node) {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>queue<span style=color:#f92672>&lt;</span>Coordinate<span style=color:#f92672>&gt;</span> q;
</span></span><span style=display:flex><span>    q.push(starting_node);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>unordered_set<span style=color:#f92672>&lt;</span>Coordinate<span style=color:#f92672>&gt;</span> visited;
</span></span><span style=display:flex><span>    visited.emplace(starting_node);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (q.size() <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        Coordinate node <span style=color:#f92672>=</span> q.front();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (Coordinate neighbor : get_neighbors(node)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (visited.count(neighbor)) <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Do stuff with the node if required
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            q.push(neighbor);
</span></span><span style=display:flex><span>            visited.emplace(neighbor);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        q.pop();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=prefix-sum>Prefix Sum</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> buildPrefixSum(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> arr) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> arr.size();
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> prefixSum(n);
</span></span><span style=display:flex><span>    prefixSum[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> arr[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        prefixSum[i] <span style=color:#f92672>=</span> prefixSum[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> arr[i];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> prefixSum;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Query sum of range [left, right] (inclusive)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>queryRange</span>(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> prefixSum, <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (left <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> prefixSum[right];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> prefixSum[right] <span style=color:#f92672>-</span> prefixSum[left<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=sliding-window---fixed-size>Sliding Window - Fixed Size</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>W <span style=color:#a6e22e>sliding_window_fixed</span>(std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> input, <span style=color:#66d9ef>int</span> window_size) {
</span></span><span style=display:flex><span>    W ans <span style=color:#f92672>=</span> window <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(input.begin(), input.begin() <span style=color:#f92672>+</span> window_size);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> right <span style=color:#f92672>=</span> window_size; right <span style=color:#f92672>&lt;</span> input.size(); <span style=color:#f92672>++</span>right) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> left <span style=color:#f92672>=</span> right <span style=color:#f92672>-</span> window_size;
</span></span><span style=display:flex><span>        remove input[left] from window
</span></span><span style=display:flex><span>        append input[right] to window
</span></span><span style=display:flex><span>        ans <span style=color:#f92672>=</span> optimal(ans, window);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=sliding-window---longest>Sliding Window - Longest</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>W <span style=color:#a6e22e>sliding_window_flexible_longest</span>(std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> input) {
</span></span><span style=display:flex><span>    initialize window, ans
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> right <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; right <span style=color:#f92672>&lt;</span> input.size(); <span style=color:#f92672>++</span>right) {
</span></span><span style=display:flex><span>        append input[right] to window
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (invalid(window)) {
</span></span><span style=display:flex><span>            remove input[left] from window
</span></span><span style=display:flex><span>            <span style=color:#f92672>++</span>left;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        ans <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>max(ans, window);       <span style=color:#75715e>// window is guaranteed to be valid here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=sliding-window---shortest>Sliding Window - Shortest</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>W <span style=color:#a6e22e>sliding_window_flexible_shortest</span>(std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> input) {
</span></span><span style=display:flex><span>    initialize window, ans
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> right <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; right <span style=color:#f92672>&lt;</span> input.size(); <span style=color:#f92672>++</span>right) {
</span></span><span style=display:flex><span>        append input[right] to window
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (valid(window)) {
</span></span><span style=display:flex><span>            ans <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>min(ans, window);   <span style=color:#75715e>// window is guaranteed to be valid here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            remove input[left] from window
</span></span><span style=display:flex><span>            <span style=color:#f92672>++</span>left;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=two-pointers---opposite-direction>Two Pointers - Opposite Direction</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>two_pointers_opposite</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> arr) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, right <span style=color:#f92672>=</span> arr.size() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (left <span style=color:#f92672>&lt;</span> right) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Process current elements
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> current <span style=color:#f92672>=</span> process(arr[left], arr[right]);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Update pointers based on condition
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (condition(arr[left], arr[right])) {
</span></span><span style=display:flex><span>            left<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            right<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=two-pointers---same-direction>Two Pointers - Same Direction</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>two_pointers_same</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> arr) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> slow <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, fast <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (fast <span style=color:#f92672>&lt;</span> arr.size()) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Process current elements
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> current <span style=color:#f92672>=</span> process(arr[slow], arr[fast]);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Update pointers based on condition
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (condition(arr[slow], arr[fast])) {
</span></span><span style=display:flex><span>            slow<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Fast pointer always moves forward
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        fast<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></article></div></div><div class="col-sm-12 col-md-12 col-lg-3"><div id=stickySideBar class=sticky-sidebar><aside class=toc><h5>Table Of Contents</h5><div class=toc-content><nav id=TableOfContents><ul><li><a href=#array--string>Array & String</a><ul><li><a href=#88-merge-sorted-array><a href=https://leetcode.com/problems/merge-sorted-array/>88. Merge Sorted Array</a></a></li><li><a href=#27-remove-item><a href=https://leetcode.com/problems/remove-element/>27. Remove Item</a></a></li><li><a href=#26-remove-duplicates-from-sorted-array><a href=https://leetcode.com/problems/remove-duplicates-from-sorted-array/>26. Remove Duplicates from Sorted Array</a></a></li><li><a href=#80-remove-duplicates-from-sorted-array-ii><a href=https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/>80. Remove Duplicates from Sorted Array II</a></a></li><li><a href=#169-majority-element><a href=https://leetcode.com/problems/majority-element/>169. Majority Element</a></a></li><li><a href=#189-rotate-array><a href=https://leetcode.com/problems/rotate-array/>189. Rotate Array</a></a></li><li><a href=#121-best-time-to-buy-and-sell-stock><a href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock/>121. Best Time to Buy and Sell Stock</a></a></li><li><a href=#122-best-time-to-buy-and-sell-stock-ii><a href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/>122: Best Time to Buy and Sell Stock II</a></a></li><li><a href=#55-jump-game><a href=https://leetcode.com/problems/jump-game/>55. Jump Game</a></a></li><li><a href=#45-jump-game-ii><a href=https://leetcode.com/problems/jump-game-ii/>45. Jump Game II</a></a></li><li><a href=#383-ransom-note><a href=https://leetcode.com/problems/ransom-note/>383. Ransom Note</a></a></li><li><a href=#141-linked-list-cycle><a href=https://leetcode.com/problems/linked-list-cycle/>141. Linked List Cycle</a></a></li></ul></li><li><a href=#intervals>Intervals</a><ul><li></li></ul></li><li><a href=#stack>Stack</a></li><li><a href=#binary-tree-general>Binary Tree General</a><ul><li></li><li><a href=#graph-general>Graph General</a></li></ul></li><li><a href=#binary>Binary</a><ul><li></li></ul></li><li><a href=#binary-tree>Binary Tree</a><ul><li><a href=#314-binary-tree-vertical-order-traversal><a href=https://leetcode.com/problems/binary-tree-vertical-order-traversal/>314. Binary Tree Vertical Order Traversal</a></a></li><li><a href=#987-vertical-order-traversal-of-a-binary-tree><a href=https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/>987. Vertical Order Traversal of a Binary Tree</a></a></li><li><a href=#236-lowest-common-ancestor-of-a-binary-tree><a href=https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/>236. Lowest Common Ancestor of a Binary Tree</a></a></li><li><a href=#1650-lowest-common-ancestor-of-a-binary-tree-iii><a href=https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/>1650. Lowest Common Ancestor of a Binary Tree III</a></a></li><li><a href=#199-binary-tree-right-side-view><a href=https://leetcode.com/problems/binary-tree-right-side-view>199. Binary Tree Right Side View</a></a></li><li><a href=#543-diameter-of-binary-tree><a href=https://leetcode.com/problems/diameter-of-binary-tree/>543. Diameter of Binary Tree</a></a></li><li><a href=#863-all-nodes-distance-k-in-binary-tree><a href=https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/>863. All Nodes Distance K in Binary Tree</a></a></li><li><a href=#124-binary-tree-maximum-path-sum><a href=https://leetcode.com/problems/binary-tree-maximum-path-sum/>124. Binary Tree Maximum Path Sum</a></a></li><li><a href=#297-serialize-and-deserialize-binary-tree><a href=https://leetcode.com/problems/serialize-and-deserialize-binary-tree/>297. Serialize and Deserialize Binary Tree</a></a></li><li><a href=#129-sum-root-to-leaf-numbers><a href=https://leetcode.com/problems/sum-root-to-leaf-numbers/>129. Sum Root to Leaf Numbers</a></a></li></ul></li><li><a href=#binary-search-treebst>Binary Search Tree(BST)</a><ul><li><a href=#938-range-sum-of-bst><a href=https://leetcode.com/problems/range-sum-of-bst/>938. Range Sum of BST</a></a></li></ul></li><li><a href=#string>String</a><ul><li><a href=#20-valid-parentheses><a href=https://leetcode.com/problems/valid-parentheses/>20. Valid Parentheses</a></a></li><li><a href=#22-generate-parentheses><a href=https://leetcode.com/problems/generate-parentheses/>22. Generate Parentheses</a></a></li><li><a href=#1249-minimum-remove-to-make-valid-parentheses><a href=https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses>1249. Minimum Remove to Make Valid Parentheses</a></a></li><li><a href=#921-minimum-add-to-make-parentheses-valid><a href=https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/>921. Minimum Add to Make Parentheses Valid</a></a></li><li><a href=#408-valid-word-abbreviation><a href=https://leetcode.com/problems/valid-word-abbreviation/>408. Valid Word Abbreviation</a></a></li><li><a href=#791-custom-sort-string><a href=https://leetcode.com/problems/custom-sort-string/>791. Custom Sort String</a></a></li><li><a href=#215-kth-largest-element-in-an-array><a href=https://leetcode.com/problems/kth-largest-element-in-an-array/>215. Kth Largest Element in an Array</a></a></li><li><a href=#227-basic-calculator-ii><a href=https://leetcode.com/problems/basic-calculator-ii/>227. Basic Calculator II</a></a></li><li><a href=#528-random-pick-with-weight><a href=https://leetcode.com/problems/random-pick-with-weight/>528. Random Pick with Weight</a></a></li><li><a href=#162-find-peak-element><a href=https://leetcode.com/problems/find-peak-element/>162. Find Peak Element</a></a></li><li><a href=#50-powx-n><a href=https://leetcode.com/problems/powx-n/>50. Pow(x, n)</a></a></li><li><a href=#71-simplify-path><a href=https://leetcode.com/problems/simplify-path/>71. Simplify Path</a></a></li><li><a href=#1091-shortest-path-in-binary-matrix><a href=https://leetcode.com/problems/shortest-path-in-binary-matrix/>1091. Shortest Path in Binary Matrix</a></a></li><li><a href=#1570-dot-product-of-two-sparse-vectors><a href=https://leetcode.com/problems/dot-product-of-two-sparse-vectors/>1570. Dot Product of Two Sparse Vectors</a></a></li><li><a href=#125-valid-palindrome><a href=https://leetcode.com/problems/valid-palindrome/>125. Valid Palindrome</a></a></li><li><a href=#680-valid-palindrome-ii><a href=https://leetcode.com/problems/valid-palindrome-ii/>680. Valid Palindrome II</a></a></li><li><a href=#5-longest-palindromic-substring><a href=https://leetcode.com/problems/longest-palindromic-substring/>5. Longest Palindromic Substring</a></a></li><li><a href=#767-reorganize-string><a href=https://leetcode.com/problems/reorganize-string/>767. Reorganize String</a></a></li><li><a href=#49-group-anagrams><a href=https://leetcode.com/problems/group-anagrams/>49. Group Anagrams</a></a></li><li><a href=#3-longest-substring-without-repeating-characters><a href=https://leetcode.com/problems/longest-substring-without-repeating-characters/>3. Longest Substring Without Repeating Characters</a></a></li><li><a href=#560-subarray-sum-equals-k><a href=https://leetcode.com/problems/subarray-sum-equals-k/>560. Subarray Sum Equals K</a></a></li><li><a href=#116-populating-next-right-pointers-in-each-node><a href=https://leetcode.com/problems/populating-next-right-pointers-in-each-node/>116. Populating Next Right Pointers in Each Node</a></a></li><li><a href=#56-merge-intervals><a href=https://leetcode.com/problems/merge-intervals/>56. Merge Intervals</a></a></li><li><a href=#146-lru-cache><a href=https://leetcode.com/problems/lru-cache>146. LRU Cache</a></a></li><li><a href=#347-top-k-frequent-elements><a href=https://leetcode.com/problems/top-k-frequent-elements>347. Top K Frequent Elements</a></a></li><li><a href=#973-k-closest-points-to-origin><a href=https://leetcode.com/problems/k-closest-points-to-origin/>973. K Closest Points to Origin</a></a></li><li><a href=#1762-buildings-with-an-ocean-view><a href=https://leetcode.com/problems/buildings-with-an-ocean-view/>1762. Buildings With an Ocean View</a></a></li><li><a href=#986-interval-list-intersections><a href=https://leetcode.com/problems/interval-list-intersections/>986. Interval List Intersections</a></a></li><li><a href=#138-copy-list-with-random-pointer><a href=https://leetcode.com/problems/copy-list-with-random-pointer/>138. Copy List with Random Pointer</a></a></li><li><a href=#23-merge-k-sorted-lists><a href=https://leetcode.com/problems/merge-k-sorted-lists/>23. Merge k Sorted Lists</a></a></li><li><a href=#339-nested-list-weight-sum><a href=https://leetcode.com/problems/nested-list-weight-sum/>339. Nested List Weight Sum</a></a></li><li><a href=#346-moving-average-from-data-stream><a href=https://leetcode.com/problems/moving-average-from-data-stream/>346. Moving Average from Data Stream</a></a></li><li><a href=#282-expression-add-operators><a href=https://leetcode.com/problems/expression-add-operators/>282. Expression Add Operators</a></a></li><li><a href=#670-maximum-swap><a href=https://leetcode.com/problems/maximum-swap/>670. Maximum Swap</a></a></li><li><a href=#31-next-permutation><a href=https://leetcode.com/problems/next-permutation/>31. Next Permutation</a></a></li><li><a href=#meeting-rooms>Meeting Rooms</a></li><li><a href=#two-sums>Two Sums</a></li><li><a href=#498-diagonal-traverse><a href=https://leetcode.com/problems/diagonal-traverse/>498. Diagonal Traverse</a></a></li><li><a href=#graph>Graph</a></li></ul></li><li><a href=#amazon>Amazon</a><ul><li><a href=#bit-manipulation>Bit Manipulation</a></li></ul></li><li><a href=#leetcode-roadmap>LeetCode Roadmap</a></li><li><a href=#leetcode-learn-by-roi>LeetCode Learn by ROI</a></li><li><a href=#useful-templates>Useful Templates</a><ul><li><a href=#backtracking---aggregation>Backtracking - Aggregation</a></li><li><a href=#backtracking---basic>Backtracking - Basic</a></li><li><a href=#binary-search>Binary Search</a></li><li><a href=#bfs-on-tree>BFS on Tree</a></li><li><a href=#dfs-on-tree>DFS on Tree</a></li><li><a href=#bfs-on-graph>BFS on Graph</a></li><li><a href=#dfs-on-graph>DFS on Graph</a></li><li><a href=#bfs-on-matrix>BFS on Matrix</a></li><li><a href=#prefix-sum>Prefix Sum</a></li><li><a href=#sliding-window---fixed-size>Sliding Window - Fixed Size</a></li><li><a href=#sliding-window---longest>Sliding Window - Longest</a></li><li><a href=#sliding-window---shortest>Sliding Window - Shortest</a></li><li><a href=#two-pointers---opposite-direction>Two Pointers - Opposite Direction</a></li><li><a href=#two-pointers---same-direction>Two Pointers - Same Direction</a></li></ul></li></ul></nav></div></aside><aside class=social><h5>Social</h5><div class=social-content><ul class=list-inline><li class="list-inline-item text-center"><a target=_blank href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fbobblelaw.github.io%2ftopics%2finterview%2fleetcode-top-interview%2f"><i class="fab fa-linkedin"></i></a></li><li class="list-inline-item text-center"><a target=_blank href="https://twitter.com/share?text=&url=https%3a%2f%2fbobblelaw.github.io%2ftopics%2finterview%2fleetcode-top-interview%2f"><i class="fab fa-twitter"></i></a></li><li class="list-inline-item text-center"><a target=_blank href="https://api.whatsapp.com/send?text=: https%3a%2f%2fbobblelaw.github.io%2ftopics%2finterview%2fleetcode-top-interview%2f"><i class="fab fa-whatsapp"></i></a></li><li class="list-inline-item text-center"><a target=_blank href='mailto:?subject=&amp;body=Check%20out%20this%20site https%3a%2f%2fbobblelaw.github.io%2ftopics%2finterview%2fleetcode-top-interview%2f'><i class="fa fa-envelope"></i></a></li></ul></div></aside></div></div></div><div class=row><div class="col-sm-12 col-md-12 col-lg-9 p-4"></div></div></div><button class="p-2 px-3" onclick=topFunction() id=topScroll>
<i class="fas fa-angle-up"></i></button></section><div class=progress><div id=scroll-progress-bar class=progress-bar role=progressbar aria-valuenow=0 aria-valuemin=0 aria-valuemax=100></div></div><script src=/js/scrollProgressBar.js></script><script>var topScroll=document.getElementById("topScroll");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?topScroll.style.display="block":topScroll.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}let stickySideBarElem=document.getElementById("stickySideBar"),stickyNavBar=!0;if(stickyNavBar){let e=document.getElementById("profileHeader"),t=e.offsetHeight+15;stickySideBarElem.style.top=t+"px"}else stickySideBarElem.style.top="50px"</script><script src=/js/readingTime.js></script></div><footer><div class="text-center pt-2"><span class=px-1><a href=https://github.com/BobbleLaw aria-label=github><svg width="2.7em" height="2.7em" viewBox="0 0 1792 1792"><path id="footer-socialNetworks-github-svg-path" d="M522 1352q-8 9-20-3-13-11-4-19 8-9 20 3 12 11 4 19zm-42-61q9 12 0 19-8 6-17-7t0-18q9-7 17 6zm-61-60q-5 7-13 2-10-5-7-12 3-5 13-2 10 5 7 12zm31 34q-6 7-16-3-9-11-2-16 6-6 16 3 9 11 2 16zm129 112q-4 12-19 6-17-4-13-15t19-7q16 5 13 16zm63 5q0 11-16 11-17 2-17-11 0-11 16-11 17-2 17 11zm58-10q2 10-14 14t-18-8 14-15q16-2 18 9zm964-956v960q0 119-84.5 203.5T1376 1664h-224q-16 0-24.5-1t-19.5-5-16-14.5-5-27.5v-239q0-97-52-142 57-6 102.5-18t94-39 81-66.5 53-105T1386 856q0-121-79-206 37-91-8-204-28-9-81 11t-92 44l-38 24q-93-26-192-26t-192 26q-16-11-42.5-27T578 459.5 492 446q-44 113-7 204-79 85-79 206 0 85 20.5 150t52.5 105 80.5 67 94 39 102.5 18q-40 36-49 103-21 10-45 15t-57 5-65.5-21.5T484 1274q-19-32-48.5-52t-49.5-24l-20-3q-21 0-29 4.5t-5 11.5 9 14 13 12l7 5q22 10 43.5 38t31.5 51l10 23q13 38 44 61.5t67 30 69.5 7 55.5-3.5l23-4q0 38 .5 103t.5 68q0 22-11 33.5t-22 13-33 1.5H416q-119 0-203.5-84.5T128 1376V416q0-119 84.5-203.5T416 128h960q119 0 203.5 84.5T1664 416z"/></svg>
</a></span><span class=px-1><a href=https://www.linkedin.com/in/boblzy aria-label=linkedin><svg width="2.4em" height="2.4em" fill="#fff" aria-label="LinkedIn" viewBox="0 0 512 512"><rect width="512" height="512" fill="#0077b5" rx="15%"/><circle cx="142" cy="138" r="37"/><path stroke="#fff" stroke-width="66" d="M244 194v198M142 194v198"/><path d="M276 282c0-20 13-40 36-40 24 0 33 18 33 45v105h66V279c0-61-32-89-76-89-34 0-51 19-59 32"/></svg></a></span></div><div class="container py-4"><div class="row justify-content-center"><div class="col-md-4 text-center"><div class=pb-2><a href=https://bobblelaw.github.io/ title="Bobble Law"><img alt="Footer logo" src=/logo.png height=40px width=40px></a></div>&copy; 2025 All rights reserved<div class=text-secondary>Made with
<span class=text-danger>&#10084;
</span>and
<a href=https://github.com/gurusabarish/hugo-profile target=_blank title="Designed and developed by gurusabarish">Hugo Profile</a></div></div></div></div></footer><script src=/bootstrap-5/js/bootstrap.bundle.min.js></script><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))});var tooltipTriggerList=[].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]')),tooltipList=tooltipTriggerList.map(function(e){return new bootstrap.Tooltip(e)})</script><script src=/js/search.js></script><section id=search-content class=py-2><div class=container id=search-results></div></section></body></html>