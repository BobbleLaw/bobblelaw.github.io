<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta http-equiv=Accept-CH content="DPR, Viewport-Width, Width"><link rel=icon href=/logo.png type=image/gif><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" media=print onload='this.media="all"'><noscript><link href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel=stylesheet></noscript><link rel=stylesheet href=/css/font.css media=all><meta property="og:url" content="https://bobblelaw.github.io/topics/interview/leetcode-top-interview/"><meta property="og:site_name" content="Bobble Law"><meta property="og:title" content="Bobble Law"><meta property="og:description" content="LeetCode Top Interview Questions Top 150 Array & String 88. Merge Sorted Array Two pointers, all start from the end Iterate from the end as well Copy the rest 27. Remove Item two pointers, one tracks valid number, one iterates.
26. Remove Duplicates from Sorted Array two pointers, one tracks concecutive duplicated, one iterates.
80. Remove Duplicates from Sorted Array II Similar to 26, the starting point and if condition are different. Generalize to max k duplicated."><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="article:section" content="topics"><meta name=twitter:card content="summary"><meta name=twitter:title content="Bobble Law"><meta name=twitter:description content="LeetCode Top Interview Questions Top 150 Array & String 88. Merge Sorted Array Two pointers, all start from the end Iterate from the end as well Copy the rest 27. Remove Item two pointers, one tracks valid number, one iterates.
26. Remove Duplicates from Sorted Array two pointers, one tracks concecutive duplicated, one iterates.
80. Remove Duplicates from Sorted Array II Similar to 26, the starting point and if condition are different. Generalize to max k duplicated."><link rel=stylesheet href=/bootstrap-5/css/bootstrap.min.css media=all><link rel=stylesheet href=/css/header.css media=all><link rel=stylesheet href=/css/footer.css media=all><link rel=stylesheet href=/css/theme.css media=all><style>:root{--text-color:#343a40;--text-secondary-color:#6c757d;--text-link-color:#007bff;--background-color:#eaedf0;--secondary-background-color:#64ffda1a;--primary-color:#007bff;--secondary-color:#f8f9fa;--text-color-dark:#e4e6eb;--text-secondary-color-dark:#b0b3b8;--text-link-color-dark:#ffffff;--background-color-dark:#18191a;--secondary-background-color-dark:#212529;--primary-color-dark:#ffffff;--secondary-color-dark:#212529}body{font-size:1rem;font-weight:400;line-height:1.5;text-align:left}html{background-color:var(--background-color)!important}body::-webkit-scrollbar{height:0;width:8px;background-color:var(--background-color)}::-webkit-scrollbar-track{border-radius:1rem}::-webkit-scrollbar-thumb{border-radius:1rem;background:#b0b0b0;outline:1px solid var(--background-color)}#search-content::-webkit-scrollbar{width:.5em;height:.1em;background-color:var(--background-color)}</style><meta name=description content><link rel=stylesheet href=/css/single.css><script defer src=/fontawesome-6/all-6.4.2.js></script><title>| Bobble Law</title></head><body class=light><script>let localStorageValue=localStorage.getItem("pref-theme"),mediaQuery=window.matchMedia("(prefers-color-scheme: dark)").matches;switch(localStorageValue){case"dark":document.body.classList.add("dark");break;case"light":document.body.classList.remove("dark");break;default:mediaQuery&&document.body.classList.add("dark");break}</script><script>var prevScrollPos=window.pageYOffset;window.addEventListener("scroll",function(){let s=document.getElementById("profileHeader"),t=window.pageYOffset,n=!1,o=!0,i=o?prevScrollPos>t:t>0;i?s.classList.add("showHeaderOnTop"):n=!0,t===0&&(n=!0),n&&s.classList.remove("showHeaderOnTop"),prevScrollPos=t})</script><header id=profileHeader><nav class="pt-3 navbar navbar-expand-lg animate"><div class="container-fluid mx-xs-2 mx-sm-5 mx-md-5 mx-lg-5"><a class="navbar-brand primary-font text-wrap" href=/><img src=/logo.png width=30 height=30 class="d-inline-block align-top">
Bob Law</a><div><input id=search autocomplete=off class="form-control mr-sm-2 d-none d-md-block" placeholder=Search... aria-label=Search oninput=searchOnChange(event)></div><button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarContent aria-controls=navbarContent aria-expanded=false aria-label="Toggle navigation"><svg aria-hidden="true" height="24" viewBox="0 0 16 16" width="24" data-view-component="true"><path fill-rule="evenodd" d="M1 2.75A.75.75.0 011.75 2h12.5a.75.75.0 110 1.5H1.75A.75.75.0 011 2.75zm0 5A.75.75.0 011.75 7h12.5a.75.75.0 110 1.5H1.75A.75.75.0 011 7.75zM1.75 12a.75.75.0 100 1.5h12.5a.75.75.0 100-1.5H1.75z"/></svg></button><div class="collapse navbar-collapse text-wrap primary-font" id=navbarContent><ul class="navbar-nav ms-auto text-center"><li class="nav-item navbar-text d-block d-md-none"><div class=nav-link><input id=search autocomplete=off class="form-control mr-sm-2" placeholder=Search... aria-label=Search oninput=searchOnChange(event)></div></li><li class="nav-item navbar-text"><a class=nav-link href=/#about aria-label=about>About</a></li><li class="nav-item navbar-text"><a class=nav-link href=/#experience aria-label=experience>Experience</a></li><li class="nav-item navbar-text"><a class=nav-link href=/#education aria-label=education>Education</a></li><li class="nav-item navbar-text"><a class=nav-link href=/posts title>Posts</a></li><li class="nav-item navbar-text"><a class=nav-link href=/tags title>Tags</a></li><li class="nav-item navbar-text"><a class=nav-link href=/topics title>Topics</a></li><li class="nav-item navbar-text"><div class=text-center><button id=theme-toggle><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></li></ul></div></div></nav></header><div id=content><section id=single><div class=container><div class="row justify-content-center"><div class="col-sm-12 col-md-12 col-lg-9"><div class=pr-lg-4><div class="title mb-5"><h1 class="text-center mb-4"></h1><div class=text-center>Jan 1, 1010
<span id=readingTime>min read</span></div></div><article class="page-content p-2"><h1 id=leetcode-top-interview-questions>LeetCode Top Interview Questions</h1><h2 id=top-150>Top 150</h2><h3 id=array--string>Array & String</h3><h4 id=88-merge-sorted-array>88. Merge Sorted Array</h4><ul><li>Two pointers, all start from the end</li><li>Iterate from the end as well</li><li>Copy the rest</li></ul><h4 id=27-remove-item>27. Remove Item</h4><p>two pointers, one tracks valid number, one iterates.</p><h4 id=26-remove-duplicates-from-sorted-array>26. Remove Duplicates from Sorted Array</h4><p>two pointers, one tracks concecutive duplicated, one iterates.</p><h4 id=80-remove-duplicates-from-sorted-array-ii>80. Remove Duplicates from Sorted Array II</h4><p>Similar to 26, the starting point and <code>if</code> condition are different. Generalize to max k duplicated.</p><ul><li>First k element always valid.</li></ul><h4 id=169-majority-element>169. Majority Element</h4><ul><li>Appears more than n / 2</li><li>Sort and return the median</li></ul><h4 id=189-rotate-array>189. Rotate Array</h4><ul><li>Rotate all -> rotate first k -> rotate remaining</li></ul><h4 id=121-best-time-to-buy-and-sell-stock>121. Best Time to Buy and Sell Stock</h4><ul><li>Track min profit so far</li><li>Calculate potential profit each step, and update</li></ul><h4 id=122-best-time-to-buy-and-sell-stock-ii>122: Best Time to Buy and Sell Stock II</h4><ul><li>Every increase is an oppotunity to make profit</li><li>Sum up all the increase</li></ul><h4 id=55-jump-game>55. Jump Game</h4><ul><li>Track the max reachable index</li><li>if index > max reach -> false. update max reach</li></ul><h4 id=45-jump-game-ii>45. Jump Game II</h4><h4 id=383-ransom-note>383. Ransom Note</h4><ul><li>Use hash table to count occurrence of each letter</li><li>Knowing all the characters are letter, we can use array instead of hash table</li></ul><h4 id=141-linked-list-cycle>141. Linked List Cycle</h4><ul><li>Two pointer, slow and fast</li></ul><h3 id=intervals>Intervals</h3><h4 id=228-summary-ranges>228. Summary Ranges</h4><ul><li>Two pointer, one point to the range start, one is iterating</li><li><strong>Be creaful of the condition</strong></li></ul><h3 id=stack>Stack</h3><h4 id=20-valid-parentheses>20. Valid Parentheses</h4><ul><li>Use stack to hold the iterated characters</li><li>Closing bracket at the front, e.g. {&rsquo;}&rsquo;, &lsquo;{&rsquo;}</li></ul><h3 id=binary-tree-general>Binary Tree General</h3><h4 id=104-maximum-depth-of-binary-tree>104. Maximum Depth of Binary Tree</h4><ul><li>Small tree use DFS, deep trees use <strong>BFS</strong>.</li></ul><h4 id=100-same-tree>100. Same Tree</h4><ul><li>Try <strong>BFS</strong></li></ul><h3 id=graph-general>Graph General</h3><h4 id=200-number-of-islands>200. Number of Islands</h4><ul><li>DFS. Traverse grid, mark (try to sink) visited cell</li></ul><h3 id=binary>Binary</h3><h4 id=67-add-binary>67. Add Binary</h4><ul><li>Simulate binary addition (with two pointers)</li></ul><h3 id=1d-dp>1D DP</h3><h4 id=70-climbing-stairs>70. Climbing Stairs</h4><ul><li>Recurrence relation: <code>dp[n] = dp[n - 1] + dp[n - 2]</code></li><li>Base case is dp[1] = 1, dp[2] = 2</li><li>Use the spatial efficient method</li></ul><hr><h2 id=meta-tagged-questions>Meta Tagged Questions</h2><h3 id=1249-minimum-remove-to-make-valid-parentheses><a href=https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses>1249. Minimum Remove to Make Valid Parentheses</a></h3><p>Two passes with stack</p><ol><li>1st pass: locate the unpaired &lsquo;)&rsquo;</li><li>Add the left &lsquo;(&rsquo; indices in the stack</li><li>Build new string by removing invalid indices</li></ol><p>Time: O(N), Space: O(N)</p><h3 id=408-valid-word-abbreviation>408. Valid Word Abbreviation</h3><p><strong>PROBLEM STATEMENT</strong></p><p>Given a string <code>word</code> and an abbreviation <code>abbr</code>, return <code>true</code> if <code>abbr</code> is a valid abbreviation for <code>word</code>, otherwise return <code>false</code>.</p><p>A valid abbreviation follows these rules:</p><ul><li>A number in <code>abbr</code> represents skipping that many characters in word.</li><li>Numbers cannot have leading zeros (e.g., &ldquo;01&rdquo; is invalid).</li><li>The skipped characters must match the length indicated by the number.</li></ul><p>Examples</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Input
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>word <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;internationalization&#34;</span>
</span></span><span style=display:flex><span>abbr <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;i12iz4n&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>true
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Input
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>word <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;apple&#34;</span>
</span></span><span style=display:flex><span>abbr <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;a2e&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>false
</span></span></code></pre></div><p>Approach: Two Pointers</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> validWordAbbreviation(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> word, <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> abbr) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Two pointer: one for word, one for abbr
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        size_t i{<span style=color:#ae81ff>0</span>}, j{<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> word.size() <span style=color:#f92672>&amp;&amp;</span> j <span style=color:#f92672>&lt;</span> abbr.size()) {            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// match digit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> ch_a <span style=color:#f92672>=</span> abbr[j]; std<span style=color:#f92672>::</span>isdigit(ch_a)) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// No leading &#39;0&#39; 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> (ch_a <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;0&#39;</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// read number
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>auto</span> num{<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (j <span style=color:#f92672>&lt;</span> m <span style=color:#f92672>&amp;&amp;</span> std<span style=color:#f92672>::</span>isdigit(abbr[j])) {
</span></span><span style=display:flex><span>                    num <span style=color:#f92672>=</span> num <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span> <span style=color:#f92672>+</span> (abbr[j] <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;0&#39;</span>);
</span></span><span style=display:flex><span>                    j<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// move forward
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                i <span style=color:#f92672>+=</span> num;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> { <span style=color:#75715e>// match word
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// Mismatch
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> (ch_a <span style=color:#f92672>!=</span> word[i]) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                j<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Fully processed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> i <span style=color:#f92672>==</span> word.size() <span style=color:#f92672>&amp;&amp;</span> j <span style=color:#f92672>==</span> abbr.size();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Time: O(Word length + abbr length), Space: O(1)</p><h3 id=680-valid-palindrome-ii><a href=https://leetcode.com/problems/valid-palindrome-ii/>680. Valid Palindrome II</a></h3><p>Two pointers with (one) Skip</p><ul><li>Lambda: Check Palindrome between range</li><li>Use <code>left</code> and <code>right</code> pointer to compare characters</li><li>If mismatch, try skip one step right/left</li><li>Check if the remaining substring is valid palindrome.</li></ul><p>Time: O(N), Space: O(1)</p><h3 id=314-binary-tree-vertical-order-traversal--987-vertical-order-traversal-of-a-binary-tree>314. Binary Tree Vertical Order Traversal / <a href=https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/>987. Vertical Order Traversal of a Binary Tree</a></h3><p>314 BFS with column tracking</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Definition for a binary tree node.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// struct TreeNode {
</span></span></span><span style=display:flex><span><span style=color:#75715e>//     int val;
</span></span></span><span style=display:flex><span><span style=color:#75715e>//     TreeNode *left;
</span></span></span><span style=display:flex><span><span style=color:#75715e>//     TreeNode *right;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>//     TreeNode(int val = 0): TreeNode(val, nullptr, nullptr) {}
</span></span></span><span style=display:flex><span><span style=color:#75715e>//     TreeNode(int x, TreeNode *left, TreeNode *right): val(x), left(left), right(right) {}
</span></span></span><span style=display:flex><span><span style=color:#75715e>// };
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> verticalTraversal(TreeNode<span style=color:#f92672>*</span> root) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> {};
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// We need a ordered map. Column -&gt; Nodes&#39; value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> col_nodes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Node -&gt; Column
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>queue<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>pair<span style=color:#f92672>&lt;</span>TreeNode<span style=color:#f92672>*</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> q;
</span></span><span style=display:flex><span>        q.push({root, <span style=color:#ae81ff>0</span>});
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// BFS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>q.empty()) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Copy on purpose
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>auto</span> [node, column] <span style=color:#f92672>=</span> q.front();
</span></span><span style=display:flex><span>            q.pop();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            col_nodes[column].push_back(node<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>auto</span> left <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>left) {
</span></span><span style=display:flex><span>                q.push({left, column <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>});
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>auto</span> right <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>right) {
</span></span><span style=display:flex><span>                q.push({right, column <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>});
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> res;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> [_, nodes]<span style=color:#f92672>:</span> col_nodes) {
</span></span><span style=display:flex><span>            res.push_back(nodes);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>987 DFS with sorting</p><ul><li>Transverse nodes to collect (col, row)</li><li>Sort the nodes by Column(left->right) -> Row(top->bottom) -> Value(ascending)</li><li>Group the values by <strong>column</strong></li></ul><h3 id=215-kth-largest-element-in-an-array><a href=https://leetcode.com/problems/kth-largest-element-in-an-array/des>215. Kth Largest Element in an Array</a></h3><p><strong>FOCUS</strong></p><p>QuickSelect. For general condition</p><p>Min-Heap. For large K</p><h3 id=227-basic-calculator-ii><a href=https://leetcode.com/problems/basic-calculator-ii/>227. Basic Calculator II</a></h3><ul><li>Use stack to handle mulitplication/division operators</li><li>Iterate through the string, build up number or sum up</li></ul><h3 id=1650-lowest-common-ancestor-of-a-binary-tree-iii>1650. Lowest Common Ancestor of a Binary Tree III</h3><p><strong>PROBLEM STATEMENT</strong></p><p>Given two nodes in a binary tree where each node contains a parent pointer, find their lowest common ancestor (LCA).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> lowestCommonAncestor(Node<span style=color:#f92672>*</span> p, Node<span style=color:#f92672>*</span> q) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Two pointers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>auto</span> p1{p};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> p2{q};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (p1 <span style=color:#f92672>!=</span> p2) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 1. Move pointer upward to parent
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 2. If pointer reaches nullptr, restart at the other&#39;s position
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            p1 <span style=color:#f92672>=</span> p1 <span style=color:#f92672>?</span> p1<span style=color:#f92672>-&gt;</span>parent : q;
</span></span><span style=display:flex><span>            p2 <span style=color:#f92672>=</span> p2 <span style=color:#f92672>?</span> p2<span style=color:#f92672>-&gt;</span>parent : p;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> p1;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=528-random-pick-with-weight><a href=https://leetcode.com/problems/random-pick-with-weight/>528. Random Pick with Weight</a></h3><ul><li>Build a prefix sum array (and total sum) from the input array</li><li>Pick random value x between [1, total]</li><li>Use binary search to find the lowerbound where prefixSum[i] >= x</li></ul><h3 id=162-find-peak-element><a href=https://leetcode.com/problems/find-peak-element/>162. Find Peak Element</a></h3><ul><li>Binary search</li></ul><h3 id=236-lowest-common-ancestor-of-a-binary-tree><a href=https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/>236. Lowest Common Ancestor of a Binary Tree</a></h3><ul><li>DFS on left and right</li><li>Difference with LCA III is no parent node given in the Node</li></ul><h3 id=50-powx-n><a href=https://leetcode.com/problems/powx-n/>50. Pow(x, n)</a></h3><ul><li>Divide and Conquer</li><li>Corner case n == 0, return 1</li><li>Use recursive/iteration. if n is even, $x^n = (x^2)^{n / 2}$, if n is odd, $x^n = x * x^{n-1}$</li></ul><h3 id=71-simplify-path><a href=https://leetcode.com/problems/simplify-path/>71. Simplify Path</a></h3><ul><li>Split the input path with &lsquo;/&rsquo;.</li><li>Process each part<ul><li>&ldquo;..&rdquo; -> move up one</li><li>&ldquo;.&rdquo; and "" -> ignore</li><li>Other are valid name</li></ul></li><li>Build output string. Always startsWith &lsquo;/&rsquo;, try not to use condition in the loop</li></ul><h3 id=1091-shortest-path-in-binary-matrix><a href=https://leetcode.com/problems/shortest-path-in-binary-matrix/>1091. Shortest Path in Binary Matrix</a></h3><ul><li>Since we want a shortest path, use BFS</li><li>Explore 8 directions</li><li>Track visited nodes to avoid cycles</li></ul><h3 id=1570-dot-product-of-two-sparse-vectors>1570. Dot Product of Two Sparse Vectors</h3><p><strong>PROBLEM STATEMENT</strong></p><p>Given two sparse vectors, implement their dot product efficiently.</p><p>A sparse vector contains mostly 0s, so storing and computing all elements naively is inefficient.</p><p>Implement a class <code>SparseVector</code> with:</p><ul><li>Constructor: <code>SparseVector(vector&lt;int>& nums)</code></li><li>Dot product function: <code>int dotProduct(SparseVector& vec)</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Store Non-Zero element
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SparseVector</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// {index: value}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>pair<span style=color:#f92672>&lt;</span>size_t, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> nonzeros;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> <span style=color:#a6e22e>SparseVector</span>(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (size_t i{<span style=color:#ae81ff>0</span>}; i <span style=color:#f92672>&lt;</span> nums.size(); <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> num <span style=color:#f92672>=</span> nums[i]; num <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                nonzeros.push_back({i, num});
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dotProduct</span>(<span style=color:#66d9ef>const</span> SparseVector<span style=color:#f92672>&amp;</span> o) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> res{<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>        size_t i{<span style=color:#ae81ff>0</span>}, j{<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> nonzeros.size() <span style=color:#f92672>&amp;&amp;</span> j <span style=color:#f92672>&lt;</span> o.nonzeros.size()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>auto</span> i1 <span style=color:#f92672>=</span> nonzeros[i].first, i2 <span style=color:#f92672>=</span> nonzeros[j].first; i1 <span style=color:#f92672>==</span> i2) {
</span></span><span style=display:flex><span>                res <span style=color:#f92672>+=</span> nonzeros[i].second <span style=color:#f92672>*</span> nonzeros[j].second;
</span></span><span style=display:flex><span>                i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                j<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (i1 <span style=color:#f92672>&lt;</span> i2) {
</span></span><span style=display:flex><span>                i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                j<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Time: O(N), Space: O(K), where K is non zero element count.</p><h3 id=938-range-sum-of-bst><a href=https://leetcode.com/problems/range-sum-of-bst/>938. Range Sum of BST</a></h3><ul><li>Recursive DFS. If current val smaller than low, search right, if current val larger than high, search left</li></ul><h3 id=125-valid-palindrome><a href=https://leetcode.com/problems/valid-palindrome/>125. Valid Palindrome</a></h3><ul><li>Two points start from the beginning and end</li><li>ignore the non-alnum characters</li><li>to lowercase and compare</li></ul><h3 id=560-subarray-sum-equals-k><a href=https://leetcode.com/problems/subarray-sum-equals-k/>560. Subarray Sum Equals K</a></h3><p><strong>QUESTIONS</strong></p><ul><li>Prefix sum, because of subarray sum</li><li>if $sum[j] - sum[i] = k$, then subarray nums[i+1: j] sums to k</li></ul><h3 id=543-diameter-of-binary-tree><a href=https://leetcode.com/problems/diameter-of-binary-tree/>543. Diameter of Binary Tree</a></h3><ul><li>Diameter is the maximum of 1. left node, 2. right node, 3. the longest path goes through the node</li><li>Because we need to know to height, so use DFS</li></ul><h3 id=199-binary-tree-right-side-view><a href=https://leetcode.com/problems/binary-tree-right-side-view>199. Binary Tree Right Side View</a></h3><ul><li>Because we need to iterate the tree by layer, so BFS</li><li>The last node is the right most node in current layer</li><li>Optional: DFS. Add the right node first, so when list size is same as the depth, that&rsquo;s the right most node</li></ul><h3 id=56-merge-intervals><a href=https://leetcode.com/problems/merge-intervals/>56. Merge Intervals</a></h3><ul><li>sort the input intervals by the mins</li><li>iterate the sorted intervals and merge based on overlapping</li></ul><h3 id=146-lru-cache><a href=https://leetcode.com/problems/lru-cache>146. LRU Cache</a></h3><h3 id=347-top-k-frequent-elements><a href=https://leetcode.com/problems/top-k-frequent-elements>347. Top K Frequent Elements</a></h3><ul><li>Use hashtable to store the frequency</li><li>Use priority heap to track top k elements</li></ul><h3 id=973-k-closest-points-to-origin><a href=https://leetcode.com/problems/k-closest-points-to-origin/>973. K Closest Points to Origin</a></h3><ul><li>Use max heap to track top k closest distance</li></ul><h3 id=1762-buildings-with-an-ocean-view>1762. Buildings With an Ocean View</h3><p><strong>PROBLEM STATEMENT</strong></p><p>There are <code>n</code> buildings in a row, indexed from <code>0</code> to <code>n-1</code>. Each building has a height represented by <code>heights[i]</code>.</p><p>A building has an ocean view if all buildings to its right have a smaller height.</p><p>Return a list of indices of buildings that have an ocean view in increasing order.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> findBuildings(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> heights) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Track the highest building seen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>auto</span> maxHeight{<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Start from the right most building (gurantee ocean view)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> heights.size() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> height <span style=color:#f92672>=</span> heights[i]; height <span style=color:#f92672>&gt;</span> maxHeight) {
</span></span><span style=display:flex><span>                res.push_back(i);
</span></span><span style=display:flex><span>                maxHeight <span style=color:#f92672>=</span> height;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>reverse(res.begin(), res.end());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=986-interval-list-intersections><a href=https://leetcode.com/problems/interval-list-intersections/>986. Interval List Intersections</a></h3><ul><li>Two pointers, start from the begining</li><li>An intersection exists if $max(start_1, start_2) \leq min(end_1, end_2)$</li><li>Move the pointer from the list from the interval ends first.</li></ul><h3 id=138-copy-list-with-random-pointer><a href=https://leetcode.com/problems/copy-list-with-random-pointer/>138. Copy List with Random Pointer</a></h3><p><strong>WARNING</strong></p><ul><li>Copy each node right after the original node (don&rsquo;t care random pointer)</li><li>Assign random pointer in the copied nodes</li><li>Separate the copied nodes and original nodes, and recover the original nodes relationship.</li></ul><h3 id=23-merge-k-sorted-lists><a href=https://leetcode.com/problems/merge-k-sorted-lists/>23. Merge k Sorted Lists</a></h3><ul><li>Use min heap, as the min always on the top</li><li>Extra the smallest element from the heap and move to form a pointer.</li></ul><h3 id=339-nested-list-weight-sum>339. Nested List Weight Sum</h3><p><strong>Problem Statement</strong></p><p>You are given a nested list of integers. Each element is either:</p><ul><li>An integer, or</li><li>A list containing other integers and/or nested lists.</li></ul><p>The depth of an integer is the number of lists it is inside.</p><p>Return the sum of all integers, weighted by their depth.</p><p>Example 1</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Input
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>nestedList <span style=color:#f92672>=</span> <span style=color:#a6e22e>[[1, 1], 2, [1, 1]]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Explanation
</span></span></span><span style=display:flex><span><span style=color:#75715e>// The &#39;1&#39;s are at depth 2, contributing 4*2=8
</span></span></span><span style=display:flex><span><span style=color:#75715e>// The &#39;2&#39; is at depth 1, contributing 2*1=2
</span></span></span></code></pre></div><p>Approach: DFS</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// LeetCode provided interface
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NestedInteger</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> isInteger() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getInteger</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>NestedInteger<span style=color:#f92672>&gt;&amp;</span> getList() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> depthSum(std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>NestedInteger<span style=color:#f92672>&gt;&amp;</span> nestedList, <span style=color:#66d9ef>int</span> depth <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> sum{<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> nested: nestedList) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (nested.isInteger()) {
</span></span><span style=display:flex><span>                sum <span style=color:#f92672>+=</span> nested.getInteger() <span style=color:#f92672>*</span> depth;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                sum <span style=color:#f92672>+=</span> depthSum(nested.getList(), depth <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> sum;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Time: O(N), Space: O(Depth)</p><h3 id=129-sum-root-to-leaf-numbers><a href=https://leetcode.com/problems/sum-root-to-leaf-numbers/>129. Sum Root to Leaf Numbers</a></h3><ul><li>Because we need to reach the leaf to build up a number, so DFS</li><li>Keep track of the sum</li><li>return sum when reach a leaf</li></ul><h3 id=346-moving-average-from-data-stream>346. Moving Average from Data Stream</h3><p><strong>PROBLEM STATEMENT</strong></p><p>You need to implement a class <code>MovingAverage</code> that calculates the moving average of the last <code>size</code> elements in a data stream.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;queue&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MovingAverage</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> MovingAverage(<span style=color:#66d9ef>int</span> size)<span style=color:#f92672>:</span> _size(size), _sum(<span style=color:#ae81ff>0.</span>) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>next</span>(<span style=color:#66d9ef>int</span> val) {
</span></span><span style=display:flex><span>        q.push(val);
</span></span><span style=display:flex><span>        sum <span style=color:#f92672>+=</span> val;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (q.size() <span style=color:#f92672>&gt;</span> _size) {
</span></span><span style=display:flex><span>            sum <span style=color:#f92672>-=</span> q.front();
</span></span><span style=display:flex><span>            q.pop();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> sum <span style=color:#f92672>/</span> q.front();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> _q;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> _sum;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> _size;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=282-expression-add-operators><a href=https://leetcode.com/problems/expression-add-operators/>282. Expression Add Operators</a></h3><p><strong>HARD!!!</strong></p><h3 id=670-maximum-swap><a href=https://leetcode.com/problems/maximum-swap/>670. Maximum Swap</a></h3><ul><li>convert the number to string</li><li>Track last occurance of each digit from left to right. Help better locate the larger digit to swap</li><li>Find the best swap</li></ul><h3 id=791-custom-sort-string><a href=https://leetcode.com/problems/custom-sort-string/>791. Custom Sort String</a></h3><ul><li><code>order</code> has less character, and it defines the order, so build final string from <code>order</code> based on <code>s</code> frequency</li><li>Use frequency map to count occurance in <code>s</code></li><li>Build result by iterating through <code>order</code></li><li>Append the remaining letters at the end</li></ul><h3 id=32-next-permutation><a href=https://leetcode.com/problems/next-permutation/>32. Next Permutation</a></h3><p><strong>DRAW EXAMPLE</strong></p><p>e.g. 24,857,631 -> 24,867,531 -> 24,861,357</p><ul><li>Traverse from right to left to find the pivot where $nums[i] &lt; nums[i-1]$</li><li>Traverse again from right to left to find the <strong>smallest digit</strong> larger than current <code>nums[i]</code>, then swap. This digit could be the new start</li><li>Reverse the sequence from <code>i+1</code> to the end</li></ul><h3 id=76-minimum-window-substring><a href=https://leetcode.com/problems/minimum-window-substring/>76. Minimum Window Substring</a></h3><h3 id=meeting-rooms>Meeting Rooms</h3><p><strong>I. PROBLEM STATEMENT</strong></p><p>Given an array of meeting time intervals <code>intervals</code> where <code>intervals[i] = [start_i, end_i]</code>, determine if a person can attend all meetings (i.e., no overlapping meetings).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> canAttendMeetings(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> intervals) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Sort based on the starting time
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>sort(intervals.begin(), intervals.end());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Iterate if any start smaller than previous end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (size_t i{<span style=color:#ae81ff>1</span>}};i <span style=color:#f92672>&lt;</span> intervals.size(); <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (intervals[i][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;</span> intervals[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>]) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>II. PROBLEM STATEMENT</strong></p><p>Given an array of meeting time intervals <code>intervals</code> where <code>intervals[i] = [start_i, end_i]</code>, return the minimum number of conference rooms required.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> minMeetingRooms(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> intervals) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (intervals.empty()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Sort based on starting point
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>sort(intervals.begin(), intervals.end());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Use min heap to track the ending, as well as the ongoing meetings
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>priority_queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>, std<span style=color:#f92672>::</span>greater<span style=color:#f92672>&gt;</span> minHeap;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        minHeap.push(intervals[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (size_t i{<span style=color:#ae81ff>1</span>}; i <span style=color:#f92672>&lt;</span> intervals.size(); <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If current start time larger than earlier ending time
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (intervals[i][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&gt;=</span> minHeap.top()) {
</span></span><span style=display:flex><span>                minHeap.pop();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            minHeap.push(intervals[i][<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> minHeap.size();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>III. PROBLEM STATEMENT</strong></p><p>You are given <code>n</code> meeting rooms and an array <code>meetings</code>, where <code>meetings[i] = [start_i, end_i]</code>. Each meeting must be assigned to a room that is free at that time. If multiple rooms are available, assign the <strong>lowest-indexed</strong> room. If no room is free, the meeting is delayed until the earliest available time.</p><p>Return the index of the meeting room that hosted the most meetings. If multiple rooms have the same count, return the smallest index.</p><h3 id=75-sort-colors><a href=https://leetcode.com/problems/sort-colors/>75. Sort Colors</a></h3><ul><li>We need to partition the array into 3 parts</li><li>Because in-place sort, so we need to swap</li><li>Use two pointers<ul><li><code>low</code> tracks 0s, <code>mid</code> tracks 1s, <code>high</code> tracks 2s</li><li><code>mid</code> traverse</li><li>check <code>nums[mid]</code></li></ul></li><li>Terminate when <code>mid</code> surpasses <code>high</code></li></ul><h3 id=825-friends-of-appropriate-ages><a href=https://leetcode.com/problems/friends-of-appropriate-ages/>825. Friends Of Appropriate Ages</a></h3><ul><li>Read the condition, and narrow down the real condition<ul><li>Condition 1 defines the min age</li><li>Condition 2 defines the max age</li><li>Special case is when max and min equal, $age = age * 0.5 + 7$, so min valid age is 14 + 1</li><li>age is between 1&mldr;120</li><li>Use age range to try Condition 3, find out it&rsquo;s useless</li><li>For each age, we need to find the people count in valid range</li><li>Use count and prefix sum on ages</li></ul></li></ul><h3 id=51-n-queens><a href=https://leetcode.com/problems/n-queens/>51. N-Queens</a></h3><p><strong>HARD</strong></p><h3 id=79-word-search><a href=https://leetcode.com/problems/word-search/>79. Word Search</a></h3><ul><li>Because we need to search to the end of the word to find a word, so use DFS</li><li>Iterate through <code>board</code>, search from the first letter</li><li>Use DFS to explore four directions</li><li>Mark visited cell before DFS (temporarily)</li><li>If index is equal to word len (iterate all characters)</li></ul><h3 id=283-move-zeroes><a href=https://leetcode.com/problems/move-zeroes/>283. Move Zeroes</a></h3><ul><li>Move in place, so we need to use two pointers, and swap</li><li><code>slow</code> tracks where the next non zero pointer should go</li><li><code>fast</code> find the non-zero elements</li><li>If found, swap</li></ul><h3 id=two-sums>Two Sums</h3><p><strong><a href>I. Two Sums</a></strong></p><ul><li>Iterate the numbers</li><li>Use hashtable to store the visited value and its index</li><li>Find if <code>target - nums[i]</code> exists in hashtable</li></ul><p><strong><a href=https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/>II. Two Sums</a></strong></p><ul><li>The difference with previous question is input array is sorted</li><li>Use two pointers, starts from the beginning and end</li><li>If sum is less than <code>target</code>, move left; greater than <code>target</code> move right, or return index pair</li></ul><p><strong><a href=https://leetcode.com/problems/3sum/description/>III. 3Sums</a></strong></p><ul><li>Sort the values</li></ul><hr><h2 id=leetcode-roadmap>LeetCode Roadmap</h2><h3 id=learn-by-roi>Learn by ROI</h3><table><thead><tr><th style=text-align:center>Topic</th><th style=text-align:center>Difficulty</th><th style=text-align:center>ROI</th></tr></thead><tbody><tr><td style=text-align:center>Basic</td><td style=text-align:center>Easy</td><td style=text-align:center>Very High</td></tr><tr><td style=text-align:center>Two Pointers</td><td style=text-align:center>Easy</td><td style=text-align:center>High</td></tr><tr><td style=text-align:center>Sliding Window</td><td style=text-align:center>Easy</td><td style=text-align:center>High</td></tr><tr><td style=text-align:center>BFS</td><td style=text-align:center>Easy</td><td style=text-align:center>High</td></tr><tr><td style=text-align:center>DFS</td><td style=text-align:center>Medium</td><td style=text-align:center>High</td></tr><tr><td style=text-align:center>Backtracking</td><td style=text-align:center>High</td><td style=text-align:center>High</td></tr><tr><td style=text-align:center>Heap</td><td style=text-align:center>Medium</td><td style=text-align:center>Medium</td></tr><tr><td style=text-align:center>Binary Search</td><td style=text-align:center>Easy</td><td style=text-align:center>Medium</td></tr><tr><td style=text-align:center>Dynamic Programming</td><td style=text-align:center>High</td><td style=text-align:center>Medium</td></tr><tr><td style=text-align:center>Divide and Conquer</td><td style=text-align:center>Medium</td><td style=text-align:center>Low</td></tr><tr><td style=text-align:center>Trie</td><td style=text-align:center>Medium</td><td style=text-align:center>Low</td></tr><tr><td style=text-align:center>Union Find</td><td style=text-align:center>Medium</td><td style=text-align:center>Low</td></tr><tr><td style=text-align:center>Greedy</td><td style=text-align:center>Medium</td><td style=text-align:center>Low</td></tr></tbody></table><h3 id=arrays-and-hashing>Arrays and Hashing</h3><h3 id=binary-search>Binary Search</h3><h4 id=template>Template</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>checkFeasible</span>(<span style=color:#66d9ef>int</span> num) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>binarySearch</span>(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> vec, <span style=color:#66d9ef>int</span> target) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> left{<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> right <span style=color:#f92672>=</span> vec.size() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// size_t
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>auto</span> index{<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (left <span style=color:#f92672>&lt;=</span> right) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> mid <span style=color:#f92672>=</span> left <span style=color:#f92672>+</span> (left <span style=color:#f92672>+</span> right) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (checkFeasible(mid)) {
</span></span><span style=display:flex><span>            index <span style=color:#f92672>=</span> mid;
</span></span><span style=display:flex><span>            right <span style=color:#f92672>=</span> mid <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            left <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> index;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></article></div></div><div class="col-sm-12 col-md-12 col-lg-3"><div id=stickySideBar class=sticky-sidebar><aside class=toc><h5>Table Of Contents</h5><div class=toc-content><nav id=TableOfContents><ul><li><a href=#top-150>Top 150</a><ul><li><a href=#array--string>Array & String</a></li><li><a href=#intervals>Intervals</a></li><li><a href=#stack>Stack</a></li><li><a href=#binary-tree-general>Binary Tree General</a></li><li><a href=#graph-general>Graph General</a></li><li><a href=#binary>Binary</a></li><li><a href=#1d-dp>1D DP</a></li></ul></li><li><a href=#meta-tagged-questions>Meta Tagged Questions</a><ul><li><a href=#1249-minimum-remove-to-make-valid-parentheses><a href=https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses>1249. Minimum Remove to Make Valid Parentheses</a></a></li><li><a href=#408-valid-word-abbreviation>408. Valid Word Abbreviation</a></li><li><a href=#680-valid-palindrome-ii><a href=https://leetcode.com/problems/valid-palindrome-ii/>680. Valid Palindrome II</a></a></li><li><a href=#314-binary-tree-vertical-order-traversal--987-vertical-order-traversal-of-a-binary-tree>314. Binary Tree Vertical Order Traversal / <a href=https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/>987. Vertical Order Traversal of a Binary Tree</a></a></li><li><a href=#215-kth-largest-element-in-an-array><a href=https://leetcode.com/problems/kth-largest-element-in-an-array/des>215. Kth Largest Element in an Array</a></a></li><li><a href=#227-basic-calculator-ii><a href=https://leetcode.com/problems/basic-calculator-ii/>227. Basic Calculator II</a></a></li><li><a href=#1650-lowest-common-ancestor-of-a-binary-tree-iii>1650. Lowest Common Ancestor of a Binary Tree III</a></li><li><a href=#528-random-pick-with-weight><a href=https://leetcode.com/problems/random-pick-with-weight/>528. Random Pick with Weight</a></a></li><li><a href=#162-find-peak-element><a href=https://leetcode.com/problems/find-peak-element/>162. Find Peak Element</a></a></li><li><a href=#236-lowest-common-ancestor-of-a-binary-tree><a href=https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/>236. Lowest Common Ancestor of a Binary Tree</a></a></li><li><a href=#50-powx-n><a href=https://leetcode.com/problems/powx-n/>50. Pow(x, n)</a></a></li><li><a href=#71-simplify-path><a href=https://leetcode.com/problems/simplify-path/>71. Simplify Path</a></a></li><li><a href=#1091-shortest-path-in-binary-matrix><a href=https://leetcode.com/problems/shortest-path-in-binary-matrix/>1091. Shortest Path in Binary Matrix</a></a></li><li><a href=#1570-dot-product-of-two-sparse-vectors>1570. Dot Product of Two Sparse Vectors</a></li><li><a href=#938-range-sum-of-bst><a href=https://leetcode.com/problems/range-sum-of-bst/>938. Range Sum of BST</a></a></li><li><a href=#125-valid-palindrome><a href=https://leetcode.com/problems/valid-palindrome/>125. Valid Palindrome</a></a></li><li><a href=#560-subarray-sum-equals-k><a href=https://leetcode.com/problems/subarray-sum-equals-k/>560. Subarray Sum Equals K</a></a></li><li><a href=#543-diameter-of-binary-tree><a href=https://leetcode.com/problems/diameter-of-binary-tree/>543. Diameter of Binary Tree</a></a></li><li><a href=#199-binary-tree-right-side-view><a href=https://leetcode.com/problems/binary-tree-right-side-view>199. Binary Tree Right Side View</a></a></li><li><a href=#56-merge-intervals><a href=https://leetcode.com/problems/merge-intervals/>56. Merge Intervals</a></a></li><li><a href=#146-lru-cache><a href=https://leetcode.com/problems/lru-cache>146. LRU Cache</a></a></li><li><a href=#347-top-k-frequent-elements><a href=https://leetcode.com/problems/top-k-frequent-elements>347. Top K Frequent Elements</a></a></li><li><a href=#973-k-closest-points-to-origin><a href=https://leetcode.com/problems/k-closest-points-to-origin/>973. K Closest Points to Origin</a></a></li><li><a href=#1762-buildings-with-an-ocean-view>1762. Buildings With an Ocean View</a></li><li><a href=#986-interval-list-intersections><a href=https://leetcode.com/problems/interval-list-intersections/>986. Interval List Intersections</a></a></li><li><a href=#138-copy-list-with-random-pointer><a href=https://leetcode.com/problems/copy-list-with-random-pointer/>138. Copy List with Random Pointer</a></a></li><li><a href=#23-merge-k-sorted-lists><a href=https://leetcode.com/problems/merge-k-sorted-lists/>23. Merge k Sorted Lists</a></a></li><li><a href=#339-nested-list-weight-sum>339. Nested List Weight Sum</a></li><li><a href=#129-sum-root-to-leaf-numbers><a href=https://leetcode.com/problems/sum-root-to-leaf-numbers/>129. Sum Root to Leaf Numbers</a></a></li><li><a href=#346-moving-average-from-data-stream>346. Moving Average from Data Stream</a></li><li><a href=#282-expression-add-operators><a href=https://leetcode.com/problems/expression-add-operators/>282. Expression Add Operators</a></a></li><li><a href=#670-maximum-swap><a href=https://leetcode.com/problems/maximum-swap/>670. Maximum Swap</a></a></li><li><a href=#791-custom-sort-string><a href=https://leetcode.com/problems/custom-sort-string/>791. Custom Sort String</a></a></li><li><a href=#32-next-permutation><a href=https://leetcode.com/problems/next-permutation/>32. Next Permutation</a></a></li><li><a href=#76-minimum-window-substring><a href=https://leetcode.com/problems/minimum-window-substring/>76. Minimum Window Substring</a></a></li><li><a href=#meeting-rooms>Meeting Rooms</a></li><li><a href=#75-sort-colors><a href=https://leetcode.com/problems/sort-colors/>75. Sort Colors</a></a></li><li><a href=#825-friends-of-appropriate-ages><a href=https://leetcode.com/problems/friends-of-appropriate-ages/>825. Friends Of Appropriate Ages</a></a></li><li><a href=#51-n-queens><a href=https://leetcode.com/problems/n-queens/>51. N-Queens</a></a></li><li><a href=#79-word-search><a href=https://leetcode.com/problems/word-search/>79. Word Search</a></a></li><li><a href=#283-move-zeroes><a href=https://leetcode.com/problems/move-zeroes/>283. Move Zeroes</a></a></li><li><a href=#two-sums>Two Sums</a></li></ul></li><li><a href=#leetcode-roadmap>LeetCode Roadmap</a><ul><li><a href=#learn-by-roi>Learn by ROI</a></li><li><a href=#arrays-and-hashing>Arrays and Hashing</a></li><li><a href=#binary-search>Binary Search</a></li></ul></li></ul></nav></div></aside><aside class=social><h5>Social</h5><div class=social-content><ul class=list-inline><li class="list-inline-item text-center"><a target=_blank href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fbobblelaw.github.io%2ftopics%2finterview%2fleetcode-top-interview%2f"><i class="fab fa-linkedin"></i></a></li><li class="list-inline-item text-center"><a target=_blank href="https://twitter.com/share?text=&url=https%3a%2f%2fbobblelaw.github.io%2ftopics%2finterview%2fleetcode-top-interview%2f"><i class="fab fa-twitter"></i></a></li><li class="list-inline-item text-center"><a target=_blank href="https://api.whatsapp.com/send?text=: https%3a%2f%2fbobblelaw.github.io%2ftopics%2finterview%2fleetcode-top-interview%2f"><i class="fab fa-whatsapp"></i></a></li><li class="list-inline-item text-center"><a target=_blank href='mailto:?subject=&amp;body=Check%20out%20this%20site https%3a%2f%2fbobblelaw.github.io%2ftopics%2finterview%2fleetcode-top-interview%2f'><i class="fa fa-envelope"></i></a></li></ul></div></aside></div></div></div><div class=row><div class="col-sm-12 col-md-12 col-lg-9 p-4"></div></div></div><button class="p-2 px-3" onclick=topFunction() id=topScroll>
<i class="fas fa-angle-up"></i></button></section><div class=progress><div id=scroll-progress-bar class=progress-bar role=progressbar aria-valuenow=0 aria-valuemin=0 aria-valuemax=100></div></div><script src=/js/scrollProgressBar.js></script><script>var topScroll=document.getElementById("topScroll");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?topScroll.style.display="block":topScroll.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}let stickySideBarElem=document.getElementById("stickySideBar"),stickyNavBar=!0;if(stickyNavBar){let e=document.getElementById("profileHeader"),t=e.offsetHeight+15;stickySideBarElem.style.top=t+"px"}else stickySideBarElem.style.top="50px"</script><script src=/js/readingTime.js></script></div><footer><div class="text-center pt-2"><span class=px-1><a href=https://github.com/BobbleLaw aria-label=github><svg width="2.7em" height="2.7em" viewBox="0 0 1792 1792"><path id="footer-socialNetworks-github-svg-path" d="M522 1352q-8 9-20-3-13-11-4-19 8-9 20 3 12 11 4 19zm-42-61q9 12 0 19-8 6-17-7t0-18q9-7 17 6zm-61-60q-5 7-13 2-10-5-7-12 3-5 13-2 10 5 7 12zm31 34q-6 7-16-3-9-11-2-16 6-6 16 3 9 11 2 16zm129 112q-4 12-19 6-17-4-13-15t19-7q16 5 13 16zm63 5q0 11-16 11-17 2-17-11 0-11 16-11 17-2 17 11zm58-10q2 10-14 14t-18-8 14-15q16-2 18 9zm964-956v960q0 119-84.5 203.5T1376 1664h-224q-16 0-24.5-1t-19.5-5-16-14.5-5-27.5v-239q0-97-52-142 57-6 102.5-18t94-39 81-66.5 53-105T1386 856q0-121-79-206 37-91-8-204-28-9-81 11t-92 44l-38 24q-93-26-192-26t-192 26q-16-11-42.5-27T578 459.5 492 446q-44 113-7 204-79 85-79 206 0 85 20.5 150t52.5 105 80.5 67 94 39 102.5 18q-40 36-49 103-21 10-45 15t-57 5-65.5-21.5T484 1274q-19-32-48.5-52t-49.5-24l-20-3q-21 0-29 4.5t-5 11.5 9 14 13 12l7 5q22 10 43.5 38t31.5 51l10 23q13 38 44 61.5t67 30 69.5 7 55.5-3.5l23-4q0 38 .5 103t.5 68q0 22-11 33.5t-22 13-33 1.5H416q-119 0-203.5-84.5T128 1376V416q0-119 84.5-203.5T416 128h960q119 0 203.5 84.5T1664 416z"/></svg>
</a></span><span class=px-1><a href=https://www.linkedin.com/in/boblzy aria-label=linkedin><svg width="2.4em" height="2.4em" fill="#fff" aria-label="LinkedIn" viewBox="0 0 512 512"><rect width="512" height="512" fill="#0077b5" rx="15%"/><circle cx="142" cy="138" r="37"/><path stroke="#fff" stroke-width="66" d="M244 194v198M142 194v198"/><path d="M276 282c0-20 13-40 36-40 24 0 33 18 33 45v105h66V279c0-61-32-89-76-89-34 0-51 19-59 32"/></svg></a></span></div><div class="container py-4"><div class="row justify-content-center"><div class="col-md-4 text-center"><div class=pb-2><a href=https://bobblelaw.github.io/ title="Bobble Law"><img alt="Footer logo" src=/logo.png height=40px width=40px></a></div>&copy; 2025 All rights reserved<div class=text-secondary>Made with
<span class=text-danger>&#10084;
</span>and
<a href=https://github.com/gurusabarish/hugo-profile target=_blank title="Designed and developed by gurusabarish">Hugo Profile</a></div></div></div></div></footer><script src=/bootstrap-5/js/bootstrap.bundle.min.js></script><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))});var tooltipTriggerList=[].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]')),tooltipList=tooltipTriggerList.map(function(e){return new bootstrap.Tooltip(e)})</script><script src=/js/search.js></script><section id=search-content class=py-2><div class=container id=search-results></div></section></body></html>