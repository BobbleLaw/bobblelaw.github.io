<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta http-equiv=Accept-CH content="DPR, Viewport-Width, Width"><link rel=icon href=/logo.png type=image/gif><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" media=print onload='this.media="all"'><noscript><link href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel=stylesheet></noscript><link rel=stylesheet href=/css/font.css media=all><script async src="https://www.googletagmanager.com/gtag/js?id=G-7GMTK23CS7"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7GMTK23CS7")}</script><meta property="og:url" content="https://bobblelaw.github.io/topics/interview/leetcode-top-interview/"><meta property="og:site_name" content="Bobble Law"><meta property="og:title" content="Bobble Law"><meta property="og:description" content="LeetCode Top Interview Questions Array & Hashing 88. Merge Sorted Array Keyword: Two-Pointer
Steps
Two pointers, all start from two end (m-1 and n-1) Iteration pointer starts from the very (m+n-1) end If nums[i1] > nums[i2], use nums[i1], move i1 Else, use nums[i2], move i2 Move i Copy the rest from nums Time: O(m+n), Space: O(1)
27. Remove Item Keyword: Two-Pointer
two pointers, one tracks valid number, one iterates."><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="article:section" content="topics"><meta name=twitter:card content="summary"><meta name=twitter:title content="Bobble Law"><meta name=twitter:description content="LeetCode Top Interview Questions Array & Hashing 88. Merge Sorted Array Keyword: Two-Pointer
Steps
Two pointers, all start from two end (m-1 and n-1) Iteration pointer starts from the very (m+n-1) end If nums[i1] > nums[i2], use nums[i1], move i1 Else, use nums[i2], move i2 Move i Copy the rest from nums Time: O(m+n), Space: O(1)
27. Remove Item Keyword: Two-Pointer
two pointers, one tracks valid number, one iterates."><script async src="https://www.googletagmanager.com/gtag/js?id=G-7GMTK23CS7"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7GMTK23CS7")</script><link rel=stylesheet href=/bootstrap-5/css/bootstrap.min.css media=all><link rel=stylesheet href=/css/header.css media=all><link rel=stylesheet href=/css/footer.css media=all><link rel=stylesheet href=/css/theme.css media=all><style>:root{--text-color:#343a40;--text-secondary-color:#6c757d;--text-link-color:#007bff;--background-color:#eaedf0;--secondary-background-color:#64ffda1a;--primary-color:#007bff;--secondary-color:#f8f9fa;--text-color-dark:#e4e6eb;--text-secondary-color-dark:#b0b3b8;--text-link-color-dark:#ffffff;--background-color-dark:#18191a;--secondary-background-color-dark:#212529;--primary-color-dark:#ffffff;--secondary-color-dark:#212529}body{font-size:1rem;font-weight:400;line-height:1.5;text-align:left}html{background-color:var(--background-color) !important}body::-webkit-scrollbar{height:0;width:8px;background-color:var(--background-color)}::-webkit-scrollbar-track{border-radius:1rem}::-webkit-scrollbar-thumb{border-radius:1rem;background:#b0b0b0;outline:1px solid var(--background-color)}#search-content::-webkit-scrollbar{width:.5em;height:.1em;background-color:var(--background-color)}</style><meta name=description content><link rel=stylesheet href=/css/single.css><script defer src=/fontawesome-6/all-6.4.2.js></script><title>| Bobble Law</title></head><body class=light><script>let localStorageValue=localStorage.getItem("pref-theme"),mediaQuery=window.matchMedia("(prefers-color-scheme: dark)").matches;switch(localStorageValue){case"dark":document.body.classList.add("dark");break;case"light":document.body.classList.remove("dark");break;default:mediaQuery&&document.body.classList.add("dark");break}</script><script>var prevScrollPos=window.pageYOffset;window.addEventListener("scroll",function(){let s=document.getElementById("profileHeader"),t=window.pageYOffset,n=!1,o=!0,i=o?prevScrollPos>t:t>0;i?s.classList.add("showHeaderOnTop"):n=!0,t===0&&(n=!0),n&&s.classList.remove("showHeaderOnTop"),prevScrollPos=t})</script><header id=profileHeader><nav class="pt-3 navbar navbar-expand-lg animate"><div class="container-fluid mx-xs-2 mx-sm-5 mx-md-5 mx-lg-5"><a class="navbar-brand primary-font text-wrap" href=/><img src=/logo.png width=30 height=30 class="d-inline-block align-top">
Bob Law</a><div><input id=search autocomplete=off class="form-control mr-sm-2 d-none d-md-block" placeholder=Search... aria-label=Search oninput=searchOnChange(event)></div><button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarContent aria-controls=navbarContent aria-expanded=false aria-label="Toggle navigation">
<svg aria-hidden="true" height="24" viewBox="0 0 16 16" width="24" data-view-component="true"><path fill-rule="evenodd" d="M1 2.75A.75.75.0 011.75 2h12.5a.75.75.0 110 1.5H1.75A.75.75.0 011 2.75zm0 5A.75.75.0 011.75 7h12.5a.75.75.0 110 1.5H1.75A.75.75.0 011 7.75zM1.75 12a.75.75.0 100 1.5h12.5a.75.75.0 100-1.5H1.75z"/></svg></button><div class="collapse navbar-collapse text-wrap primary-font" id=navbarContent><ul class="navbar-nav ms-auto text-center"><li class="nav-item navbar-text d-block d-md-none"><div class=nav-link><input id=search autocomplete=off class="form-control mr-sm-2" placeholder=Search... aria-label=Search oninput=searchOnChange(event)></div></li><li class="nav-item navbar-text"><a class=nav-link href=/#about aria-label=about>About</a></li><li class="nav-item navbar-text"><a class=nav-link href=/#experience aria-label=experience>Experience</a></li><li class="nav-item navbar-text"><a class=nav-link href=/#education aria-label=education>Education</a></li><li class="nav-item navbar-text"><a class=nav-link href=/posts title>Posts</a></li><li class="nav-item navbar-text"><a class=nav-link href=/tags title>Tags</a></li><li class="nav-item navbar-text"><a class=nav-link href=/topics title>Topics</a></li><li class="nav-item navbar-text"><div class=text-center><button id=theme-toggle>
<svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></li></ul></div></div></nav></header><div id=content><section id=single><div class=container><div class="row justify-content-center"><div class="col-sm-12 col-md-12 col-lg-9"><div class=pr-lg-4><div class="title mb-5"><h1 class="text-center mb-4"></h1><div class=text-center>Jan 1, 1010
<span id=readingTime>min read</span></div></div><article class="page-content p-2"><h1 id=leetcode-top-interview-questions>LeetCode Top Interview Questions</h1><p><img src="https://img.shields.io/badge/Meta-%230467DF.svg?style=for-the-badge&amp;logo=Meta&amp;logoColor=white" alt=Meta><br><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS><br><img src="https://img.shields.io/badge/google-4285F4?style=for-the-badge&amp;logo=google&amp;logoColor=white" alt=Google><br><img src="https://img.shields.io/badge/Apple-%23000000.svg?style=for-the-badge&amp;logo=apple&amp;logoColor=white" alt=Apple></p><h2 id=array--hashing>Array & Hashing</h2><h4 id=88-merge-sorted-array><a href=https://leetcode.com/problems/merge-sorted-array/>88. Merge Sorted Array</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Steps</strong></p><ul><li>Two pointers, all start from two end (<code>m-1</code> and <code>n-1</code>)</li><li>Iteration pointer starts from the very (<code>m+n-1</code>) end<ul><li>If <code>nums[i1] > nums[i2]</code>, use <code>nums[i1]</code>, move i1</li><li>Else, use <code>nums[i2]</code>, move i2</li><li>Move i</li></ul></li><li>Copy the rest from <code>nums</code></li></ul><p>Time: O(m+n), Space: O(1)</p><h4 id=27-remove-item><a href=https://leetcode.com/problems/remove-element/>27. Remove Item</a></h4><p><strong>Keyword</strong>: Two-Pointer</p><p>two pointers, one tracks valid number, one iterates.</p><h4 id=26-remove-duplicates-from-sorted-array><a href=https://leetcode.com/problems/remove-duplicates-from-sorted-array/>26. Remove Duplicates from Sorted Array</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Intuition</strong></p><ul><li>Slow pointer track the position of unique number, fast pointer to iterate array</li></ul><p><strong>Steps</strong></p><ul><li><code>slow</code> start at 0</li><li><code>fast</code> start at 1, iterate <code>fast</code></li><li>Whenever find a unique element, increase <code>slow</code>, update value at <code>slow</code> to value as fast</li></ul><h4 id=80-remove-duplicates-from-sorted-array-ii><a href=https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/>80. Remove Duplicates from Sorted Array II</a></h4><p>Similar to 26, the starting point and <code>if</code> condition are different. Generalize to max k duplicated.</p><ul><li>First k element always valid.</li></ul><h4 id=169-majority-element><a href=https://leetcode.com/problems/majority-element/>169. Majority Element</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Intuition</strong></p><ul><li>Because the majority element appears more than n / 2, so just sort and return the value at median</li></ul><p><strong>Steps</strong></p><ul><li>Sort</li><li>Return the value at median</li></ul><h4 id=189-rotate-array><a href=https://leetcode.com/problems/rotate-array/>189. Rotate Array</a></h4><ul><li>Rotate all -> rotate first k -> rotate remaining</li></ul><h4 id=121-best-time-to-buy-and-sell-stock><a href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock/>121. Best Time to Buy and Sell Stock</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Observations</strong></p><ul><li>Buy and sell should happen on different day</li><li>One operation</li></ul><p><strong>Intuition</strong></p><ul><li>Buy low, sell high</li></ul><p><strong>Steps</strong></p><ul><li>Track min price and max profit so far</li><li>Iterate prices<ul><li>Update min price</li><li>Update potential max profit</li></ul></li></ul><p>Time: O(N), Space: O(1)</p><h4 id=122-best-time-to-buy-and-sell-stock-ii><a href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/>122: Best Time to Buy and Sell Stock II</a></h4><p><strong>Observations</strong></p><ul><li>Buy and sell can happen in the same day</li><li>Hold at most one stock</li><li>Multiple operations</li></ul><p><strong>Intuition</strong></p><ul><li>Capture All Uptrends: buy at every valley, sell at every peak</li><li>Avoid Overlapping Trade<ul><li>Even it&rsquo;s possible stock increases for several day, but we should make use of the rule from the question</li></ul></li></ul><p><strong>Steps</strong></p><ul><li>Iterate prices<ul><li>Every increase is an oppotunity to make profit</li><li>Sum up all the increase</li></ul></li></ul><p>Time: O(N), Space: O(1)</p><h4 id=55-jump-game><a href=https://leetcode.com/problems/jump-game/>55. Jump Game</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Greedy</p><p><strong>Intuition</strong></p><ul><li>Always try to find out the max jump position from current position</li></ul><p><strong>Steps</strong></p><ul><li>Track the max reachable index</li><li>Iterate the jumps<ul><li>If current index > max reachable index, return false</li><li>Update max reachable index from current index</li><li>If new max reachable index is over the total, return true</li></ul></li><li>Default return true</li></ul><h4 id=45-jump-game-ii><a href=https://leetcode.com/problems/jump-game-ii/>45. Jump Game II</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Greedy</p><p><strong>Intuition</strong></p><ul><li>The difference between this question and <a href=/topics/interview/leetcode-top-interview/#55-jump-game>Jump Game</a> is<ul><li><strong>Return the minimum jump</strong></li><li>Destination is <code>nums[n - 1]</code></li></ul></li><li><strong>Greedy</strong>: At each level, try to extend the jump range as far as possible</li></ul><p><strong>Steps</strong></p><ul><li>Declare the farthest index we can reach by <code>farthest</code></li><li>Declare the current range of jump by <code>currentRange</code></li><li>Declare jump count</li><li>Iterate <code>[0... n-1)</code><ul><li>Update <code>farthest</code></li><li>If we reach <code>currentRange</code>, we must jump<ul><li>Increase the <code>jump</code> counter</li><li>Update <code>currentRange</code></li></ul></li></ul></li></ul><h4 id=11-container-with-most-water><a href=https://leetcode.com/problems/container-with-most-water/>11. Container with Most Water</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Intuition</strong></p><ul><li><code>area = std::min(heights[left] + height[right]) * (heights[right] - height[left])</code></li><li>Move the lower height to maximize the area</li></ul><p><strong>Steps</strong></p><ul><li><code>left</code>: 0, <code>right</code>: n - 1</li><li>Declare <code>maxArea</code></li><li>While <code>left</code> and <code>right</code> not cross<ul><li>Calculate and update <code>maxArea</code></li><li>Move the smaller side to update bound</li></ul></li></ul><p>Time: O(N), Space: O(1)</p><h4 id=42-trapping-rain-water><a href=https://leetcode.com/problems/trapping-rain-water/>42. Trapping Rain Water</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>HARD!!!</strong></p><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Observations</strong></p><ul><li>Water volumn can be trapped depends on the lower side</li><li>Water that can be trapping at index i is <code>std::min(leftMax, rightMax) - h[i]</code></li></ul><p><strong>Steps</strong></p><ul><li>Two pointers start at begining and end</li><li>When the two pointers not cross, loop<ul><li>If left is smaller, check left side<ul><li>Check if need to update <code>leftMax</code></li><li>Calculate water at current index</li><li>Move left pointer</li></ul></li><li>If right is small, check right side<ul><li>Check if need to update <code>rightMax</code></li><li>Calculate water at current index</li><li>Move right pointer</li></ul></li></ul></li></ul><p>Time: O(N), Space: O(1)</p><h4 id=383-ransom-note><a href=https://leetcode.com/problems/ransom-note/>383. Ransom Note</a></h4><ul><li>Use hash table to count occurrence of each letter</li><li>Knowing all the characters are letter, we can use array instead of hash table</li></ul><h2 id=intervals>Intervals</h2><h4 id=228-summary-ranges><a href=https://leetcode.com/problems/summary-ranges/>228. Summary Ranges</a></h4><ul><li>Two pointer, one point to the range start, one is iterating</li><li><strong>Be creaful of the condition</strong></li></ul><h2 id=stack>Stack</h2><h2 id=binary-tree-general>Binary Tree General</h2><h4 id=104-maximum-depth-of-binary-tree><a href=https://leetcode.com/problems/maximum-depth-of-binary-tree/>104. Maximum Depth of Binary Tree</a></h4><p><strong>Keyword</strong>: DFS/BFS on Tree</p><ul><li>Small tree use DFS, deep trees use <strong>BFS</strong>.</li></ul><h4 id=100-same-tree><a href=https://leetcode.com/problems/same-tree/>100. Same Tree</a></h4><ul><li>Try <strong>BFS</strong></li></ul><h3 id=graph-general>Graph General</h3><h4 id=200-number-of-islands><a href=https://leetcode.com/problems/number-of-islands/>200. Number of Islands</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: BFS/DFS on Graph</p><p><strong>Intuition</strong></p><ul><li>When we meet a land, try to sink its adjacent lands until we can&rsquo;t</li></ul><p><strong>Steps: DFS</strong></p><ul><li>Define DFS<ul><li>Input: grid, and coordinate (row, col), Output: void</li><li>If coordinate in range, and current cell is a land<ul><li>Sink it</li><li>Explore adjcent cells</li></ul></li></ul></li><li>Iterate the grid<ul><li>If current cell is land<ul><li>Count up</li><li>Use DFS to sink its adjacent cells</li></ul></li></ul></li></ul><p><strong>Steps: BFS (Recommend)</strong></p><ul><li>Return if <code>grid</code> is empty</li><li>Declare queue to keep pending <strong>lands</strong></li><li>Iterate the grid<ul><li>If current cell is land<ul><li>Sink</li><li>Count up</li><li>Add to queue</li><li>Iterate pending lands (if appplicable)<ul><li>For each land, try 4 directions<ul><li>If cell is in range and is a land<ul><li>Sink</li><li>Add to queue</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>Return count</li></ul><p>Time: O(m x n), Space: O(m x n)</p><h4 id=934-shortest-bridge><a href=https://leetcode.com/problems/shortest-bridge/>934. Shortest Bridge</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: DFS, BFS on Grid</p><p><strong>Intuition</strong></p><ul><li>Try to locate and mark the first island (using 2) with DFS</li><li>Use BFS from all the boundary points of the first island to expand toward the second</li><li>The first point touch the second island is the shortest bridges</li></ul><p><strong>Steps</strong></p><ul><li>Find and mark the first island<ul><li>Declare <code>dfs()</code> function<ul><li>Input: grid, row, col, queue</li><li>Output: None</li><li>If not in range or not island, return</li><li>Mark visited as 2, and push land into queue</li><li>Explore 4 directions</li></ul></li></ul></li><li>Start BFS loop<ul><li>Retrieve island in queue</li><li>Try 4 directions<ul><li>If not in range, skip</li><li>If meet island, return <code>len</code></li><li>If meet sea<ul><li>Mark as visited</li><li>Append to queue</li></ul></li></ul></li></ul></li></ul><p>Time: O(n^2), Space: O(n^2)</p><h4 id=127-word-ladder><a href=https://leetcode.com/problems/word-ladder/>127. Word Ladder</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: BFS on Graph</p><p><strong>Steps</strong></p><ul><li>Put words into hash set</li><li>Return if <code>endWord</code> is not in the set</li><li>Declare queue of {string, depth} pair for later BFS</li><li>Declare hash set of visited strings</li><li>BFS loop<ul><li>For each word, try to replace each character from &lsquo;a&rsquo; to &lsquo;z&rsquo; (two loops)</li><li>If new word is end word, return <code>depth + 1</code></li><li>If new word is inside the set, and never visited, append to queue</li></ul></li></ul><h4 id=207-course-schedule><a href=https://leetcode.com/problems/course-schedule/>207. Course Schedule</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: BFS on Graph</p><p><strong>Key Idea</strong></p><ul><li>&ldquo;In Degree&rdquo;<ul><li>Definition: In a directed graph, the in-degree of a node is the number of edges pointing into it. The out-degree is the number of edges leaving it.</li><li>In topological sort, we<ul><li>Start with the node that have 0 in-degree</li><li>Then process and reduce the in-degree of the neighbor nodes</li></ul></li></ul></li></ul><p><strong>Intuition</strong></p><ul><li>All the prerequisities form a <strong>directed graph</strong></li><li>Start from the courses with no prerequisities (0 degree)</li><li>Return true if we can iterate all the nodes</li></ul><p><strong>Steps</strong></p><ul><li>Iterate the prerequisites, to<ul><li>Build a graph, from pre course point to course</li><li>Track in-degree of the course</li></ul></li><li>Start with the course having 0 in-degree</li><li>BFS<ul><li>Process: Count up the taken course</li><li>Reduce the in-degree of the next courses (neighbors)</li></ul></li><li>The taken courses count should be equal to number of courses</li></ul><p>Time: O(N + E), Space: O(N + E)</p><h4 id=210-course-schedule-ii><a href=https://leetcode.com/problems/course-schedule-ii/>210. Course Schedule II</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Intuition</strong></p><ul><li>Same as <a href=/topics/interview/leetcode-top-interview/#207-course-schedule>207. Course Schedule</a></li><li>Change BFS Process: append current course</li></ul><p>Time: O(N + E), Space: O(N + E)</p><h2 id=binary-operation>Binary Operation</h2><h4 id=67-add-binary><a href=https://leetcode.com/problems/add-binary/>67. Add Binary</a></h4><ul><li>Simulate binary addition (with two pointers)</li></ul><h2 id=binary-tree>Binary Tree</h2><h4 id=638-shopping-offers><a href=https://leetcode.com/problems/shopping-offers/>638. Shopping Offers</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: DFS</p><p><strong>Intuition</strong></p><ul><li>Try <strong>ALL</strong> possible combinations of special offers to minimize the cost</li><li>Use DFS (recursion) with memoization to explore state space</li></ul><p><strong>Steps</strong></p><ul><li>Declare <code>dfs(...)</code> function<ul><li>Input: prices, offers, needs</li><li>Output: min cost</li><li>If in memo, retrieve and return</li><li>Base case: without special offers</li><li>Try each offer<ul><li>Offer valid if all the needs is greater and equal to item in offer</li><li>Deduct the offer item count from need</li><li>Try to calculate new min cost with new needs</li></ul></li><li>Update min cost of current need</li><li>Return min cost</li></ul></li><li>Start dfs with given prices, offers and needs</li></ul><h4 id=103-binary-tree-zigzag-level-order-traversal><a href=https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/>103. Binary Tree Zigzag Level Order Traversal</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: BFS on Tree</p><p><strong>Intuition</strong></p><ul><li>Almost the same as binary tree level traverse</li><li>Except we need one more boolean to indicate the direction, reverse the values in level based on the direction</li></ul><h4 id=314-binary-tree-vertical-order-traversal><a href=https://leetcode.com/problems/binary-tree-vertical-order-traversal/>314. Binary Tree Vertical Order Traversal</a></h4><p><strong>PROBLEM STATEMENT</strong></p><p>Given the <code>root</code> of a binary tree, return its vertical order traversal.</p><ul><li>Nodes in the same vertical are ordered from top to bottom.</li><li>If multiple nodes are in the same position, they appear in left-to-right order.</li></ul><p><strong>Keyword</strong>: BFS</p><p><strong>Intuition</strong></p><ul><li>Top to bottom, left to right, so use BFS</li><li>During BFS, track the column</li><li><code>column = column_parent +/- 1</code>, and <code>root_column = 0</code></li></ul><p><strong>Approach</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Definition for a binary tree node.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// struct TreeNode {
</span></span></span><span style=display:flex><span><span style=color:#75715e>//     int val;
</span></span></span><span style=display:flex><span><span style=color:#75715e>//     TreeNode *left;
</span></span></span><span style=display:flex><span><span style=color:#75715e>//     TreeNode *right;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>//     TreeNode(int val = 0): TreeNode(val, nullptr, nullptr) {}
</span></span></span><span style=display:flex><span><span style=color:#75715e>//     TreeNode(int x, TreeNode *left, TreeNode *right): val(x), left(left), right(right) {}
</span></span></span><span style=display:flex><span><span style=color:#75715e>// };
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Intuition: BFS with column tracking
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> verticalTraversal(TreeNode<span style=color:#f92672>*</span> root) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> {};
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// We need a ordered map to store Column -&gt; Nodes&#39; value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> col_nodes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// For the BFS queue, we store Node -&gt; Column
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>queue<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>pair<span style=color:#f92672>&lt;</span>TreeNode<span style=color:#f92672>*</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> q;
</span></span><span style=display:flex><span>        q.push({root, <span style=color:#ae81ff>0</span>});
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// BFS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>q.empty()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>auto</span> [node, column] <span style=color:#f92672>=</span> q.front();
</span></span><span style=display:flex><span>            q.pop();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            col_nodes[column].push_back(node<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>auto</span> left <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>left) {
</span></span><span style=display:flex><span>                q.push({left, column <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>});
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>auto</span> right <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>right) {
</span></span><span style=display:flex><span>                q.push({right, column <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>});
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> res;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> [_, nodes]<span style=color:#f92672>:</span> col_nodes) {
</span></span><span style=display:flex><span>            res.push_back(nodes);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Time: O($Nlog(N)$), Space: O(N)</p><h4 id=987-vertical-order-traversal-of-a-binary-tree><a href=https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/>987. Vertical Order Traversal of a Binary Tree</a></h4><p><strong>HARD</strong></p><p><strong>Keyword</strong>: BFS</p><p><strong>Intuitions</strong></p><ul><li>The different with <a href=/topics/interview/leetcode-top-interview/#314-binary-tree-vertical-order-traversal>314. Binary Tree Vertical Order Traversal</a> is that if there multiple nodes in the same row and same column, sort these nodes by their values.</li><li>We could reuse the same structure, but change <code>std::vector&lt;int></code> to <code>std::map&lt;int, std::multiset&lt;int>></code>, meaning &ldquo;row -> sorted nodes&rdquo;</li><li>Optionally we can use DFS with sorting</li></ul><p><strong>Approach: DFS with Sorting</strong></p><ul><li>DFS to traverse all nodes with (col, row)</li><li>Sort the nodes by, with the container of map&lt;col, map&lt;row, multiset<val>&#187;<ul><li>Column(left->right)</li><li>Row(top->bottom)</li><li>Value(ascending)</li></ul></li><li>Build the result</li></ul><p>Time: O($Nlog(N)$), Space: O(N)</p><h4 id=236-lowest-common-ancestor-of-a-binary-tree><a href=https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/>236. Lowest Common Ancestor of a Binary Tree</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: DFS</p><p><strong>Intuition</strong></p><ul><li>Use DFS to traverse the tree and locate LCA</li><li>Try <a href=/topics/interview/leetcode-top-interview/#1650-lowest-common-ancestor-of-a-binary-tree-iii>1650. Lowest Common Ancestor of a Binary Tree III</a>, and you would find that if the node can access its parent, everything is better.</li><li>So the other option is to build a hash map of nodes and their parent first, and the problem is the same as <a href=/topics/interview/leetcode-top-interview/#1650-lowest-common-ancestor-of-a-binary-tree-iii>1650. Lowest Common Ancestor of a Binary Tree III</a></li></ul><p><strong>Steps</strong></p><ul><li>DFS function<ul><li>Return: the LCA</li><li>Inputs: node, taget1, target2</li><li>If <code>node</code> is null, return null</li><li>If any of <code>p</code> and <code>q</code> is <code>node</code>, return <code>node</code></li><li>Recursively get left LCA and right LCA from left and right branch</li><li>If LCA exists on both sides, return <code>node</code></li><li>Either <code>p</code> or <code>q</code> on one side of the <code>node</code>, LCA should be in that side of the <code>node</code></li></ul></li><li>Use DFS on left and right</li></ul><p><strong>Notes</strong></p><ul><li>Even we can reuse the <code>lowestCommonAncestor()</code> function, its intention is confusing(we can&rsquo;t always find LCA in the subtree!), we better use a new <code>dfs()</code> function to define what to do in DFS recursion</li></ul><h4 id=1644-lowest-common-ancestor-of-a-binary-tree-ii><a href=https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/>1644. Lowest Common Ancestor of a Binary Tree II</a></h4><p><strong>PROBLEM STATEMENT</strong></p><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes <code>p</code> and <code>q</code>. However, this version of the problem has a special requirement:</p><ul><li>If either <code>p</code> or <code>q</code> is missing from the tree, return <code>nullptr</code> instead of the LCA.</li></ul><p><strong>Keyword</strong>: DFS</p><p><strong>Intuition</strong></p><ul><li>Similar to <a href=/topics/interview/leetcode-top-interview/#236-lowest-common-ancestor-of-a-binary-tree>236. Lowest Common Ancestor of a Binary Tree</a></li><li>The <code>dfs</code> function carries more infos</li></ul><p><strong>Solution</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Reuse the structure of basic LCA, but in dfs(), we carry the result if q and p exist in the tree, 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> lowestCommonAncestor(Node<span style=color:#f92672>*</span> root, Node<span style=color:#f92672>*</span> p, Node<span style=color:#f92672>*</span> q) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> findP{false}, findQ{false};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> lca <span style=color:#f92672>=</span> dfs(root, p, q, findP, findQ);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (findP <span style=color:#f92672>&amp;&amp;</span> findQ) <span style=color:#f92672>?</span> lca : <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> dfs(Node<span style=color:#f92672>*</span> node, Node<span style=color:#f92672>*</span> p, Node<span style=color:#f92672>*</span> q, <span style=color:#66d9ef>bool</span><span style=color:#f92672>&amp;</span> findP, <span style=color:#66d9ef>bool</span><span style=color:#f92672>&amp;</span> findQ) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>node) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> leftFindP{false}, leftFindQ{false};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> left <span style=color:#f92672>=</span> dfs(node<span style=color:#f92672>-&gt;</span>left, p, q, leftFindP, leftFindQ);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> rightFindP{false}, rightFindQ{false};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> right <span style=color:#f92672>=</span> dfs(node<span style=color:#f92672>-&gt;</span>right, p, q, rightFindP, rightFindQ);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        findP <span style=color:#f92672>=</span> leftFindP <span style=color:#f92672>||</span> rightFindP <span style=color:#f92672>||</span> node <span style=color:#f92672>==</span> p;
</span></span><span style=display:flex><span>        findQ <span style=color:#f92672>=</span> leftFindQ <span style=color:#f92672>||</span> rightFindQ <span style=color:#f92672>||</span> node <span style=color:#f92672>==</span> q;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (node <span style=color:#f92672>==</span> p <span style=color:#f92672>||</span> node <span style=color:#f92672>==</span> q) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> node;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (left <span style=color:#f92672>&amp;&amp;</span> right) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> node;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> left <span style=color:#f92672>?</span> left : right;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=1650-lowest-common-ancestor-of-a-binary-tree-iii><a href=https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/>1650. Lowest Common Ancestor of a Binary Tree III</a></h4><p><strong>PROBLEM STATEMENT</strong></p><p>Given two nodes in a binary tree where each node contains a parent pointer, find their lowest common ancestor (LCA).</p><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Steps</strong></p><ul><li>Use two pointers, start at <code>p</code> and <code>q</code></li><li>Move each pointer upward to its parent until they meet</li><li>If a pointer reaches the root (<code>parent = nullptr</code>), restart at the other node<ul><li>Both pointers would traverse the same height in the end</li></ul></li><li>The first common node encountered is the LCA</li></ul><p><strong>Solution</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Node definition
</span></span></span><span style=display:flex><span><span style=color:#75715e>// class Node {
</span></span></span><span style=display:flex><span><span style=color:#75715e>//     int val;
</span></span></span><span style=display:flex><span><span style=color:#75715e>//     Node* left;
</span></span></span><span style=display:flex><span><span style=color:#75715e>//     Node* right;
</span></span></span><span style=display:flex><span><span style=color:#75715e>//     Node* parent;
</span></span></span><span style=display:flex><span><span style=color:#75715e>// };
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> lowestCommonAncestor(Node<span style=color:#f92672>*</span> p, Node<span style=color:#f92672>*</span> q) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Two pointers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>auto</span> p1{p};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> p2{q};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (p1 <span style=color:#f92672>!=</span> p2) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 1. Move pointer upward to parent
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 2. If pointer reaches nullptr, restart at the other&#39;s position
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            p1 <span style=color:#f92672>=</span> p1 <span style=color:#f92672>?</span> p1<span style=color:#f92672>-&gt;</span>parent : q;
</span></span><span style=display:flex><span>            p2 <span style=color:#f92672>=</span> p2 <span style=color:#f92672>?</span> p2<span style=color:#f92672>-&gt;</span>parent : p;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> p1;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Time: O(H), Space: O(1)</p><h4 id=199-binary-tree-right-side-view><a href=https://leetcode.com/problems/binary-tree-right-side-view>199. Binary Tree Right Side View</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: BFS</p><p><strong>Intuition</strong></p><ul><li>Because we need to iterate the tree by layer, so BFS</li><li>The last node is the right most node in current layer</li><li>Optional: DFS. Add the right node first, so when list size is same as the depth, that&rsquo;s the right most node</li></ul><p><strong>Steps</strong></p><ul><li>Prepare BFS<ul><li>Declare queue of Node</li><li>Push root</li></ul></li><li>BFS loop<ul><li>Iterate elements in layer<ul><li>Update the last element</li><li>Insert left and right (if neccessary)</li></ul></li><li>Append last number of this layer</li></ul></li><li>Return result</li></ul><p>Time: O(N), Space: O(N)</p><p><strong>Variants</strong></p><ul><li>Left Side View: Same structure, but save the first node of the layer</li></ul><h4 id=543-diameter-of-binary-tree><a href=https://leetcode.com/problems/diameter-of-binary-tree/>543. Diameter of Binary Tree</a></h4><p><strong>Keyword</strong>: DFS</p><p><strong>Intuition</strong></p><ul><li>Diameter of a node is the longest path goes through the node<ul><li>In other words, <strong>the largest sum of left and right subtree height</strong></li></ul></li><li>Because we need to calculate the height from bottom up, so use DFS</li></ul><p><strong>Steps</strong></p><ul><li>DFS recursion<ul><li>Calculate the sum of left and right subtring height</li><li>Update the max diameter</li><li>Return height</li></ul></li><li>Start recursion with root</li></ul><p>Time: O(N), Space: O(H)</p><h4 id=863-all-nodes-distance-k-in-binary-tree><a href=https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/>863. All Nodes Distance K in Binary Tree</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>MEDIUM BUT HARD!</strong></p><p><strong>Keyword</strong>: Binary Tree, BFS on Graph</p><p><strong>Intuition</strong></p><ul><li>We are given a tree, but the problem is more like a graph, so we <strong>build a undirected graph from tree</strong></li><li>Use BFS to traverse the graph, and find all the paths of length k</li></ul><p><strong>Steps</strong></p><ul><li>Build undirected graph from tree<ul><li>Inputs: node, parent</li><li>Append parent to node&rsquo;s neigbors, append node to parent&rsquo;s neigbors</li><li>Recursively build left and right</li></ul></li><li>Prepare BFS queue, and visited set</li><li>Declare distance (depth), init as 0</li><li>Start the loop<ul><li>If distance is k, break</li><li>Else iterate elements in current distance<ul><li>Pop the front</li><li>Insert its neigbors (is not visited)</li></ul></li><li>Distance count up</li></ul></li><li>Return the elements in the queue</li></ul><p>Time: O(N) + O(N), Space: O(N)</p><h4 id=124-binary-tree-maximum-path-sum><a href=https://leetcode.com/problems/binary-tree-maximum-path-sum/>124. Binary Tree Maximum Path Sum</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>HARD</strong></p><p><strong>Keyword</strong>: Binary Tree, DFS</p><p><strong>Intuition</strong></p><ul><li>We want to know the <strong>max</strong> sum, so think of DFS</li><li>DFS function track the max sum and the max gain (from single side)</li></ul><p><strong>Steps</strong></p><ul><li>DFS function<ul><li>Return: Max Gain.</li><li>Inputs: Node, max sum</li><li>If node is null, return 0</li><li>Calculate sum of left and right node</li><li>Calculate current sum</li><li>Update max sum</li><li>Return max gain</li></ul></li><li>Traverse the tree with DFS, start with root, and max sum is 0</li></ul><p>Time: O(N), Space: O(H)</p><h4 id=297-serialize-and-deserialize-binary-tree><a href=https://leetcode.com/problems/serialize-and-deserialize-binary-tree/>297. Serialize and Deserialize Binary Tree</a></h4><p><strong>HARD</strong></p><ul><li>We can use BFS to solver handle serialization and deserialization</li><li>Serialization<ul><li>Check <code>node</code> is <code>nullptr</code> instead of <code>node->left</code> and <code>node->right</code></li></ul></li><li>Deserialization<ul><li>Get familiar with <code>int std::getline(std::stringstream, std::string, char)</code></li></ul></li></ul><h4 id=129-sum-root-to-leaf-numbers><a href=https://leetcode.com/problems/sum-root-to-leaf-numbers/>129. Sum Root to Leaf Numbers</a></h4><p><strong>Keyword</strong>: DFS</p><p><strong>Intuition</strong></p><ul><li>Because we need to reach the leaf to build up a number, so DFS</li></ul><p><strong>Steps</strong></p><ul><li>DFS, while tracking the sum<ul><li>Calculate current number</li><li>If meet leaf, return current number as sum</li><li>Else, return the sum of left and right node</li></ul></li></ul><p>Time: O(N), Space: O(H)</p><h2 id=binary-search-treebst>Binary Search Tree(BST)</h2><h4 id=938-range-sum-of-bst><a href=https://leetcode.com/problems/range-sum-of-bst/>938. Range Sum of BST</a></h4><p><strong>Keyword</strong>: DFS on BST</p><p><strong>Steps</strong></p><ul><li>DFS function: Return sum<ul><li>If current val smaller than low, return sum of right branch</li><li>If current val larger than high, return sum of left branch</li><li>If current val in range, return the sum of left and rigth branches, and current value</li></ul></li></ul><p>Time: O(N), Space: O(H)</p><h4 id=230-kth-smallest-element-in-a-bst><a href=https://leetcode.com/problems/kth-smallest-element-in-a-bst/>230. Kth Smallest Element in a BST</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: In-order Traversal on BST</p><p><strong>Intuition</strong></p><ul><li>In order traversal on BST, and carrying the counter, stop when <code>counter == k</code></li></ul><p><strong>Steps</strong></p><ul><li>Declare <code>traverse()</code> function<ul><li>Input: node, k</li><li>Carry: count, result</li><li>Output: void</li><li>If <code>node</code> is null or count meet/exceed k, return</li><li>Traverse left node</li><li><code>count</code> add up</li><li>If <code>counter == k</code>, save current val to result, and return</li><li>Traverse left node</li></ul></li><li>Start from root, k, count = 0, res = -1</li></ul><p>Time: O(H + N), Space: O(H)</p><h2 id=binary-search>Binary Search</h2><h4 id=875-koko-eating-bananas><a href=https://leetcode.com/problems/koko-eating-bananas/>875. Koko Eating Bananas</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Binary Search</p><p><strong>Intuition</strong></p><ul><li>The more bananas Koko eats per hour, the fewer hours she needs.</li><li>We can binary search for the minimum valid speed <code>k</code> between 1 and the maximum in <code>piles</code>.</li></ul><p><strong>Steps</strong></p><ul><li>Write a helper function: Given eating speed <code>k</code>, check can eat all or not?<ul><li>Iterate piles<ul><li>Use <code>(pile + k - 1)</code> to efficiently calculate <code>std::ceil(pile / (double)k)</code></li></ul></li></ul></li><li>Binary search loop<ul><li><code>left</code>: 1 (min eat one banana), <code>right</code>: max of pile</li><li>If can eat all, slow down, move right</li><li>Else, speed up, move left</li></ul></li><li>Return left</li></ul><p>Time: O(nLog(max)), each check takes O(n), binary search take O(log(max)), Space: O(1)</p><h4 id=410-split-array-largest-sum><a href=https://leetcode.com/problems/split-array-largest-sum/>410. Split Array Largest Sum</a></h4><p><strong>Keyword</strong>: Binary Search</p><h2 id=string>String</h2><h4 id=20-valid-parentheses><a href=https://leetcode.com/problems/valid-parentheses/>20. Valid Parentheses</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Stack, Parentheses</p><p><strong>Steps</strong></p><ul><li>Define hash map to store Parentheses. {close, open}</li><li>Use a stack to hold the pending open brackets</li><li>Iterate string<ul><li>If open, push to stack</li><li>If close<ul><li>If stack empty, or stack top (last) not equal to corresponding open, return false</li><li>Else pop</li></ul></li></ul></li></ul><h4 id=22-generate-parentheses><a href=https://leetcode.com/problems/generate-parentheses/>22. Generate Parentheses</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Backtrack</p><p><strong>Intuition</strong></p><ul><li>Add open as much as possible (less than n)</li><li>Add close when close is less than open</li></ul><p><strong>Steps</strong></p><ul><li>Define <code>backtrack</code> function<ul><li>Parameters: current string, open count, close count, total parenthese need, combination so far</li><li>If current string size is equal to <code>2*n</code><ul><li>Append current string and return</li></ul></li><li>If open count is less than total need, append open</li><li>If close count is less than open count, append close</li></ul></li></ul><h4 id=1249-minimum-remove-to-make-valid-parentheses><a href=https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses>1249. Minimum Remove to Make Valid Parentheses</a></h4><p><strong>Approach I: Two-Pass with Stack</strong></p><ol><li>Use stack to store &lsquo;(&rsquo;, and unordered_set for invalid indices for quick access</li><li>1st pass: locate the unpaired &lsquo;)&rsquo; indices</li><li>2nd pass: Add the left &lsquo;(&rsquo; (unpaired) indices into invalid indices</li><li>Build new string by removing invalid indices</li></ol><p>Time: O(N), Space: O(N)</p><h4 id=921-minimum-add-to-make-parentheses-valid><a href=https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/>921. Minimum Add to Make Parentheses Valid</a></h4><p><strong>Approach: Simulate Stack</strong></p><ul><li>Traverse from left to right</li><li>When encountering &lsquo;(&rsquo;, increase left counter</li><li>When encountering &lsquo;)&rsquo;<ul><li>There&rsquo;s &lsquo;(&rsquo; left, decrease counter</li><li>Otherwise, increase right counter</li></ul></li></ul><h4 id=408-valid-word-abbreviation><a href=https://leetcode.com/problems/valid-word-abbreviation/>408. Valid Word Abbreviation</a></h4><p><strong>PROBLEM STATEMENT</strong></p><p>Given a string <code>word</code> and an abbreviation <code>abbr</code>, return <code>true</code> if <code>abbr</code> is a valid abbreviation for <code>word</code>, otherwise return <code>false</code>.</p><p>A valid abbreviation follows these rules:</p><ul><li>A number in <code>abbr</code> represents skipping that many characters in word.</li><li>Numbers cannot have leading zeros (e.g., &ldquo;01&rdquo; is invalid).</li><li>The skipped characters must match the length indicated by the number.</li></ul><p>Examples</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Input
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>word <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;internationalization&#34;</span>
</span></span><span style=display:flex><span>abbr <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;i12iz4n&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>true
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Input
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>word <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;apple&#34;</span>
</span></span><span style=display:flex><span>abbr <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;a2e&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>false
</span></span></code></pre></div><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Solution</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> validWordAbbreviation(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> word, <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> abbr) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Two pointer: one for word, one for abbr
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        size_t i{<span style=color:#ae81ff>0</span>}, j{<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> word.size() <span style=color:#f92672>&amp;&amp;</span> j <span style=color:#f92672>&lt;</span> abbr.size()) {            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// match digit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> ch_a <span style=color:#f92672>=</span> abbr[j]; std<span style=color:#f92672>::</span>isdigit(ch_a)) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// No leading &#39;0&#39; 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> (ch_a <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;0&#39;</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// read number
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>auto</span> num{<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (j <span style=color:#f92672>&lt;</span> abbr.size() <span style=color:#f92672>&amp;&amp;</span> std<span style=color:#f92672>::</span>isdigit(abbr[j])) {
</span></span><span style=display:flex><span>                    num <span style=color:#f92672>=</span> num <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span> <span style=color:#f92672>+</span> (abbr[j] <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;0&#39;</span>);
</span></span><span style=display:flex><span>                    j<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// move forward
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                i <span style=color:#f92672>+=</span> num;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> { <span style=color:#75715e>// match word
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// Mismatch
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> (ch_a <span style=color:#f92672>!=</span> word[i]) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                j<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Fully processed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> i <span style=color:#f92672>==</span> word.size() <span style=color:#f92672>&amp;&amp;</span> j <span style=color:#f92672>==</span> abbr.size();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Time: O(len(word) + len(abbr)), Space: O(1)</p><h4 id=791-custom-sort-string><a href=https://leetcode.com/problems/custom-sort-string/>791. Custom Sort String</a></h4><p><strong>Intuition</strong></p><ul><li><code>order</code> has less character, and it defines the order, so build final string from <code>order</code> based on <code>s</code> frequency</li></ul><p><strong>Steps</strong></p><ul><li>Declare hash map to count occurance in <code>s</code></li><li>Count occurance</li><li>Build result by iterating through <code>order</code></li><li>Append the remaining letters at the end</li></ul><p>Time: O(N), Space: O(N)</p><h4 id=215-kth-largest-element-in-an-array><a href=https://leetcode.com/problems/kth-largest-element-in-an-array/>215. Kth Largest Element in an Array</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Approach I: Sort</strong></p><ul><li>Sort the array in descending order</li><li>Return kth element</li></ul><p>Time: O($Nlog(N)$), Space: O(1). Good for small N</p><p><strong>Approach II: Min Heap</strong></p><ul><li>Define min heap to maintain the k largest elements</li><li>Iterate array<ul><li>Pop (the smallest) when the heap size exceeds k</li></ul></li><li>Return the top element</li></ul><p>Time: O($Nlog(K)$), Space: O(K). Good for big K, or streaming data</p><p><strong>Approach III: Quickselect</strong></p><p>TODO</p><p>Time: O(N) average, O($N^2$) worst, Space: O(1)</p><h4 id=224-basic-calculator><a href=https://leetcode.com/problems/basic-calculator/>224. Basic Calculator</a></h4><p><img src="https://img.shields.io/badge/Meta-%230467DF.svg?style=for-the-badge&amp;logo=Meta&amp;logoColor=white" alt=Meta></p><h4 id=227-basic-calculator-ii><a href=https://leetcode.com/problems/basic-calculator-ii/>227. Basic Calculator II</a></h4><p><img src="https://img.shields.io/badge/Meta-%230467DF.svg?style=for-the-badge&amp;logo=Meta&amp;logoColor=white" alt=Meta><br><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Stack</p><p><strong>Intuition</strong></p><ul><li>If there are only &lsquo;+&rsquo; and &lsquo;-&rsquo;, then process the numbers in sequence</li><li>But we have &lsquo;*&rsquo; and &lsquo;/&rsquo;, upcoming number should be processed immediately</li><li>So we use stack to achieve this</li></ul><p><strong>Steps</strong></p><ul><li>Declare stack, (current) number, and last operator</li><li>Iterate the string while tracking the current number and last operator<ul><li>If digit, convert to number</li><li>If (not digit and not space), or it&rsquo;s last digit<ul><li>+: Push number to stack</li><li>-: Push neg number to stack</li><li>*: Calculate stack.top() * num, pop, and push result</li><li>/: Calculate stack.top() / num, pop, and push result</li><li>Update last operator, clear number</li></ul></li></ul></li><li>Sum up all the elements in stack</li></ul><p>Time: O(N), Space: O(N)</p><h4 id=528-random-pick-with-weight><a href=https://leetcode.com/problems/random-pick-with-weight/>528. Random Pick with Weight</a></h4><p><strong>Keyword</strong>: Prefix Sum, Binary Search</p><p><strong>Intuition</strong></p><ul><li>Prefix sum can map the range into prefix sum array</li><li>Use binary search to quickly find the valid index</li></ul><p><strong>Steps</strong></p><ul><li>Build a prefix sum array, and total sum) from the input array in constructor</li><li>Pick random value x between [1, total]</li><li>Use binary search to find the lowerbound where prefixSum[i] >= x</li></ul><p><strong>Note</strong></p><p>How to randomly pick a number in a range with modern C++?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>rndom_device rd;
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>mt19937 rng{rd()};
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>uniform_int_distribution<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dist{kLow, kHigh};
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> num <span style=color:#f92672>=</span> dist(rd);a
</span></span></code></pre></div><h4 id=162-find-peak-element><a href=https://leetcode.com/problems/find-peak-element/>162. Find Peak Element</a></h4><p><strong>IMPORTANT!!!</strong></p><p><strong>Keyword</strong>: Binary Search</p><p><strong>Intuition</strong></p><ul><li>We are guaranteed to find a peak, and we can return any peak.</li><li>Use binary search</li></ul><p><strong>Steps</strong></p><ul><li>Start at <code>0</code> and <code>n-1</code></li><li>Loop, condition: Not cross (left &lt; right)<ul><li>Calculate <code>mid</code>, and compare <code>nums[mid]</code> and <code>nums[mid+1]</code><ul><li><code>nums[mid]</code> > <code>nums[mid+1]</code>, move <code>right</code> to <code>mid</code></li><li><code>nums[mid]</code> &lt; <code>nums[mid+1]</code>, move <code>left</code> to <code>mid + 1</code></li></ul></li></ul></li><li>Return left (because <code>left == right</code> in the end)</li></ul><p>Time: O($log(N)$), Space: O(1)</p><h4 id=50-powx-n><a href=https://leetcode.com/problems/powx-n/>50. Pow(x, n)</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Divide and Conquer</p><p><strong>Observations</strong></p><ul><li>If n is even, $x^n = (x^2)^{n/2}$</li><li>If n is odd, $x^n = x \times x^{n-1}$</li></ul><p><strong>Steps</strong></p><ul><li>Corner case n == 0, return 1</li><li>Inverse <code>x</code> and <code>n</code>, if the exponent is negative<ul><li>Be careful, range of <code>int</code> is $[-2^{31} - 1, 2^{31}]$, so $[2^{31} + 1]$ would overflow, either use <code>long long</code>, or calculate $x * myPow(x, -(n + 1))$</li></ul></li><li>Use recursive/iteration.<ul><li>If <code>n</code> is even, $x^n = (x^2)^{n / 2}$</li><li>If <code>n</code> is odd, $x^n = x * x^{n-1}$</li></ul></li></ul><p>Time: O($Log(N)$), Space: recursive O($Log(N)$); Iteration: O(1)</p><h4 id=71-simplify-path><a href=https://leetcode.com/problems/simplify-path/>71. Simplify Path</a></h4><p><strong>Keyword</strong>: Stack</p><p><strong>Observations</strong></p><ul><li>Similar to <a href=/topics/interview/leetcode-top-interview/#227-basic-calculator-ii>227. Basic Calculator II</a></li></ul><p><strong>Steps</strong></p><ul><li>Split the input path with &lsquo;/&rsquo;<ul><li>Use <code>std::getline()</code></li></ul></li><li>Process each part<ul><li>&ldquo;.&rdquo; and "" -> ignore</li><li>&ldquo;..&rdquo; -> move up one by pop stack</li><li>Other are valid name, push stack</li></ul></li><li>Build output string.<ul><li>Always startsWith &lsquo;/&rsquo;, try not to use condition in the loop</li></ul></li></ul><p>Time: O(N), Space: O(N)</p><h4 id=1091-shortest-path-in-binary-matrix><a href=https://leetcode.com/problems/shortest-path-in-binary-matrix/>1091. Shortest Path in Binary Matrix</a></h4><p><strong>Keyword</strong>: BFS</p><p><strong>Intuition</strong></p><ul><li>Since we want to find a shortest path, use BFS</li><li>Explore 8 directions</li><li>Track visited nodes to avoid cycles</li></ul><p><strong>Steps</strong></p><ul><li>If the top-left or bottom-right cell is 1, return false</li><li>Element in BFS queue is [row, col],<ul><li>Push root</li><li>Update grid to visited</li><li>Init length to 1</li></ul></li><li>BFS Loop<ul><li>Iterate each layer (8 directions)<ul><li>If reach bottom-right, return length</li><li>Try all 8 directions<ul><li>If still in bound, and not visited<ul><li>Push into layer</li><li>Update visited</li></ul></li></ul></li></ul></li><li>Increase path</li></ul></li><li>Default not found, return -1</li></ul><p>Time: O($N^2$), Space: O($N^2$), Worst case: visit all the nodes</p><h4 id=1570-dot-product-of-two-sparse-vectors><a href=https://leetcode.com/problems/dot-product-of-two-sparse-vectors/>1570. Dot Product of Two Sparse Vectors</a></h4><p><strong>PROBLEM STATEMENT</strong></p><p>Given two sparse vectors, implement their dot product efficiently.</p><p>A sparse vector contains mostly 0s, so storing and computing all elements naively is inefficient.</p><p>Implement a class <code>SparseVector</code> with:</p><ul><li>Constructor: <code>SparseVector(vector&lt;int>& nums)</code></li><li>Dot product function: <code>int dotProduct(SparseVector& vec)</code></li></ul><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Intuition</strong></p><ul><li>Store the SparseVector as list of non-zero numbers&rsquo; index and value</li><li>Use two pointers to iterate both SparseVector</li></ul><p><strong>Solution</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SparseVector</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Store Non-Zero element: {index: value}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>pair<span style=color:#f92672>&lt;</span>size_t, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> nonzeros;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> <span style=color:#a6e22e>SparseVector</span>(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (size_t i{<span style=color:#ae81ff>0</span>}; i <span style=color:#f92672>&lt;</span> nums.size(); <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> num <span style=color:#f92672>=</span> nums[i]; num <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                nonzeros.push_back({i, num});
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dotProduct</span>(<span style=color:#66d9ef>const</span> SparseVector<span style=color:#f92672>&amp;</span> o) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> res{<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>        size_t i{<span style=color:#ae81ff>0</span>}, j{<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> nonzeros.size() <span style=color:#f92672>&amp;&amp;</span> j <span style=color:#f92672>&lt;</span> o.nonzeros.size()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>auto</span> i1 <span style=color:#f92672>=</span> nonzeros[i].first, i2 <span style=color:#f92672>=</span> nonzeros[j].first; i1 <span style=color:#f92672>==</span> i2) {
</span></span><span style=display:flex><span>                res <span style=color:#f92672>+=</span> nonzeros[i].second <span style=color:#f92672>*</span> nonzeros[j].second;
</span></span><span style=display:flex><span>                i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                j<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (i1 <span style=color:#f92672>&lt;</span> i2) {
</span></span><span style=display:flex><span>                i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                j<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Time: O(N), Space: O(K), where K is non zero element count.</p><h4 id=125-valid-palindrome><a href=https://leetcode.com/problems/valid-palindrome/>125. Valid Palindrome</a></h4><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Steps</strong></p><ul><li>Two pointers start from the start and end</li><li>Loop unitl <code>left</code> and <code>right</code> cross<ul><li>Ignore the non-alnum characters on both sides</li><li>Convert to lowercase and compare</li><li>Move closer</li></ul></li></ul><p>Time: O(N), Space: O(1)</p><h4 id=680-valid-palindrome-ii><a href=https://leetcode.com/problems/valid-palindrome-ii/>680. Valid Palindrome II</a></h4><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Approach: Two Pointer with (at most) one skip</strong></p><ul><li>Write a function to check if a string between range is palindrome</li><li>Two pointers start from the start and end</li><li>Loop unitl <code>left</code> and <code>right</code> cross<ul><li>If not match, try to move either <code>left</code> or <code>right</code></li><li>Move closer</li></ul></li></ul><p>Time: O(N), Space: O(1)</p><h4 id=9-palindrome-number><a href=https://leetcode.com/problems/palindrome-number/>9. Palindrome Number</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Intuition</strong></p><ul><li>Convert to string, then two pointers (not optimal)</li><li>Reverse the last half of the number and compare it to the first half<ul><li>If <code>x == reversedHalf</code> (even digits) or <code>x == reversedHalf / 10</code> (odd digits), it&rsquo;s a palindrome.</li></ul></li></ul><p><strong>Steps</strong></p><ul><li>Corner case, return false<ul><li>Negative number</li><li>Number ends with 0</li></ul></li><li><code>while x > reverse_half</code>, we want x is larger or equal to rev<ul><li>Use last digit to assemble reverse_half</li><li>Remove last digit</li></ul></li><li>Compare first half and last half</li></ul><p>Time: O(log(N))</p><h4 id=647-palindromic-substrings><a href=https://leetcode.com/problems/palindromic-substrings/>647. Palindromic Substrings</a></h4><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Steps</strong></p><ul><li>Expand string from center of each character, and count valid palindrome<ul><li>Consider both odd number (<code>i, i</code>) and even number (<code>i, i + 1</code>)</li></ul></li></ul><p>Time: O($N^2$), Space: O(1)</p><h4 id=5-longest-palindromic-substring><a href=https://leetcode.com/problems/longest-palindromic-substring/>5. Longest Palindromic Substring</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Intuition</strong></p><ul><li>Expand string from center to get longest palindrom</li></ul><p><strong>Steps</strong></p><ul><li>Iterate all characters<ul><li>Expand string from center of each character from both odd number (<code>i, i</code>) and even number (<code>i, i + 1</code>)</li><li>Get the longer substring</li><li>Update maxLen (and start index) if neccessary</li></ul></li><li>Return substring</li></ul><p>Time: O(N^2), Space: O(1)</p><h4 id=767-reorganize-string><a href=https://leetcode.com/problems/reorganize-string/>767. Reorganize String</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Greedy, Max-Heap</p><p><strong>Steps</strong></p><ul><li>Count frequency of each character. (Use hash map or array)</li><li>Declare a max heap to sort the characters by count, so later we can track the <strong>two most frequent</strong> characters<ul><li>Push {count, char} pairs to max heap</li></ul></li><li>Start loop while make sure at least 2 elements in queue<ul><li>Retrive the most count two characters</li><li>Append to the result</li><li>Decrease count, and push back to max heap if applicable</li></ul></li><li>If some element left in the queue at the end,<ul><li>If the element has more than 1 count, it&rsquo;s invalid, return empty</li><li>Else append the last character</li></ul></li><li>Return result</li></ul><p>Time: O(Nlog(A)) - N is length of string, A is alphabet size, Space: O(A)</p><h4 id=49-group-anagrams><a href=https://leetcode.com/problems/group-anagrams/>49. Group Anagrams</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Character Stats</p><p><strong>Steps</strong></p><ul><li>Declare groups, {key: encoded character frequency, value: strings}</li><li>Iterate all strings<ul><li>Calculate the character frequency (Or use a 26 length array)</li><li>Turn frequency to string</li><li>Update groups</li></ul></li><li>Flatten the groups</li></ul><p>Time: O(N * K), Space: O(N * K), K is string length</p><h4 id=3-longest-substring-without-repeating-characters><a href=https://leetcode.com/problems/longest-substring-without-repeating-characters/>3. Longest Substring Without Repeating Characters</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Sliding Window</p><p><strong>Intuition</strong></p><ul><li>Use the sliding window technique to maintain a substring without repeating characters while iterating through the string.<br>If a character is repeated, move the left pointer of the window forward to exclude the previous occurrence.</li></ul><p><strong>Steps</strong></p><ul><li>Use two pointers, <code>left</code> and <code>right</code> start at <code>0</code></li><li>Declare hash map to record the last seen character index, {character, index}</li><li>Iterate the string (with <code>right</code>)<ul><li>If current character is seen and in range of the window<ul><li>Update <code>left</code> to next index of the seen character index</li></ul></li><li>Update <code>lastSeen</code> of current position (<code>right</code>)</li><li>Update max length</li></ul></li><li>Return max length</li></ul><p>Time: O(N), Space: O(A), where A is the size of the character size</p><h4 id=560-subarray-sum-equals-k><a href=https://leetcode.com/problems/subarray-sum-equals-k/>560. Subarray Sum Equals K</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Prefix Sum</p><p><strong>Intuition</strong></p><ul><li>Because we want to find <em>subarray</em> sum, think of prefix sum<ul><li>If $sum[j] - sum[i] = k$, then subarray <code>nums[i+1: j]</code> sums to k</li></ul></li></ul><p><strong>Steps</strong></p><ul><li>Use a hash table to store {Prefix Sum Value -> Count}<ul><li>Base case: Prefix 0 occurs once</li></ul></li><li>Iterate numbers<ul><li>If find <code>Current prefix sum - k</code> in the hash table, accumulate count</li><li>Update Prefix Sum hash table</li></ul></li></ul><p>Time: O(N), Space: O(N)</p><h4 id=974-subarray-sums-divisible-by-k><a href=https://leetcode.com/problems/subarray-sums-divisible-by-k/>974. Subarray Sums Divisible by K</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Prefix Sum</p><p><strong>Intuition</strong></p><ul><li>If the sum of a subarray(i, j) is divisible by k, then: <code>prefix[j + 1] % k == prefix[i] % k</code></li></ul><p><strong>Steps</strong></p><ul><li>Declare hash map to count the modulo<ul><li>Init <code>map[0] = 1</code> to handle the case where the subarray starts from 0</li></ul></li><li>Iterate the numbers<ul><li>Update prefix sum</li><li>Calculate modulo</li><li>Count up how many times this modulo seen before</li><li>Count up the current modulo</li></ul></li></ul><p>Time: O(N), Space: O(K)</p><h4 id=1010-pairs-of-songs-with-total-durations-divisible-by-60><a href=https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/>1010. Pairs of Songs With Total Durations Divisible by 60</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Modulo</p><p><strong>Intuition</strong></p><ul><li>No return order required, not duplicated position. So just simply find all the possible combinations</li></ul><p><strong>Steps</strong></p><ul><li>Use a 60 size array for the occurance of different modulos</li><li>Three cases<ul><li>0 + 0</li><li>30 + 30</li><li>i + (60 - i), where i in [1, 30)</li></ul></li></ul><p>Time: O(N), Space: O(K)</p><h4 id=116-populating-next-right-pointers-in-each-node><a href=https://leetcode.com/problems/populating-next-right-pointers-in-each-node/>116. Populating Next Right Pointers in Each Node</a></h4><ul><li>Use BFS, traverse from top to bottom, left to right, ignore the right most node in each layer</li><li>Make use of <code>next</code> pointer. Two while loop, outer use leftMost, inner use head</li></ul><h4 id=146-lru-cache><a href=https://leetcode.com/problems/lru-cache>146. LRU Cache</a></h4><p><img src="https://img.shields.io/badge/Meta-%230467DF.svg?style=for-the-badge&amp;logo=Meta&amp;logoColor=white" alt=Meta><br><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Doubly Linked-List</p><p><strong>Observations</strong></p><ul><li>Both <code>get()</code> and <code>put()</code> are considered &ldquo;used&rdquo;, So we use doubly linked list for efficient ordering</li><li>We can&rsquo;t use index to manipulate value in linked list, so we create a hash map {key, iterator}</li></ul><p><strong>Steps</strong></p><ul><li>Declare a doubly linked list (of {key, value} pairs) for the underlying container, front is the most used, end is the least used</li><li>Declare a hash map {key, iterator} to fast access data</li><li><code>get()</code><ul><li>If not exist in map, return -1</li><li>If exist<ul><li>Use the iterator to get value</li><li>Move this {key, value} to the front<ul><li>Remove the iterator</li><li>Push new node to the front</li><li>Update map</li></ul></li></ul></li></ul></li><li><code>put()</code><ul><li>If exist in map<ul><li>Use iterator to remove the existed one</li></ul></li><li>If not exist in map<ul><li>If exceed capacity<ul><li>Get the last key</li><li>Pop last element</li><li>Remove from map</li></ul></li></ul></li><li>Push new node to the front</li><li>Update map</li></ul></li></ul><p>Time: O(1), Space: O(N)</p><h4 id=347-top-k-frequent-elements><a href=https://leetcode.com/problems/top-k-frequent-elements>347. Top K Frequent Elements</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Min-Heap</p><p><strong>Intuition</strong></p><ul><li>Use min heap to track the k largest number by contraint the size to k</li></ul><p><strong>Steps</strong></p><ul><li>Declare hash map to store the number frequency</li><li>Iterate the hash map<ul><li>Push current {count, number} pair to min heap</li><li>If min heap size is more than k, pop the top (smallest one)</li></ul></li><li>Build results</li></ul><p>Time: O(NLog(K)), Space: O(N)</p><h4 id=973-k-closest-points-to-origin><a href=https://leetcode.com/problems/k-closest-points-to-origin/>973. K Closest Points to Origin</a></h4><p><strong>Keyword</strong>: Max-Heap</p><p><strong>Intuition</strong></p><ul><li>&ldquo;K Closest Points to Origin&rdquo;, meaning the smallest K distances, use max heap</li></ul><p><strong>Steps: Max-Heap</strong></p><ul><li>Declare max heap: Element is [distance -> point]</li><li>Iterate points<ul><li>Push new distance</li><li>If exceed k, pop heap</li></ul></li></ul><p>Time: O(NLog(K)), Space: O(K)</p><p><strong>Steps: Quick-Select</strong></p><ul><li>Use std::nth_element</li></ul><p>Time: O(N) for average, O($N^2$), Space: O(1)</p><h4 id=1762-buildings-with-an-ocean-view><a href=https://leetcode.com/problems/buildings-with-an-ocean-view/>1762. Buildings With an Ocean View</a></h4><p><strong>PROBLEM STATEMENT</strong></p><p>There are <code>n</code> buildings in a row, indexed from <code>0</code> to <code>n-1</code>. Each building has a height represented by <code>heights[i]</code>.</p><p>A building has an ocean view if all buildings to its right have a smaller height.</p><p>Return a list of indices of buildings that have an ocean view in increasing order.</p><p><strong>Observations</strong></p><ul><li>Start from the rightmost building, which guaranteed ocean view.</li></ul><p><strong>Steps</strong></p><ul><li>Iterate from the right, and track the so far tallest<ul><li>If <code>newHeight > maxHeight</code>, update max, save index</li></ul></li><li>Reverse result</li></ul><p><strong>Solution</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> findBuildings(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> heights) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Track the highest building seen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>auto</span> maxHeight{<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Start from the right most building (gurantee ocean view)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> heights.size() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> height <span style=color:#f92672>=</span> heights[i]; height <span style=color:#f92672>&gt;</span> maxHeight) {
</span></span><span style=display:flex><span>                res.push_back(i);
</span></span><span style=display:flex><span>                maxHeight <span style=color:#f92672>=</span> height;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>reverse(res.begin(), res.end());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Time: O(N), Space: O(1)</p><h4 id=986-interval-list-intersections><a href=https://leetcode.com/problems/interval-list-intersections/>986. Interval List Intersections</a></h4><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Steps</strong></p><ul><li>Declare two pointers, start from the begining</li><li>Loop<ul><li>An intersection exists if $max(start_1, start_2) \leq min(end_1, end_2)$</li><li>Move the pointer from the list where the interval ends first (smaller ending).</li></ul></li></ul><p>Time: O(N+M), Space: O(1)</p><h4 id=138-copy-list-with-random-pointer><a href=https://leetcode.com/problems/copy-list-with-random-pointer/>138. Copy List with Random Pointer</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>MEDIUM BUT HARD</strong></p><p><strong>Keyword</strong>: Linked-List</p><p><strong>Intuition</strong></p><ul><li>The easiest way is to use an extra hash map to store {Old Node -> New Node}</li><li>The optimal solution is not easy to come up</li></ul><p><strong>Approach: Hash map</strong></p><ul><li>Declare hash map {Old Node -> New Node}</li><li>1st pass: Copy node one by one, and update hash map</li><li>2nd pass: Iterate the hash map, link next and random node of new node</li></ul><p><strong>Approach: Interleaving</strong></p><ul><li>1st pass: Copy each node right after the original node (don&rsquo;t care random pointer)</li><li>2nd pass: Link random pointer in the copied nodes</li><li>3rd pass: Separate the copied nodes and original nodes, and recover the original nodes links.<ul><li>Use dummy header</li></ul></li></ul><p>Time: O(N), Space: O(1)</p><h4 id=23-merge-k-sorted-lists><a href=https://leetcode.com/problems/merge-k-sorted-lists/>23. Merge k Sorted Lists</a></h4><p><img src="https://img.shields.io/badge/Meta-%230467DF.svg?style=for-the-badge&amp;logo=Meta&amp;logoColor=white" alt=Meta><br><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Min-Heap</p><p><strong>Steps</strong></p><ul><li>Declare a min heap</li><li>Iterate lists<ul><li>Insert starting nodes into min heap, so list with smallest node starts first</li></ul></li><li>Create dummy node</li><li>Loop<ul><li>Pop the smallest (pop)</li><li>Link next to this node</li><li>Move to this node</li><li>Push to next of current node (if there is)</li></ul></li><li>Return dummy&rsquo;s next</li></ul><p>Time: O(NLog(K)), Space: O(k)</p><h4 id=339-nested-list-weight-sum><a href=https://leetcode.com/problems/nested-list-weight-sum/>339. Nested List Weight Sum</a></h4><p><strong>PROBLEM STATEMENT</strong></p><p>You are given a nested list of integers. Each element is either:</p><ul><li>An integer, or</li><li>A list containing other integers and/or nested lists.</li></ul><p>The depth of an integer is the number of lists it is inside.</p><p>Return the sum of all integers, weighted by their depth.</p><p>Example 1</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Input
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>nestedList <span style=color:#f92672>=</span> <span style=color:#a6e22e>[[1, 1], 2, [1, 1]]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Explanation
</span></span></span><span style=display:flex><span><span style=color:#75715e>// The &#39;1&#39;s are at depth 2, contributing 4*2=8
</span></span></span><span style=display:flex><span><span style=color:#75715e>// The &#39;2&#39; is at depth 1, contributing 2*1=2
</span></span></span></code></pre></div><p><strong>Keyword</strong>: DFS</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// LeetCode provided interface
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NestedInteger</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> isInteger() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getInteger</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>NestedInteger<span style=color:#f92672>&gt;&amp;</span> getList() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// DFS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> depthSum(std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>NestedInteger<span style=color:#f92672>&gt;&amp;</span> nestedList, <span style=color:#66d9ef>int</span> depth <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> sum{<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> nested: nestedList) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (nested.isInteger()) {
</span></span><span style=display:flex><span>                sum <span style=color:#f92672>+=</span> nested.getInteger() <span style=color:#f92672>*</span> depth;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                sum <span style=color:#f92672>+=</span> depthSum(nested.getList(), depth <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> sum;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Time: O(N), Space: O(Depth)</p><h4 id=346-moving-average-from-data-stream><a href=https://leetcode.com/problems/moving-average-from-data-stream/>346. Moving Average from Data Stream</a></h4><p><strong>PROBLEM STATEMENT</strong></p><p>You need to implement a class <code>MovingAverage</code> that calculates the moving average of the last <code>size</code> elements in a data stream.</p><p><strong>Keyword</strong>: Sliding Window</p><p><strong>Intuition</strong></p><ul><li>Classic sliding window, use queue</li><li>Track current sum while manipulating(add/remove) data</li></ul><p><strong>Solution</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;queue&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MovingAverage</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> MovingAverage(<span style=color:#66d9ef>int</span> size)<span style=color:#f92672>:</span> _size(size), _sum(<span style=color:#ae81ff>0.</span>) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>next</span>(<span style=color:#66d9ef>int</span> val) {
</span></span><span style=display:flex><span>        q.push(val);
</span></span><span style=display:flex><span>        sum <span style=color:#f92672>+=</span> val;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (q.size() <span style=color:#f92672>&gt;</span> _size) {
</span></span><span style=display:flex><span>            sum <span style=color:#f92672>-=</span> q.front();
</span></span><span style=display:flex><span>            q.pop();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> sum <span style=color:#f92672>/</span> q.size();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> _q;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> _sum;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> _size;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Time: O(1), Space: O(capacity)</p><h4 id=282-expression-add-operators><a href=https://leetcode.com/problems/expression-add-operators/>282. Expression Add Operators</a></h4><p><strong>HARD!!!</strong></p><h4 id=670-maximum-swap><a href=https://leetcode.com/problems/maximum-swap/>670. Maximum Swap</a></h4><p><strong>Keyword</strong>: Greedy</p><p><strong>Observations</strong></p><ul><li>Swap <strong>at most once</strong></li><li>For each digit, we want to <strong>swap with the largest on the right</strong></li><li>Among all the largest one the right, we want <strong>the rightmost digit</strong></li></ul><p><strong>Steps</strong></p><ul><li>Convert the number to string</li><li>Declare a std::array to store <em>last occured index of digit</em></li><li>Iterate string<ul><li>From biggest digit (9) to current digit<ul><li>If last occurred to the right (last occur index > i), swap and return</li></ul></li></ul></li></ul><p>Time: O(N), Capacity: O(1)</p><p><strong>Variant</strong></p><ul><li>Buil the second largest number<ul><li>Declare list of 10 to calculate the freqs</li><li>Build the largest number first</li><li>Iterate from right to left, swap the first number pair that&rsquo;s not equal, similar to <a href=/topics/interview/leetcode-top-interview/#31-next-permutation>31. Next Permutation</a></li></ul></li></ul><h4 id=31-next-permutation><a href=https://leetcode.com/problems/next-permutation/>31. Next Permutation</a></h4><p><strong>MEDIUM, BUT HARD</strong></p><p><strong>Intuition</strong></p><ul><li>Convert the digits to number is better to understand</li><li>The problem is equivalent to &ldquo;<strong>Find the next larger number</strong>&rdquo;</li><li>The digits on the right contribute less to the final number, so <strong>iterate from right to left</strong></li></ul><p><strong>Steps</strong></p><ul><li>Traverse from right to left to find the valley where $nums[i] &lt; nums[i-1]$</li><li>Traverse again from right to left to find the <strong>next higher digit</strong> after the valley, then swap.</li><li>Reverse the sequence from <code>i+1</code> to the end</li></ul><p><strong>Variant</strong></p><ul><li>Previous Permutation<ul><li>Reuse the code structure, change the following<ul><li>Instead of finding a valley, we find a peak</li><li>Instead of finding next higher to the right, we <strong>find next lower after the peak</strong></li></ul></li></ul></li></ul><h4 id=76-minimum-window-substring><a href=https://leetcode.com/problems/minimum-window-substring/>76. Minimum Window Substring</a></h4><p><strong>HARD</strong></p><p><strong>Keyword</strong>: Two-Pointer, Sliding Window</p><p><strong>Intuition</strong></p><ul><li>Count the frequency in <code>template</code></li><li>Using sliding window to expand and contract as needed</li><li>Track how many characters have met required count</li></ul><p><strong>Steps</strong></p><ul><li>Declare template frequency map: {char -> int}</li><li>Count the frequency in <code>template</code></li><li>Declare sliding window<ul><li>Window frequency map: {char -> int}</li><li>Window start</li><li>Window length</li></ul></li><li>Two pointers loop. <code>right</code> as expand iterator, <code>left</code> as contract iterator<ul><li>Get current <code>right</code>, and move on (expand)<ul><li>If this character is needed<ul><li>Window frequency increase</li><li>If the frequency is same, match counter increase</li></ul></li></ul></li><li>If match counter is same as need (meaning we have all the characters, but frequency may not correct), try to contract<ul><li>If current length is smaller, update min window length</li><li>Get current <code>left</code>, and move on (expand)<ul><li>If this character is needed<ul><li>If the frequency is same, match counter decrease</li><li>Window frequency decrease</li></ul></li></ul></li></ul></li></ul></li><li>Return substring</li></ul><p>Time: O(len(string), len(template)), Space: O(len(template))</p><h4 id=56-merge-intervals><a href=https://leetcode.com/problems/merge-intervals/>56. Merge Intervals</a></h4><p><img src="https://img.shields.io/badge/Meta-%230467DF.svg?style=for-the-badge&amp;logo=Meta&amp;logoColor=white" alt=Meta><br><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Intervals</p><p><strong>Steps</strong></p><ul><li>Sort the input intervals <strong>by the mins</strong></li><li>Iterate the sorted intervals<ul><li>If result is empty, append current interval</li><li>If the end of last interval in results is less than beginning of current interval, append current interval</li><li>Else, update the end of last interval in results</li></ul></li></ul><p>Time: O(NLog(N)), Space: O(N)</p><h4 id=252-meeting-rooms-i><a href=https://leetcode.com/problems/meeting-rooms/>252. Meeting Rooms I</a></h4><p><strong>PROBLEM STATEMENT</strong></p><p>Given an array of meeting time intervals <code>intervals</code> where <code>intervals[i] = [start_i, end_i]</code>, determine if a person can attend all meetings (i.e., no overlapping meetings).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> canAttendMeetings(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> intervals) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Sort based on the starting time
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>sort(intervals.begin(), intervals.end());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Iterate if any start smaller than previous end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (size_t i{<span style=color:#ae81ff>1</span>}};i <span style=color:#f92672>&lt;</span> intervals.size(); <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (intervals[i][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;</span> intervals[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>]) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=253-meeting-rooms-ii><a href=https://leetcode.com/problems/meeting-rooms-ii/>253. Meeting Rooms II</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>PROBLEM STATEMENT</strong></p><p>Given an array of meeting time intervals <code>intervals</code> where <code>intervals[i] = [start_i, end_i]</code>, return the minimum number of conference rooms required.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> minMeetingRooms(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> intervals) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (intervals.empty()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Sort based on starting point
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>sort(intervals.begin(), intervals.end());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Use min heap to track the ending, as well as the ongoing meetings
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>priority_queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>, std<span style=color:#f92672>::</span>greater<span style=color:#f92672>&gt;</span> minHeap;
</span></span><span style=display:flex><span>        minHeap.push(intervals[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (size_t i{<span style=color:#ae81ff>1</span>}; i <span style=color:#f92672>&lt;</span> intervals.size(); <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If current meeting starts after (larger than) the earliest ending time, reuse room
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (intervals[i][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&gt;=</span> minHeap.top()) {
</span></span><span style=display:flex><span>                minHeap.pop();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            minHeap.push(intervals[i][<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> minHeap.size();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Time: O(nlogn) + O(nlogn)</p><h4 id=2402-meeting-rooms-iii><a href=https://leetcode.com/problems/meeting-rooms-iii/>2402. Meeting Rooms III</a></h4><p><strong>HARD</strong></p><h4 id=75-sort-colors><a href=https://leetcode.com/problems/sort-colors/>75. Sort Colors</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><ul><li>We need to partition the array into 3 parts</li><li>Because in-place sort, so we need to swap</li><li>Use two pointers<ul><li><code>low</code> tracks 0s, <code>mid</code> tracks 1s, <code>high</code> tracks 2s</li><li><code>mid</code> traverse</li><li>check <code>nums[mid]</code></li></ul></li><li>Terminate when <code>mid</code> surpasses <code>high</code></li></ul><h4 id=825-friends-of-appropriate-ages><a href=https://leetcode.com/problems/friends-of-appropriate-ages/>825. Friends Of Appropriate Ages</a></h4><ul><li>Read the condition, and narrow down the real condition<ul><li>Condition 1 defines the min age</li><li>Condition 2 defines the max age</li><li>Special case is when max and min equal, $age = age * 0.5 + 7$, so min valid age is 14 + 1</li></ul></li><li>age is between 1&mldr;120</li><li>Use age range to try Condition 3, find out it&rsquo;s useless</li><li>For each age, we need to find the people count in valid range</li><li>Use count and prefix sum on ages</li></ul><h4 id=51-n-queens><a href=https://leetcode.com/problems/n-queens/>51. N-Queens</a></h4><p><strong>HARD</strong></p><h4 id=79-word-search><a href=https://leetcode.com/problems/word-search/>79. Word Search</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: DFS on Matrix, Backtracking</p><p><strong>Intuition</strong></p><ul><li>Because we need to search to the end of the word to find a word, so use DFS</li></ul><p><strong>Steps</strong></p><ul><li>Define DFS<ul><li>Carriers: <code>board</code>, current row&amp;col, <code>word</code>, current index</li><li>Return: Find word or not</li><li>Terminate Condition:<ul><li>Current index equal to &lsquo;word` size, return true</li><li>Not in range, and character of current coord is not the same as word current index, return false</li></ul></li><li>Backtrack<ul><li>Mark current character visited</li><li>Explore 4 adjacent directions, and next index</li><li>Recover current character</li></ul></li><li>Return found</li></ul></li><li>Iterate through <code>board</code>, search from the first letter</li></ul><h4 id=283-move-zeroes><a href=https://leetcode.com/problems/move-zeroes/>283. Move Zeroes</a></h4><ul><li>Move in place, so we need to use two pointers, and swap</li><li><code>slow</code> tracks where the next non zero pointer should go</li><li><code>fast</code> find the non-zero elements</li><li>If found, swap</li></ul><h3 id=two-sums>Two Sums</h3><h4 id=1-two-sums><a href=https://leetcode.com/problems/two-sum/>1. Two Sums</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Hash</p><p><strong>Steps</strong></p><ul><li>Use hash map to store the visited value and its index</li><li>Iterate the numbers<ul><li>If <code>target - nums[i]</code> exists in hashtable, append to result</li><li>Else insert new pair</li></ul></li></ul><h4 id=167-two-sums-ii><a href=https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/>167. Two Sums II</a></h4><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Intuition</strong></p><ul><li>The difference with <a href=/topics/interview/leetcode-top-interview/#1-two-sums>Two Sums</a> is the input array is sorted</li><li>We can use two pointer method to find the two sums pair</li><li>The other difference is given array is <strong>1-indexed</strong></li></ul><p><strong>Steps</strong></p><ul><li>Two pointers, <code>left</code> at 0, <code>right</code> at end</li><li>While <code>left</code> and <code>right</code> don&rsquo;t cross<ul><li>If current sum is target, return index</li><li>If current sum is less, move left</li><li>If current sum is more, move right</li></ul></li></ul><h4 id=15-3sums><a href=https://leetcode.com/problems/3sum/>15. 3Sums</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Intuition</strong></p><ul><li>Need to return <strong>all</strong> triplets</li><li>Fixed one number, and the rest is <a href=/topics/interview/leetcode-top-interview/#167-two-sums-ii>Two Sums II</a></li></ul><p><strong>Steps</strong></p><ul><li>Sort the numbers</li><li>Iterate the numbers<ul><li>Skip if current number is dupliacted (use the first one in duplicated sequence)</li><li>Break if current number is positive (not possible to find triplet in the rest sorted array)</li><li>Start <a href=/topics/interview/leetcode-top-interview/#167-two-sums-ii>Two Sums II</a>, with<ul><li><code>target = -num[i]</code></li><li><code>left = i + 1</code>, <code>right = end</code></li><li>If less &mldr;</li><li>If more &mldr;</li><li>If equal, remember to keep moving <code>left</code> and <code>right</code> until no duplicated</li></ul></li></ul></li></ul><p>Sorting: O(nlogn)<br>Searching: O(n^2)</p><h4 id=18-4sum><a href=https://leetcode.com/problems/4sum/>18. 4Sum</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Binary Search</p><p><strong>Inuition</strong></p><ul><li>Similar to <a href=/topics/interview/leetcode-top-interview/#15-3sums>3Sum</a>, but try to fix two positions</li><li><strong>BE CAREFUL</strong> of<ul><li>Duplicated numbers</li><li>Sum overflow</li></ul></li></ul><p><strong>Steps</strong></p><ul><li>Sort the numbers</li><li>First index loop<ul><li>Skip the duplicated numbers</li><li>Second index loop<ul><li>Skip the duplicated numbers</li><li>Binary Search<ul><li><code>left</code>: j + 1, <code>right</code>: n - 1</li><li>Start loop<ul><li>If sum == target, append to results, skip duplicated numbers</li><li>If sum &lt; target, move left</li><li>If sum > target, move right</li></ul></li></ul></li></ul></li></ul></li><li>Return results</li></ul><p>Time: O(n^3)</p><h4 id=827-making-a-large-island><a href=https://leetcode.com/problems/making-a-large-island/>827. Making A Large Island</a></h4><p><strong>HARD</strong></p><p><strong>Keywords</strong>: DFS</p><p><strong>Intuition</strong></p><ul><li>When we change a cell from sea into land, it also connect the neighbor lands together</li><li>Label all islands with unique ids, and save their size<ul><li>ID should starts from 2, because 0 is for water, 1 is for OG land(a.k.a. unvisited land)</li></ul></li><li>Try to turn each water into land, and calculate the new island size, update max island size<ul><li>Use <code>set</code> to avoid duplicated</li></ul></li></ul><p><strong>Steps</strong></p><ul><li>Declare hash map, {Island Id -> Island Size}<ul><li>Id starts from 2</li></ul></li><li>1st pass: Iterate cells, use DFS calculate size.</li><li>DFS function: return size, log visited (with Id), carry the Island size map<ul><li>If not in bound, or not unvisited land, return 0</li><li>If in bound<ul><li>Update Id</li><li>Explore 4 directions, (size from 1)</li></ul></li></ul></li><li>2nd pass: Find current max island size</li><li>3rd pass: Iterate cells, locate water and try to fill<ul><li>Explore 4 directions, and add neighbor</li><li>Sum up to calculate new size</li><li>Update new max size</li></ul></li></ul><p>Time: O($N^2$), Space: O($N^2$)</p><h4 id=1004-max-consecutive-ones-iii><a href=https://leetcode.com/problems/max-consecutive-ones-iii/>1004. Max Consecutive Ones III</a></h4><p><strong>Keywords</strong>: Sliding Windows</p><p><strong>Intuition</strong></p><ul><li>The problem is equivalent to <strong>find the widest window with at most <code>k</code> zeros</strong></li></ul><p><strong>Steps</strong></p><ul><li>Two pointers, iterate <code>right</code>, slide control with <code>left</code></li><li><code>zeroCount</code> to count zeros, <code>maxLen</code> to track current max length</li><li>Iterate numbers<ul><li>If zero, count up</li><li>If more than <code>k</code> zeros in the window, move <code>left</code></li><li>Update window length</li></ul></li></ul><p>Time: O(N), Space: O(1)</p><h4 id=65-valid-number><a href=https://leetcode.com/problems/valid-number/>65. Valid Number</a></h4><p><strong>HARD</strong></p><p><strong>Intuition</strong></p><ul><li>Nothing special, consider the following<ul><li>Start with optional sign?</li><li>Integer or decimal?</li><li>Optional <strong>exponent followed by an integer(even it&rsquo;s legit in math, not here)</strong></li></ul></li></ul><p><strong>Steps</strong></p><ul><li>If start with sign, move on</li><li>Iterate the following<ul><li>Is numberic? Log, and move on</li><li>Is dot? Met dot or exponent before?<ul><li>Yes -> Quit</li><li>No -> Log, and move on</li></ul></li><li>Is exp? Met exponent or no numberic before?<ul><li>Yes -> Quit</li><li>No -> Log, and <strong>reset meet numberic</strong>, and move on.<ul><li>Move on if followed by a sign</li></ul></li></ul></li><li>Other -> Quit</li></ul></li><li>Return Meet numberic or not</li></ul><h4 id=34-find-first-and-last-position-of-element-in-sorted-array><a href=https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/>34. Find First and Last Position of Element in Sorted Array</a></h4><p><strong>Keyword</strong>: Binary search</p><p><strong>Intuition</strong></p><ul><li>We can do a binary search to land in the target set, then expand outward</li><li><strong>BUT!!!</strong> That works only when we know targets is a small cluster, The worst cast is that, all the values are target, then time complexity is O(N)</li><li>So a more general solution would be <strong>binary search twice</strong>, don&rsquo;t stop after we find the target, continue search left and right half</li></ul><p><strong>Steps: Binary Search Twice</strong></p><ul><li>Custom binary search<ul><li>When target is found<ul><li>If want to find low bound, <code>right = mid - 1</code></li><li>If want to find high bound, <code>left = mid + 1</code></li></ul></li><li>We could even use template</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span> _isLow<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> findBound(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums, <span style=color:#66d9ef>int</span> target) {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Use case
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>auto</span> kLow{true};
</span></span><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>auto</span> kHigh{false};
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>constexpr</span> (kLow) {
</span></span><span style=display:flex><span>    right <span style=color:#f92672>=</span> mid <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    left <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>return</span> {findBound<span style=color:#f92672>&lt;</span>kLow<span style=color:#f92672>&gt;</span>(...), findBound<span style=color:#f92672>&lt;</span>kHigh<span style=color:#f92672>&gt;</span>(...)};
</span></span></code></pre></div><h4 id=249-group-shifted-strings><a href=https://leetcode.com/problems/group-shifted-strings/>249. Group Shifted Strings</a></h4><p><strong>PROBLEM STATEMENT</strong></p><p>We are given an array of strings. Two strings are shifted versions of each other if:</p><ul><li>You can shift each character in one string by the same number of positions in the alphabet to get the other string.</li><li>For example, &ldquo;abc&rdquo; → &ldquo;bcd&rdquo; → &ldquo;cde&rdquo; are all shifted versions.</li><li>More example, &ldquo;ace&rdquo; → &ldquo;ceg&rdquo;</li></ul><p>Task: Group all strings that are shifted versions of each other.</p><p><strong>Intuition</strong></p><ul><li>All the strings in a same group share same &ldquo;pattern&rdquo;</li><li>&ldquo;Shift pattern&rdquo; can be calculated by a vector of shift from the first character<ul><li>&ldquo;abc&rdquo; -> <code>[1, 1](by b-a, c-b)</code></li><li>&ldquo;bcd&rdquo; -> <code>[1, 1](by c-b, d-c)</code></li></ul></li><li>We can make it more robust, if we shift all the strings to &ldquo;a&rdquo;</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;&gt;</span> groupStrings(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;&amp;</span> strings) {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>unordered_map<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string, std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;&gt;</span> patternToStrings;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> str: strings) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> pattern <span style=color:#f92672>=</span> calcPattern(str);
</span></span><span style=display:flex><span>            patternToStrings[pattern].push_back(str);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;&gt;</span> res;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> [_, strings]<span style=color:#f92672>:</span> patternToStrings) {
</span></span><span style=display:flex><span>            res.push_back(strings);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string calcPattern(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> s) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Normalize to start from &#39;a&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> shift <span style=color:#f92672>=</span> s[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;a&#39;</span>;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>string pattern;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> ch: s) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Normalize -&gt; calculate diff -&gt; convert to char
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            pattern <span style=color:#f92672>+=</span> (ch <span style=color:#f92672>-</span> shift <span style=color:#f92672>+</span> <span style=color:#ae81ff>26</span>) <span style=color:#f92672>%</span> <span style=color:#ae81ff>26</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;a&#39;</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> pattern;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=2-add-two-numbers><a href=https://leetcode.com/problems/add-two-numbers/>2. Add Two Numbers</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Linked-List</p><p><strong>Intuition</strong></p><ul><li>Since numbers are stored in reverse order, adding them from head to tail is same as adding numbers</li></ul><p><strong>Steps</strong></p><ul><li>Declare a dummy pointer</li><li>Declare <code>curr</code> and <code>carrier</code></li><li>Loop while <code>l1</code> and <code>l2</code> both valid</li><li>Loop either <code>l1</code> or <code>l2</code> valid</li><li>Append carrier node if it exists</li></ul><h4 id=33-search-in-rotated-sorted-array><a href=https://leetcode.com/problems/search-in-rotated-sorted-array/>33. Search in Rotated Sorted Array</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Binary Search</p><p><strong>Intuition</strong></p><ul><li>Even though rotated, one half of it is still sorted (ascendingly), we can use modified binary search<ul><li>Check which side is sorted</li><li>Narrow search</li></ul></li></ul><p><strong>Steps</strong></p><ul><li><code>left</code> at 0, <code>right</code> at end</li><li>While <code>left &lt;= right</code><ul><li>Calculate <code>mid</code></li><li>If <code>nums[mid] == target</code>, return <code>mid</code></li><li>If <code>nums[left] &lt;= nums[mid]</code> (left side sorted)<ul><li>If <code>target</code> also in left range, move right</li><li>Else, move left</li></ul></li><li>Else (right side sorted)<ul><li>If <code>target</code> also in right range, move left</li><li>Else, move right</li></ul></li></ul></li><li>Return invalid</li></ul><h4 id=19-remove-nth-node-from-end-of-list><a href=https://leetcode.com/problems/remove-nth-node-from-end-of-list/>19. Remove Nth Node From End of List</a></h4><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Intuition</strong></p><ul><li>For singly linked link, we can&rsquo;t access element by index, instead we have to count the move.</li><li>The distance between the earlier pointer and the later pointer keeps constant</li></ul><p><strong>Steps</strong></p><ul><li><code>first</code> and <code>second</code> pointer start from <code>dummy</code> node</li><li>Move <code>first</code> for <code>n+1</code> steps forward</li><li>Then move both together until <code>first</code> hits the end</li><li><code>second->next</code> is the one to remove</li></ul><p><strong>Note</strong></p><ul><li>Why <code>dummy</code> node?</li><li>Why move <code>n+1</code> steps?<ul><li>To remove the nth from the end, we need to arrive at the one before last nth node</li><li>The <code>first</code> pointer stops at pos n</li></ul></li></ul><h4 id=282-expression-add-operators-1><a href=https://leetcode.com/problems/expression-add-operators/>282. Expression Add Operators</a></h4><p><strong>HARD</strong></p><h4 id=498-diagonal-traverse><a href=https://leetcode.com/problems/diagonal-traverse/>498. Diagonal Traverse</a></h4><p><strong>Observation</strong></p><ul><li>The <code>row + col</code> of element on diagonal is the same.<ul><li>Origin at top left corner, x-axis to leftward, y-axis downward so diagonal is y = -x + k</li></ul></li><li>There are in total <code>m + n - 1</code> directions (Easy to visualize)</li></ul><p><strong>Steps</strong></p><ul><li>Iterate <code>m + n - 1</code> directions, <strong>from top to bottom, left to right</strong><ul><li>If even, go up-right<ul><li>Locate start point (left/bottom edge), move</li></ul></li><li>If odd, go down-left<ul><li>Locate start point (right/top edge), move</li></ul></li></ul></li></ul><p><strong>Note</strong></p><ul><li>How to understand <code>d</code>? e.g. $m=5, n=7$</li></ul><pre tabindex=0><code class=language-math data-lang=math>\begin{matrix}
0 &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 \\
1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 \\
2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 \\
3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 &amp; 9 \\
4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 &amp; 9 &amp; 10
\end{matrix}
</code></pre><h4 id=1539-kth-missing-positive-number><a href=https://leetcode.com/problems/kth-missing-positive-number/>1539. Kth Missing Positive Number</a></h4><p><strong>Keyword</strong>: Binary search</p><p><strong>Observations</strong></p><ul><li>For index <code>i</code>, the num of missing number before arr[i] is <code>arr[i] - i - 1</code><ul><li>If no missing, number <code>arr[i]</code> should be at index <code>arr[i] - 1</code>, but now at index <code>i</code>, so missing <code>arr[i] - i - 1</code></li></ul></li><li>We could use line scan. In case of large n, we use binary search</li></ul><p><strong>Steps</strong></p><ul><li><code>left</code> at 0, <code>right</code> at n</li><li>Calculate <code>mid</code>, and missing at <code>mid</code><ul><li>If less than <code>k</code>, move <code>left</code></li><li>Else, move <code>right</code></li></ul></li></ul><p><strong>Notes</strong></p><ul><li><code>while</code> condition, and how to update <code>left</code> and <code>right</code></li></ul><h4 id=41-first-missing-positive><a href=https://leetcode.com/problems/first-missing-positive/>41. First Missing Positive</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Array</p><p><strong>Intuition</strong></p><ul><li>Goal is to find the <strong>smallest positive integer not present</strong> in the array</li><li>Try to place each number in its correct index if it&rsquo;s in range [1, n]. e.g. we want <code>nums[i] == i + 1</code></li></ul><p><strong>Steps</strong></p><ul><li>Iterate all numbers<ul><li>For the numbers in range [1, n], if <code>nums[i] != i + 1</code>, swap to correct position</li></ul></li><li>Iterate all numbers from left to right again to find out which number doesn&rsquo;t satisfy <code>nums[i] == i + 1</code>, return <code>i + 1</code></li><li>Or return <code>n + 1</code></li></ul><h4 id=708-insert-into-a-sorted-circular-linked-list><a href=https://leetcode.com/problems/insert-into-a-sorted-circular-linked-list/>708. Insert into a Sorted Circular Linked List</a></h4><p><strong>PROBLEM STATEMENT</strong></p><h4 id=636-exclusive-time-of-functions><a href=https://leetcode.com/problems/exclusive-time-of-functions/>636. Exclusive Time of Functions</a></h4><p><strong>Keyword</strong>: Stack</p><p><strong>Steps</strong></p><ul><li>Write a log parser</li><li>Iterate the logs while tracking the previous timestamp to know how much time the top function on the stack run since last event<ul><li>If it&rsquo;s a &ldquo;start&rdquo;, push into the stack, calculate the running time of current function (if there&rsquo;s any), update <code>prevTime</code></li><li>If it&rsquo;s a &ldquo;start&rdquo;, calculate the running time of current function, and pop stack, update <code>prevTime</code></li></ul></li></ul><p>Time: O(N), Space: O(N)</p><h4 id=523-continuous-subarray-sum><a href=https://leetcode.com/problems/continuous-subarray-sum/>523. Continuous Subarray Sum</a></h4><p><strong>Keyword</strong>: Prefix Sum</p><p><strong>Intuition</strong></p><ul><li>&ldquo;Subarray sum&rdquo;, probably use prefix sum</li><li><code>sum[i:j] = sum[j] - sum [i]</code> is divisible by <code>k</code>, that means <code>sum[i] % k == sum[j] % k</code></li></ul><p><strong>Steps</strong></p><ul><li>Use a hash table to store the Index -> mod<ul><li>Remember to add edge case {0: -1} <strong>!!!</strong></li></ul></li><li>Iterate the array<ul><li>If <code>mod % k</code> in the hash table<ul><li>Yes, return if the distance is more than 2</li><li>No, insert result</li></ul></li></ul></li></ul><p>Time: O(N), Space: O(N)</p><h4 id=270-closest-binary-search-tree-value><a href=https://leetcode.com/problems/closest-binary-search-tree-value/>270. Closest Binary Search Tree Value</a></h4><p><strong>PROBLEM STATEMENT</strong></p><h4 id=426-convert-binary-search-tree-to-sorted-doubly-linked-list><a href=https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/>426. Convert Binary Search Tree to Sorted Doubly Linked List</a></h4><p><strong>PROBLEM STATEMENT</strong></p><h4 id=14-longest-common-prefix><a href=https://leetcode.com/problems/longest-common-prefix/>14. Longest Common Prefix</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Steps</strong></p><ul><li>Use the first string as reference to scan other strings</li><li>Iterate character of the first string<ul><li>Compare to all other strings<ul><li>If not the same character at same index or new string is too small, return current substring</li></ul></li></ul></li><li>Return first string</li></ul><h3 id=graph>Graph</h3><h4 id=133-clone-graph><a href=https://leetcode.com/problems/clone-graph/>133. Clone Graph</a></h4><p><strong>Keyword</strong>: DFS on Graph</p><p><strong>Intuition</strong></p><ul><li>Use DFS to traverse the graph</li><li>Use one hash table to store cloned nodes {Old -> New} to avoid cycles</li><li>Cycles for graph is like leaf of tree but connected</li></ul><p><strong>Steps</strong></p><ul><li>The DFS function: Return cloned node, carrying (or cache) hash map<ul><li>If <code>nullptr</code> return <code>nullptr</code></li><li>If node is cloned, return the cloned node</li><li>Otherwise<ul><li>Clone new node</li><li>Recursively clone its neigbor</li></ul></li></ul></li><li>Start DFS from <code>root</code></li></ul><p>Time: O(N + E), Space: O(N)</p><h4 id=130-surrounded-regions><a href=https://leetcode.com/problems/surrounded-regions/>130. Surrounded Regions</a></h4><p><strong>Keyword</strong>: BFS</p><h4 id=721-accounts-merge><a href=https://leetcode.com/problems/accounts-merge/>721. Accounts Merge</a></h4><h4 id=398-random-pick-index><a href=https://leetcode.com/problems/random-pick-index/>398. Random Pick Index</a></h4><h4 id=415-add-strings><a href=https://leetcode.com/problems/add-strings/>415. Add Strings</a></h4><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Intuition</strong></p><ul><li>Simulate adding operation from the end of two strings with a carrier</li><li>char -> digit: ch - &lsquo;0&rsquo;, digit -> char: d + &lsquo;0&rsquo;</li></ul><h4 id=824-goat-latin><a href=https://leetcode.com/problems/goat-latin/>824. Goat Latin</a></h4><p><strong>Keyword</strong>: String</p><p><strong>Intuition</strong></p><ul><li>Follow the instruction</li><li>Move first letter to the end: <code>s = s.substr(1) + s[0]</code></li></ul><h4 id=1768-merge-strings-alternately><a href=https://leetcode.com/problems/merge-strings-alternately/>1768. Merge Strings Alternately</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Two-Pointer</p><p><strong>Intuition</strong></p><ul><li><strong>Don&rsquo;t need to use extra variable</strong> to decide which letter to append<ul><li>Add one by one from word1 to word2 will do the job</li></ul></li></ul><p><strong>Steps</strong></p><ul><li>Two pointers start at 0</li><li>Loop when not both pointers arrive the end<ul><li>If i not to the end, append value at i, count up i</li><li>If j not to the end, append value at j, count up j</li></ul></li></ul><h4 id=219-contains-duplicate-ii><a href=https://leetcode.com/problems/contains-duplicate-ii/>219. Contains Duplicate II</a></h4><p><strong>Intuition</strong></p><ul><li>Use a hash map to track <strong>the latest index where each number appeared</strong></li></ul><h4 id=173-binary-search-tree-iterator><a href=https://leetcode.com/problems/binary-search-tree-iterator/>173. Binary Search Tree Iterator</a></h4><h4 id=4-median-of-two-sorted-arrays><a href=https://leetcode.com/problems/median-of-two-sorted-arrays/>4. Median of Two Sorted Arrays</a></h4><p><strong>HARD!!!</strong></p><p><strong>Keyword</strong>: Binary Search</p><p><strong>Intuition</strong></p><ul><li>We are required to finish in O(log(m + n)), so we can&rsquo;t merge and sort (O(nlog(n)))</li><li>Try to partion both arrays at index <code>AMid</code> and <code>BMid</code>, such that: <code>AMid + BMid == (m + n + 1) / 2</code></li><li>Check if all the left parts are less equal than all the right parts</li><li>Tricks<ul><li>Always binary search the shorter one</li><li>Be careful about the edge cases at start and end</li></ul></li></ul><p><strong>Steps</strong></p><ul><li>Always binary search on the smaller array.</li><li>Partition both arrays at index i and j such that: <code>i + j == (m + n + 1) / 2</code> (ensures left and right parts are balanced)</li><li>Use INT_MIN and INT_MAX to avoid boundary issues.</li><li>Check if:<ul><li>Aleft &lt;= Bright and Bleft &lt;= Aright</li><li>If not, adjust binary search (low/high)</li></ul></li><li>Once the correct partition is found:<ul><li>If total length is odd: return max(left parts)</li><li>If even: return average of max(left parts) and min(right parts)</li></ul></li></ul><h4 id=1047-remove-all-adjacent-duplicates-in-string><a href=https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/>1047. Remove All Adjacent Duplicates In String</a></h4><h4 id=1152-analyze-user-website-visit-pattern><a href=https://leetcode.com/problems/analyze-user-website-visit-pattern/>1152. Analyze User Website Visit Pattern</a></h4><p><strong>PROBLEM STATEMENT</strong><br>You are given three arrays: username, timestamp, and website, where each entry represents a user&rsquo;s website visit at specific time. A 3-sequence is a list of three websites visited in order by a user. Your task is to find the 3-sequence visited by the largest number of users. If multiple sequences have the same highest count, return the lexicographically smallest one.</p><pre tabindex=0><code>Input:
username = [&#34;joe&#34;,&#34;joe&#34;,&#34;joe&#34;, &#34;james&#34;,&#34;james&#34;,&#34;james&#34;,&#34;james&#34;,&#34;mary&#34;,&#34;mary&#34;,&#34;mary&#34;]
timestamp = [1,2,3,4,5,6,7,8,9,10]
website = [&#34;home&#34;,&#34;about&#34;,&#34;career&#34;,&#34;home&#34;,&#34;cart&#34;,&#34;maps&#34;,&#34;home&#34;,&#34;home&#34;,&#34;about&#34;,&#34;career&#34;]
</code></pre><p><strong>Solution</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span> mostVisitedPattern(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;&amp;</span> usernames, <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> timestamps, <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;&amp;</span> websites) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> usernames.size();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1. Combine all data, and sort with timestamp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// [timestamp, username, website]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>tuple<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, std<span style=color:#f92672>::</span>string, std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;&gt;</span> data;
</span></span><span style=display:flex><span>    data.reserve(n);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        data.emplace_back(timestamps[i], usernames[i], websites[i]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>sort(data.begin(), data.end());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// User visited pattern
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>unordered_map<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string, std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;&gt;</span> userToWebsites;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> [_, username, website]<span style=color:#f92672>:</span> data) {
</span></span><span style=display:flex><span>        userToWebsites[username].push_back(website);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3 sequences
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>map<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span>, std<span style=color:#f92672>::</span>set<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;&gt;</span> seqsToUsers;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> [user, websites]<span style=color:#f92672>:</span> userToWebsites) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (websites.size() <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>set<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;&gt;</span> seqs;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> sz <span style=color:#f92672>=</span> websites.size();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> sz; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;</span> sz; <span style=color:#f92672>++</span>j) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>; k <span style=color:#f92672>&lt;</span> sz; <span style=color:#f92672>++</span>k) {
</span></span><span style=display:flex><span>                    seqs.insert({websites[i], websites[j], websites[k]});
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> seq: seqs) {
</span></span><span style=display:flex><span>            seqsToUsers[seq].insert(user);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Find the most visited
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> maxCount <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> [seqs, users]<span style=color:#f92672>:</span> seqsToUsers) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> users.size(); count <span style=color:#f92672>&gt;</span> maxCount <span style=color:#f92672>||</span> (count <span style=color:#f92672>==</span> maxCount <span style=color:#f92672>&amp;&amp;</span> seqs <span style=color:#f92672>&lt;</span> res)) {
</span></span><span style=display:flex><span>            maxCount <span style=color:#f92672>=</span> count;
</span></span><span style=display:flex><span>            res <span style=color:#f92672>=</span> seqs;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=994-rotting-oranges><a href=https://leetcode.com/problems/rotting-oranges/>994. Rotting Oranges</a></h4><p><strong>Keyword</strong>: BFS on Matrix, Flood-Fill</p><p><strong>Intuition</strong></p><ul><li>Classic BFS flood-fill problem<ul><li>Multi sources, starts from rotten oranges</li><li>Process layer by layer (min by min)</li><li>Count min as BFS depth</li></ul></li></ul><p><strong>Steps</strong></p><ul><li>Traverse grid to prepare BFS<ul><li>Push rotten pos into queue</li><li>Count fresh count</li></ul></li><li>BFS loop<ul><li>Iterate all the rotten oranges in this layer<ul><li>Try 4 directions<ul><li>If out of range or not fresh, skip</li><li>Else rotten, push back to queue, decrease fresh count</li></ul></li></ul></li><li>Minute add up</li></ul></li><li>Return if no fresh left or not</li></ul><h4 id=128-longest-consecutive-sequence><a href=https://leetcode.com/problems/longest-consecutive-sequence/>128. Longest Consecutive Sequence</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Intuition</strong></p><ul><li>Since the time complexity should be O(n), so we can&rsquo;t sort</li><li>We try to use hash set to make the query faster O(1)</li></ul><p><strong>Steps</strong></p><ul><li>Declare hash set, transform the nums into hash set</li><li>Iterate the <strong>set</strong> (IMPORTANT!!! As the test case may contain a lots of duplicated values)<ul><li>Start only when current number is <strong>start</strong> (<code>num - 1</code> not inside hash set)<ul><li>Count the length of the sequence starts with this number</li><li>Update longest length</li></ul></li></ul></li></ul><h4 id=735-asteroid-collision><a href=https://leetcode.com/problems/asteroid-collision/>735. Asteroid Collision</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Stack</p><p><strong>Intuition</strong></p><ul><li>Collisions only occur when a positive asteroid (moving right) is followed by a negative asteroid (moving left).</li><li>Use a stack to simulate the process, handling collisions in a Last-In-First-Out (LIFO) manner.</li></ul><p><strong>Steps</strong></p><ul><li>Iterate through each asteroid<ul><li>For each asteroid, check if it collides with the top of the stack (i.e., current asteroid is negative and top of stack is positive).</li><li>If the top asteroid is smaller, it is destroyed (pop from stack).</li><li>If they are equal, both are destroyed (pop from stack and mark current asteroid as destroyed).</li><li>If the top asteroid is larger, the current asteroid is destroyed.</li></ul></li></ul><h4 id=380-insert-delete-getrandom-o1><a href=https://leetcode.com/problems/insert-delete-getrandom-o1/>380. Insert Delete GetRandom O(1)</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Data Structure</p><p><strong>Intuition</strong></p><ul><li>Because we need to random access element, so the underlying container should be vector</li><li>Because the <code>insert</code> and <code>remove</code> work O(1), we need to use hash map to fast query value, and access index</li></ul><p><strong>Steps</strong></p><ul><li>Under lying container <code>std::vector</code>, use hash map to track Value -> Index</li><li><code>insert</code><ul><li>If exist, return</li><li>Append to vector, and insert new Value -> Index</li></ul></li><li><code>remove</code><ul><li>If not exist, return</li><li>Get value&rsquo;s index</li><li>Swap <em>value&rsquo;s index</em> and <em>last index</em></li><li>Update new Value -> Index</li><li>Remove last value, and old Value -> Index</li></ul></li><li><code>getRandom()</code><ul><li>Return value at random index</li></ul></li></ul><h4 id=3371-identify-the-largest-outlier-in-an-array><a href=https://leetcode.com/problems/identify-the-largest-outlier-in-an-array/>3371. Identify the Largest Outlier in an Array</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Intuition</strong></p><ul><li>Total Sum = Outlier + Sum of Special Numbers + [Special Numbers] = Outlier + 2 * Sum of Special Numbers</li><li>So we can iterate the <code>nums</code>, and find if outlier exists in <code>nums</code>, and find the max possible outlier</li><li>Be careful, the sum of special numbers should be on different index of outlier</li></ul><p><strong>Steps</strong></p><ul><li>Declare a hash map for number frequency</li><li>Iterate the nums to get number frequency and sum</li><li>Iterate number frequency {num, freq}<ul><li>Calculate outlier assume the current number is special sum</li><li>If outlier exists<ul><li>If outlier is not the same as special sum or outlier value appears multiple times, update max outlier</li></ul></li></ul></li><li>Return max outlier</li></ul><h2 id=dynamic-programming>Dynamic Programming</h2><h4 id=322-coin-change><a href=https://leetcode.com/problems/coin-change/>322. Coin Change</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: DP</p><p><strong>Steps</strong></p><ul><li>Define the DP<br>+</li></ul><h4 id=139-word-break><a href=https://leetcode.com/problems/word-break/>139. Word Break</a></h4><p><strong>Keyword</strong>: DP</p><p><strong>Steps</strong></p><ul><li>Define DP<ul><li>Given word <code>s</code> of length <code>n</code></li><li><code>dp[i] == 1</code> means the substring <code>s[0...i-1]</code> can be broken into words</li></ul></li><li>Loop <code>[1...n]</code><ul><li>Loop <code>[0...n)</code><ul><li>Try to split the word at <code>j</code>, and check if <code>dp[j]</code> is valid and the suffix <code>s[j, i - j]</code> is in the dictionary</li></ul></li></ul></li><li>Return <code>dp[n]</code></li></ul><p>Time: O(n^2), Space: O(n + d)</p><h4 id=472-concatenated-words><a href=https://leetcode.com/problems/concatenated-words/>472. Concatenated Words</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: DP</p><p><strong>Intuition</strong></p><ul><li>Similar to <a href=/topics/interview/leetcode-top-interview/#139-word-break>Word Break</a>, except we need to iterate all the words</li></ul><p><strong>Steps</strong></p><ul><li>Write a helper function to check if a word can be formed by a dictionary, exactly the same as <a href=/topics/interview/leetcode-top-interview/#139-word-break>Word Break</a></li><li>Sort the words based on length</li><li>Iterate words<ul><li>If current word can be formed with dictionary, append word to result</li><li>Update dictionary</li></ul></li></ul><p>Time: O(N<em>L^2), Space: O(N</em>L)</p><h4 id=198-house-robber><a href=https://leetcode.com/problems/house-robber/>198. House Robber</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: DP</p><p><strong>Steps</strong></p><ul><li>Define DP<ul><li><code>dp[i]</code>: max amount of money to get on day i</li><li>Transition:<ul><li><code>dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])</code></li></ul></li><li>Base cases:<ul><li><code>dp[0] = nums[0]</code></li><li><code>dp[1] = max(nums[0], nums[1])</code></li></ul></li></ul></li></ul><h4 id=70-climbing-stairs><a href=https://leetcode.com/problems/climbing-stairs/>70. Climbing Stairs</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: DP</p><p><strong>Steps</strong></p><ul><li>Define DP<ul><li><code>dp[i]</code>: Distinct ways to climb to the top</li><li>Transition:<ul><li><code>dp[i] = dp[i - 1] + dp[i - 2]</code></li></ul></li><li>Base cases:<ul><li><code>dp[0] = 1</code></li><li><code>dp[1] = 2</code></li></ul></li></ul></li></ul><h4 id=120-triangle><a href=https://leetcode.com/problems/triangle/>120. Triangle</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: DP</p><p><strong>Steps</strong></p><ul><li>Start from the second last row and go upward.</li><li>For each element, update it with the sum of itself and the min of its two children (below it).</li><li>The top element becomes the answer.</li></ul><h4 id=78-subsets><a href=https://leetcode.com/problems/subsets/>78. Subsets</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Backtrack</p><p><strong>Intuition</strong><br>Classic backtrack problem</p><p><strong>Steps</strong></p><ul><li>Declare <code>backtrack</code> function<ul><li>Return: void</li><li>Inputs: nums (optional), current index, current sequence, current results</li><li>Base condition: append current sequence</li><li>Backtrack condition:<ul><li>Iterate <code>[current index, nums' size)</code><ul><li>Append num to current sequence</li><li>backtrack</li><li>Remove the last from current sequence</li></ul></li></ul></li></ul></li><li>Start backtrack with<ul><li>numbers</li><li>index 0</li><li>sequence</li><li>results</li></ul></li></ul><h4 id=54-spiral-matrix><a href=https://leetcode.com/problems/spiral-matrix/>54. Spiral Matrix</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Intuition</strong></p><ul><li>Simulate the process</li></ul><p><strong>Steps</strong></p><ul><li>Declare top, bottom, left, right</li><li>Loop while left and right, top and bottom don&rsquo;t cross<ul><li>Loop from left to right, top add up</li><li>Loop from top to bottom, right count down</li><li>If top and bottom not cross<ul><li>Loop from right to left, bottom count down</li></ul></li><li>If left and right not cross<ul><li>Loop from bottom to top, left add up</li></ul></li></ul></li></ul><h4 id=36-valid-sudoku><a href=https://leetcode.com/problems/valid-sudoku/>36. Valid Sudoku</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Intuition</strong></p><ul><li>Simulate how human check Sudoku valid</li></ul><p><strong>Steps</strong></p><ul><li>Declare three <code>int[9][9]</code> to track if number occurance in rows, cols, and boxes</li><li>Iterate the elements<ul><li>If char is &lsquo;.&rsquo;, skip</li><li>If number exists in any row, col, or boxes, return false</li><li>Update number occurances</li></ul></li><li>Return true</li></ul><p>Time: O(9x9), Space: O(9x9x3)</p><h4 id=1138-alphabet-board-path><a href=https://leetcode.com/problems/alphabet-board-path/>1138. Alphabet Board Path</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Simulation</p><p><strong>Steps</strong></p><h4 id=838-push-dominoes><a href=https://leetcode.com/problems/push-dominoes/>838. Push Dominoes</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Simulation</p><p><strong>Steps</strong></p><h4 id=1429-first-unique-number><a href=https://leetcode.com/problems/first-unique-number/>1429. First Unique Number</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>PROBLEM STATEMENT</strong></p><h4 id=795-number-of-subarrays-with-bounded-maximum><a href=https://leetcode.com/problems/number-of-subarrays-with-bounded-maximum/>795. Number of Subarrays with Bounded Maximum</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><h4 id=881-boats-to-save-people><a href=https://leetcode.com/problems/boats-to-save-people/>881. Boats to Save People</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><h4 id=17-letter-combinations-of-a-phone-number><a href=https://leetcode.com/problems/letter-combinations-of-a-phone-number/>17. Letter Combinations of a Phone Number</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Backtrack</p><p><strong>Intuition</strong></p><ul><li>A very classic combinatorics problem involving backtracking</li></ul><p><strong>Steps</strong></p><ul><li>The <code>backtrack</code> function<ul><li>Return: void</li><li>Carry: (optional)digits, current index in digits, current word, current results</li><li>Declare a static hash map, an even better option is <code>char[8][4]</code>, for digits represent 3 letters, use &lsquo;\0&rsquo; as 4th letter</li><li>Base case: If current index is equal to digits size (iteration finishes), append current word, return</li><li>Recursive case:<ul><li>Get possible letters for current digit</li><li>Append each letter to current word</li></ul></li></ul></li><li>Start backtrackwith<ul><li>Input <code>digits</code></li><li>Empty word</li><li>Index 0</li><li>Output <code>res</code></li></ul></li></ul><p>Time:</p><h3 id=bit-manipulation>Bit Manipulation</h3><h4 id=190-reverse-bits><a href=https://leetcode.com/problems/reverse-bits/>190. Reverse Bits</a></h4><p><strong>Steps</strong></p><ul><li>Declare the result value</li><li>Shift result left</li><li>Add the LSB of the input, <code>res |= (n & 1)</code></li><li>Shift input right</li></ul><h4 id=191-number-of-1-bits><a href=https://leetcode.com/problems/number-of-1-bits/>191. Number of 1 Bits</a></h4><p><strong>Approach I: Iterate through</strong></p><ul><li>Iterate the input bits</li><li>Count the LSB of the input, <code>count += (n & 1)</code></li><li>Shift input right</li></ul><p><strong>Approach II: Brian Kernighan&rsquo;s Algorithm</strong></p><ul><li>While input still exists<ul><li>Remove the lowest set bit</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hammingWeight</span>(<span style=color:#66d9ef>uint32_t</span> n) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (n) {
</span></span><span style=display:flex><span>    n <span style=color:#f92672>&amp;=</span> (n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#f92672>++</span>count;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> count;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=136-single-number><a href=https://leetcode.com/problems/single-number/>136. Single Number</a></h4><p><strong>Key Idea</strong></p><ul><li>Use <strong>XOR</strong> cancels out the pairs</li><li>XOR of a number with itself is 0</li><li>XOR with 0 leaves the number unchanged</li></ul><h4 id=137-single-number-ii><a href=https://leetcode.com/problems/single-number-ii/>137. Single Number II</a></h4><p><strong>Key Idea</strong></p><ul><li><code>ones = (ones ^ num) & ~twos</code>, meaning appear once, and not twice</li><li><code>twos = (twos ^ num) & ~ones</code>, meaning appear twice, and not once</li><li>The numbers appear three times will cancel out, left the one appears once</li><li>Return <code>ones</code></li></ul><h4 id=260-single-number-iii><a href=https://leetcode.com/problems/single-number-iii/>260. Single Number III</a></h4><p><strong>Key Idea</strong></p><ul><li>Same as <a href=/topics/interview/leetcode-top-interview/#136-single-number>136. Single Number</a>, XOR will cancel out all the duplicated numbers</li><li>But the final result is <code>a^b</code>, the XOR of two unique numbers</li><li>Use <code>diff = a_b & (-a_b);</code> to extract the <strong>lowest diff bits</strong> of <code>a_b</code></li><li>Use this diff to separate the numbers into two group, and xor will cancel out the numbers appear twice</li><li>Return a and b</li></ul><h4 id=2357-make-array-zero-by-subtracting-equal-amounts><a href=https://leetcode.com/problems/make-array-zero-by-subtracting-equal-amounts/>2357. Make Array Zero by Subtracting Equal Amounts</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Intuition</strong></p><ul><li>Each operation removes <strong>one unique non-zero number</strong> from the set of values in the array.</li><li>Since subtracting the smallest non-zero value will eventually turn elements zero, <strong>the number of unique non-zero values</strong> in the array is exactly the number of operations needed.</li></ul><p><strong>Steps</strong></p><ul><li>Declare a set to track unique numbers</li><li>Return size</li></ul><h4 id=238-product-of-array-except-self><a href=https://leetcode.com/problems/product-of-array-except-self/>238. Product of Array Except Self</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Intuition</strong></p><ul><li>We can&rsquo;t use divide</li><li>We compute the product of at index i from left product and right product</li></ul><p><strong>Steps</strong></p><ul><li>Declare the <code>res</code> array of size n, initialize with 1</li><li>Iterate from left to right, starting at 1 to calculate<ul><li>res[i] = res[0] * res[1] * &mldr; * res[i - 1]</li></ul></li><li>Iterate from right to left, starting at n - 1 to calculate<ul><li>Multiply the values in right parts</li></ul></li></ul><h4 id=53-maximum-subarray><a href=https://leetcode.com/problems/maximum-subarray/>53. Maximum Subarray</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Intuition</strong></p><ul><li>Similar to <a href=/topics/interview/leetcode-top-interview/#121-best-time-to-buy-and-sell-stock>Best Time to Buy and Sell Stock</a></li><li>Append vs. Start new</li></ul><p><strong>Steps</strong></p><ul><li>Declare <code>curSum</code> as the first element, and <code>maxSum</code> as <code>curSum</code></li><li>Loop from the second element<ul><li>Update <code>curSum</code> based on <strong>append element</strong> or <strong>start new subarray</strong></li><li>Update <code>maxSum</code></li></ul></li></ul><h4 id=2790-maximum-number-of-groups-with-increasing-length><a href=https://leetcode.com/problems/maximum-number-of-groups-with-increasing-length/>2790. Maximum Number of Groups With Increasing Length</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>HARD!!!</strong></p><p><strong>Keyword</strong>: Greedy</p><p><strong>Intuition</strong><br>No idea???</p><p><strong>Steps</strong></p><h4 id=239-sliding-window-maximum><a href=https://leetcode.com/problems/sliding-window-maximum/>239. Sliding Window Maximum</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Sliding Window</p><p><strong>Intuition</strong></p><ul><li>Brutal force: scan each window, cost O(nk)</li><li>Use <code>deque</code> to store <code>indices</code> of useful elements in window</li></ul><p><strong>Steps</strong></p><ul><li>Declare a deque to keep indices of elements that are candidates for max</li><li>Iterate <code>nums</code><ul><li>Remove the outside indices from the front</li><li>Remove small indices from the back</li><li>If i in range, append deque front (indices with larger value)</li></ul></li></ul><h4 id=2214-minimum-health-to-beat-game><a href=https://leetcode.com/problems/minimum-health-to-beat-game/>2214. Minimum Health to Beat Game</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>PROBLEM STATEMENT</strong></p><p>You&rsquo;re given an array damage where <code>damage[i]</code> represents the health lost upon completing level i. Additionally, you have an armor that can be <strong>used once</strong> to absorb up to armor damage on a single level. Your health must always above 0. Determine the minimum initial health required to complete all levels.</p><p><strong>Keyword</strong>: Greedy</p><p><strong>Intuition</strong></p><ul><li>Total Damage: sum up</li><li>Optimal Armor Usage: Use armor on the level with highest damage</li><li>Effective Armor: The armor can absorb up to armor damage, but not more than the max damage</li></ul><p><strong>Solution</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> minimumHealth(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> damage, <span style=color:#66d9ef>int</span> armor) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>auto</span> totalDamage <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>accumulate(damage.begin(), damage.end(), <span style=color:#ae81ff>0ll</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>auto</span> maxDamage <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>std<span style=color:#f92672>::</span>max_element(damage.begin(), damage.end());
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>auto</span> effectiveArmor <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>min(armor, maxDamage);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> totalDamage <span style=color:#f92672>-</span> effectiveArmor <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=295-find-median-from-data-stream><a href=https://leetcode.com/problems/find-median-from-data-stream/description/>295. Find Median from Data Stream</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Min/Max Heap</p><p><strong>Intuition</strong></p><ul><li>We don&rsquo;t want to sort the the entire list every time</li><li>Instead, we use two heaps to store two halves:<ul><li>A max heap for the smaller half</li><li>A min heap for the larger half</li></ul></li><li>We also need to keep two heaps balanced so<ul><li>left == right</li><li>left == right + 1</li></ul></li></ul><p><strong>Steps</strong></p><ul><li><code>add()</code><ul><li>Add to left first</li><li>Move the largest from left to right to maintain order (???)</li><li>Rebalance: if right more than left, move smallest back to left</li></ul></li><li><code>findMedian()</code><ul><li>If left > right, return left top</li><li>return half of left top and right top</li></ul></li></ul><h4 id=102-binary-tree-level-order-traversal><a href=https://leetcode.com/problems/binary-tree-level-order-traversal/>102. Binary Tree Level Order Traversal</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: BFS on Tree</p><p><strong>Intuition</strong></p><ul><li>Classic BFS</li></ul><h4 id=2551-put-marbles-in-bags><a href=https://leetcode.com/problems/put-marbles-in-bags/>2551. Put Marbles in Bags</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: List</p><p><strong>Intuition</strong></p><ul><li>The score is <strong>only determined</strong> by the sum of <strong>the first and last</strong> element in each group</li><li>Each cut affects two adjacent elements, their sum is important</li><li>Don&rsquo;t need to care about the first and last element</li></ul><p><strong>Steps</strong></p><ol><li>For each adjacent pair of weights, calculate <code>pairSums</code></li><li>Sort the <code>pairSums</code></li><li>Accumulate the smallest k sums to <code>minScore</code>, and the largest k sums to <code>maxScore</code></li><li>Return <code>maxScore - minScore</code></li></ol><p>Time: O(N) * 2 + O(NlogN), Space: O(N)</p><h4 id=3462-maximum-sum-with-at-most-k-elements><a href=https://leetcode.com/problems/maximum-sum-with-at-most-k-elements/>3462. Maximum Sum with at Most K Elements</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Min-Heap, Greedy</p><p><strong>Intuition</strong></p><ul><li>&ldquo;Most K&rdquo; thinks of min heap</li><li>Add as bigger number as possible of a row into the min heap</li></ul><p><strong>Steps</strong></p><ul><li>Declare min heap to store global max k element</li><li>Iterate all rows<ul><li>Sort current row (we want to append from max value)</li><li>Try to add <code>top row limit</code> elements into the heap</li><li>Always keep k element (the max k) in min heap</li></ul></li><li>Sum up the elements in min heap</li></ul><p>Time: O(m*nlogn), Space: O(k)</p><h4 id=7-reverse-integer><a href=https://leetcode.com/problems/reverse-integer/>7. Reverse Integer</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Intuition</strong></p><ul><li>The structure is very easy, keep extract the last digit by mod, and append to the new number</li><li>Be carefult about the <strong>overflow problem</strong><ul><li>INT_MAX: 2^31 - 1, ***7</li><li>INT_MIN: -2^31, -***8</li></ul></li></ul><p><strong>Steps</strong></p><ul><li>While x is not zero<ul><li>d = x % 10, x /= 10</li><li>To prevent overflow, pre-check if multiplying by 10 and adding a digit would exceed limits.</li><li>res = res * 10 + d</li></ul></li></ul><p>Time: O(logn), Space: O(1)</p><h4 id=739-daily-temperatures><a href=https://leetcode.com/problems/daily-temperatures/>739. Daily Temperatures</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Stack</p><p><strong>Intuition</strong><br>Use a <strong>monotonic stack</strong> to remember <strong>indices</strong> of days with cooler (or same) temperatures.<br>As soon as we find a warmer temperature, we can pop previous days.</p><p><strong>Steps</strong></p><ul><li>Declare stack for the decresing temperature <strong>indices</strong></li><li>Declare results, initialize with 0</li><li>Iterate temperatures<ul><li>If we find current temp is higher than the temps in the stack<ul><li>Pop out</li><li>Append the index diff as result</li></ul></li><li>Push temp to stack</li></ul></li><li>Return results</li></ul><p>Time: O(N), Space: O(N)</p><h4 id=907-sum-of-subarray-minimums><a href=https://leetcode.com/problems/sum-of-subarray-minimums/>907. Sum of Subarray Minimums</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>HARD!!!</strong></p><p><strong>Intuition</strong></p><ul><li>Each element may be the minimum for some subarray</li><li>The problem becomes <strong>how many subarrays</strong> each element serves as the minimum</li><li>Use monotonic stack to find<ul><li>How many elements on the left are bigger</li><li>How many elements on the right are bigger</li></ul></li></ul><p><strong>Steps</strong></p><ul><li>For each elements, use monotonic stack to find, use -1 to indicate no less element<ul><li>Index of previous smaller element, <code>[0...n)</code>, use <code>></code></li><li>Index of next smaller element, <code>[n-1, 0]</code>, use <code>>=</code></li></ul></li><li>Sum up the element based on contribution (and mod). `sum = (sum + arr[i] * left * right) % 10</li><li>Return sum</li></ul><p>Time: 3 * O(n), Space: 2 * O(n)</p><h4 id=1492-the-kth-factor-of-n><a href=https://leetcode.com/problems/the-kth-factor-of-n/>1492. The kth Factor of n</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Intuition</strong></p><ul><li>Instead of finding all factors of n, we can count them as we iterate up to n. Once we find the kth, we return it immediately.</li></ul><p><strong>Steps</strong></p><ul><li>Use <code>k</code> as counter</li><li>Iterate from 1 to <code>n</code><ul><li>If <code>n % i == 0</code>, decrease counter</li><li>If <code>counter == 0</code>, reutrn <code>i</code></li></ul></li><li>Return invalid</li></ul><h4 id=21-merge-two-sorted-lists><a href=https://leetcode.com/problems/merge-two-sorted-lists/>21. Merge Two Sorted Lists</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Linked-List</p><p><strong>Intuition</strong></p><ul><li>Since both lists are sorted, we can iterate through both and merge them in order.</li></ul><p><strong>Steps</strong></p><ul><li>Create <code>dummy</code> node</li><li>Declare <code>current</code> node starts at dummy</li><li>While both list not to the end<ul><li>Link the smaller node, and move forward</li></ul></li><li>Link the rest list</li></ul><p>Time: O(n+m), Space: O(1)</p><h4 id=148-sort-list><a href=https://leetcode.com/problems/sort-list/>148. Sort List</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Linked-List</p><p><strong>Intuition</strong></p><ul><li>Naturally think of merge sort</li><li>Split the linked-list with fast-slow pointer</li><li>Merge two part, check <a href=/topics/interview/leetcode-top-interview/#21-merge-two-sorted-lists>21. Merge Two Sorted Lists</a></li></ul><p><strong>Steps</strong></p><ul><li>If <code>head</code> is <code>nullptr</code> or one head, return <code>head</code></li><li>Use fast-slow pointer to split the list</li><li>Recursively call <code>sortList</code> on <code>head</code> and <code>slow</code></li><li>Merge the result</li></ul><p>Time: O(nlogn), Space: O(logn) of stack</p><h4 id=62-unique-paths><a href=https://leetcode.com/problems/unique-paths/>62. Unique Paths</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Intuition</strong><br>This is a <strong>combinatorics</strong> problem. The robot has to make exactly <code>m-1</code> down moves and <code>n-1</code> right moves. The total number of unique paths is equivalent to choosing m-1 downs out of (m+n-2) total moves.</p><p><strong>Steps</strong></p><ul><li>Calculate $C_{m+n-2}^{m-1}$</li></ul><h4 id=2055-plates-between-candles><a href=https://leetcode.com/problems/plates-between-candles/>2055. Plates Between Candles</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Prefix Sum</p><p><strong>Intuition</strong></p><ul><li>Precompute the prefix sum of plates to quickly calculate the number of plates between any two indices.</li><li>For each position, determine the nearest candle to the left and the nearest candle to the right.</li></ul><p><strong>Steps</strong></p><ul><li>Create an array <code>prefixSum</code> where <code>prefixSum[i]</code> represents the total number of plates from the start up to index <code>i</code>.</li><li>Create an array <code>leftCandle</code> where <code>leftCandle[i]</code> stores the index of the nearest candle to the left of or at position <code>i</code>. If there&rsquo;s no candle to the left, store <code>-1</code>.</li><li>Create an array <code>rightCandle</code> where <code>rightCandle[i]</code> stores the index of the nearest candle to the right of or at position <code>i</code>. If there&rsquo;s no candle to the right, store <code>-1</code>.</li><li>Iterate all the queries. For each query [left, right]:<ul><li>Find the index of the nearest candle to the right of left using rightCandle[left].</li><li>Find the index of the nearest candle to the left of right using leftCandle[right].</li><li>If both candles exist and the right of left is less than the left of right, calculate the number of plates between these two candles using the prefix sum <code>prefixSum[rightCandleIndex] - prefixSum[leftCandleIndex]</code></li><li>Otherwise, the answer for this query is 0.</li></ul></li></ul><p>Time: O(n + q), Space: O(n)</p><h4 id=206-reverse-linked-list><a href=https://leetcode.com/problems/reverse-linked-list/>206. Reverse Linked List</a></h4><p><strong>Keyword</strong>: Linked-List</p><h4 id=92-reverse-linked-list-ii><a href=https://leetcode.com/problems/reverse-linked-list-ii/>92. Reverse Linked List II</a></h4><p><strong>Keyword</strong>: Linked-List</p><p><strong>Intuition</strong></p><ul><li>Difference with <a href=/topics/interview/leetcode-top-interview/#206-reverse-linked-list>206. Reverse Linked List</a> is reverse list in a range</li></ul><h4 id=876-middle-of-the-linked-list><a href=https://leetcode.com/problems/middle-of-the-linked-list/>876. Middle of the Linked List</a></h4><p><strong>Keyword</strong>: Linked-List, Two-Pointer</p><p><strong>Intuition</strong></p><ul><li>Slow and fast pointer. When fast meets the end, return the slow</li></ul><h4 id=141-linked-list-cycle><a href=https://leetcode.com/problems/linked-list-cycle/>141. Linked List Cycle</a></h4><p><strong>Keyword</strong>: Linked-List, Two-Pointer</p><p><strong>Intuition</strong></p><ul><li>Slow and fast pointer. When fast meets slow, then there&rsquo;s a cycle</li></ul><h4 id=142-linked-list-cycle-ii><a href=https://leetcode.com/problems/linked-list-cycle-ii/>142. Linked List Cycle II</a></h4><p><strong>Keyword</strong>: Linked-List, Two-Pointer</p><p><strong>Intuition</strong></p><ul><li>Difference with <a href=/topics/interview/leetcode-top-interview/#141-linked-list-cycle>141. Linked List Cycle</a> is the problem requires return the entry of the loop</li><li>Detect loop part is the same. After we find a loop, place a node in the beginning, and move together with slow</li></ul><h4 id=237-delete-node-in-a-linked-list><a href=https://leetcode.com/problems/delete-node-in-a-linked-list/>237. Delete Node in a Linked List</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Linked-List</p><p><strong>Intuition</strong>:</p><ul><li>Can&rsquo;t access head, and we don&rsquo;t know prev, so we can&rsquo;t simply unlink this node</li><li>We can <strong>copy the next node</strong> into current node, and delete next node</li></ul><h4 id=225-implement-stack-using-queues><a href=https://leetcode.com/problems/implement-stack-using-queues/>225. Implement Stack using Queues</a></h4><h4 id=2221-find-triangular-sum-of-an-array><a href=https://leetcode.com/problems/find-triangular-sum-of-an-array/>2221. Find Triangular Sum of an Array</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Math</p><p><strong>Intuition</strong></p><ul><li>Simulate the process</li><li>Dont use extra vector, put new result in nums[i], <code>nums[i] = (nums[i] + nums[i+1]) % 10</code></li></ul><h4 id=2268-minimum-number-of-keypresses><a href=https://leetcode.com/problems/minimum-number-of-keypresses/>2268. Minimum Number of Keypresses</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>PROBLEM STATEMENT</strong></p><p>You have a keypad with 9 buttons, numbered from 1 to 9, each mapped to lowercase English letters. You can choose which characters each button is matched to as long as:</p><ul><li>All 26 lowercase English letters are mapped to.</li><li>Each character is mapped to by exactly 1 button.</li><li>Each button maps to at most 3 characters.</li><li>To type the first character matched to a button, you press the button once. To type the second character, you press the button twice, and so on.</li></ul><p>Given a string s, return the minimum number of keypresses needed to type s using your keypad.</p><p>Note that the characters mapped to by each button, and the order they are mapped in cannot be changed.</p><p><strong>Keyword</strong>: Sort, Simulation</p><p><strong>Intuition</strong></p><ul><li>To minimize the total keypresses<ul><li>Put the most frequent letters in the positions with lower cost</li><li>Then put the next most frequent letters into positions with 2 or 3 presses.</li></ul></li></ul><p><strong>Steps</strong></p><ul><li>Count the frequencies of each letter</li><li>Sort them by descending order</li><li>Assign the most frequent 9 letters to cost 1, then next 9 to cost 2, then next 9 to cost 3</li></ul><p><strong>Solution</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> minimumKeypresses(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> str) {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>array<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>26</span><span style=color:#f92672>&gt;</span> freq(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> ch: str) {
</span></span><span style=display:flex><span>            freq[ch <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;a&#39;</span>]<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>sort(freq.begin(), freq.end(), std<span style=color:#f92672>::</span>greater<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>26</span> <span style=color:#f92672>&amp;&amp;</span> freq[i] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> press <span style=color:#f92672>=</span> i <span style=color:#f92672>/</span> <span style=color:#ae81ff>9</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            res <span style=color:#f92672>+=</span> press <span style=color:#f92672>*</span> freq[i];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Time: O(n) + O(26log26), Space: O(1)</p><h4 id=366-find-leaves-of-binary-tree><a href=https://leetcode.com/problems/find-leaves-of-binary-tree/>366. Find Leaves of Binary Tree</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>PROBLEM STATEMENT</strong><br>Given a binary tree, collect a tree&rsquo;s nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty.</p><p><strong>Keyword</strong>: DFS on Tree</p><p><strong>Intuition</strong></p><ul><li>Simulate &ldquo;removing&rdquo; leaves by grouping nodes by their height from the bottom</li><li>The leaves have height of 0, and their parent have height 1, and so on&mldr;</li></ul><p><strong>Steps</strong></p><ul><li>Define <code>dfs</code> function<ul><li>Input: node</li><li>Carrying: result</li><li>Output: height</li><li>nullptr has height -1</li><li>Height is the max of left and right height, add one</li><li>Nodes at same height at result[h]</li><li>Push current node to result[h]</li><li>Return height</li></ul></li><li>Start with given root node, and results</li></ul><p><strong>Solution</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> findLeaves(TreeNode<span style=color:#f92672>*</span> root) {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> res;
</span></span><span style=display:flex><span>        dfs(root, res);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dfs(TreeNode<span style=color:#f92672>*</span> node, std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> res) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>node) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> h <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>max(dfs(node<span style=color:#f92672>-&gt;</span>left, dfs(node<span style=color:#f92672>-&gt;</span>right, res)), right) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (res.size() <span style=color:#f92672>&lt;=</span> height) {
</span></span><span style=display:flex><span>            res.push_back({});
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        res[h].push_back(node<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> h;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=692-top-k-frequent-words><a href=https://leetcode.com/problems/top-k-frequent-words/>692. Top K Frequent Words</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: Min-Heap</p><p><strong>Intuition</strong></p><ul><li>Top k problem, use min heap</li></ul><p><strong>Steps</strong></p><ul><li>Calculate the word frequency</li><li>Declare a min heap of [count->word] pairs</li><li>Keep pushing item into min heap while keep heap size not larger than k</li><li>Assemble the result</li><li>Reverse the result</li></ul><p>Time: O(nlogk + mlogm), Space: O(n+k)</p><h4 id=113-path-sum-ii><a href=https://leetcode.com/problems/path-sum-ii/>113. Path Sum II</a></h4><p><img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&amp;logo=amazon-aws&amp;logoColor=white" alt=AWS></p><p><strong>Keyword</strong>: DFS on Tree, Backtrack</p><p><strong>Intuition</strong></p><ul><li>From node to leave, so we need to go to the end, think of DFS</li><li>Use DFS to traverse the tree and carrying the current path, current sum, and result</li></ul><p><strong>Steps</strong></p><ul><li>Define <code>dfs</code> function<ul><li>Input: node, target</li><li>Carrying: current path, current sum, result</li><li>Output: none</li><li>nullptr return</li><li>Push the node, add up current value to current sum<ul><li>If current is leaf, and meet target, append current path to result</li><li>Find left/right</li></ul></li><li>Pop back (end backtrack)</li></ul></li><li>Start with given root, target, and empty path, 0 sum, result</li></ul><p>Time: O(N), Space: O(H)</p><h4 id=1730-shortest-path-to-get-food><a href=https://leetcode.com/problems/shortest-path-to-get-food/>1730. Shortest Path to Get Food</a></h4><p><strong>PROBLEM STATEMENT</strong></p><p>You are starving and you want to eat food as quickly as possible. You want to find the shortest path to arrive at any food cell.</p><p>You are given an <code>m x n</code> character matrix, <code>grid</code>, of these different types of cells:</p><ul><li>&lsquo;<em>&rsquo; is your location. There is exactly one &lsquo;</em>&rsquo; cell.</li><li>&lsquo;#&rsquo; is a food cell. There may be multiple food cells.</li><li>&lsquo;O&rsquo; is free space, and you can travel through these cells.</li><li>&lsquo;X&rsquo; is an obstacle, and you cannot travel through these cells.</li></ul><p>You can travel to any adjacent cell north, east, south, or west of your current location if there is not an obstacle.</p><p>Return the length of the shortest path for you to reach any food cell. If there is no path for you to reach food, return -1.</p><p><strong>Keyword</strong>: BFS on Grid</p><p><strong>Intuition</strong></p><p><strong>Solution</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> getFood(std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;&amp;</span> grid) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> rows <span style=color:#f92672>=</span> grid.size();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> cols <span style=color:#f92672>=</span> grid[<span style=color:#ae81ff>0</span>].size();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>queue<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> q;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;&gt;</span> visited(rows, std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>(cols, false));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Find starting point
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> r <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; r <span style=color:#f92672>&lt;</span> rows; <span style=color:#f92672>++</span>r) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; c <span style=color:#f92672>&lt;</span> cols; <span style=color:#f92672>++</span>c) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (grid[r][c] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;*&#39;</span>) {
</span></span><span style=display:flex><span>                    q.emplace(r, c);
</span></span><span style=display:flex><span>                    visited[r][c] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>constexpr</span> std<span style=color:#f92672>::</span>array kDirs{<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> steps <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>q.empty()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> q.size();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>auto</span> [r, c] <span style=color:#f92672>=</span> q.front();
</span></span><span style=display:flex><span>                q.pop();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (grid[r][c] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;#&#39;</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> steps;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> d <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; d <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4</span>; <span style=color:#f92672>++</span>d) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>int</span> rr <span style=color:#f92672>=</span> r <span style=color:#f92672>+</span> kDirs[d];
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>int</span> cc <span style=color:#f92672>=</span> c <span style=color:#f92672>+</span> kDirs[d <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (rr <span style=color:#f92672>&gt;=</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> cc <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> rr <span style=color:#f92672>&lt;</span> rows <span style=color:#f92672>&amp;&amp;</span> cc <span style=color:#f92672>&lt;</span> cols <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                        <span style=color:#f92672>!</span>visited[rr][cc] <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                        grid[rr][cc] <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;X&#39;</span>) {
</span></span><span style=display:flex><span>                          q.emplace(rr, cc);
</span></span><span style=display:flex><span>                          visited[rr][cc] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            steps<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Time: O(mxn), Space: (mxn)</p><h4 id=716-max-stack><a href=https://leetcode.com/problems/max-stack/>716. Max Stack</a></h4><p><strong>PROBLEM STATEMENT</strong><br>Design a max stack that supports push, pop, top, peekMax and popMax.</p><ul><li>push(x) &ndash; Push element x onto stack.</li><li>pop() &ndash; Remove the element on top of the stack and return it.</li><li>top() &ndash; Get the element on the top.</li><li>peekMax() &ndash; Retrieve the maximum element in the stack.</li><li>popMax() &ndash; Retrieve the maximum element in the stack, and remove it. If you find more than one maximum elements, only remove the top-most one.</li></ul><p><strong>Keyword</strong>: Stack</p><p><strong>Solution</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MaxStack</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> push(<span style=color:#66d9ef>int</span> x) {
</span></span><span style=display:flex><span>        _data.push_back(x);
</span></span><span style=display:flex><span>        _valToIt[x].push_back(_data.rbegin());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>pop</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> val <span style=color:#f92672>=</span> _data.back();
</span></span><span style=display:flex><span>        _data.pop_back();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        _valToIt[val].pop_back();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (_valToIt[val].empty()) {
</span></span><span style=display:flex><span>            _valToIt.erase(val);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> val;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>top</span>() <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> _data.back();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>peekMax</span>() <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> _valToIt.rbegin()<span style=color:#f92672>-&gt;</span>first;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>popMax</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> _valToIt.rbegin();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> max <span style=color:#f92672>=</span> it<span style=color:#f92672>-&gt;</span>first;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> lastIt <span style=color:#f92672>=</span> it<span style=color:#f92672>-&gt;</span>second.back();
</span></span><span style=display:flex><span>        _data.erase(lastIt);
</span></span><span style=display:flex><span>        it<span style=color:#f92672>-&gt;</span>second.pop_back();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (it<span style=color:#f92672>-&gt;</span>second.empty()) {
</span></span><span style=display:flex><span>            _valToIt.erase(max);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> max;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> _Container <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>    _Container _data;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>_Container<span style=color:#f92672>::</span>iterator<span style=color:#f92672>&gt;&gt;</span> _valToIt;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><strong>Variant</strong></p><ul><li>What if we don&rsquo;t need <code>popMax()</code>, how can we improve the algorithm?</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>namespace</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MaxStack</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> push(<span style=color:#66d9ef>int</span> x) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (_data.empty()) {
</span></span><span style=display:flex><span>            _max <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>            _data.push(x);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (x <span style=color:#f92672>&gt;</span> _max) {
</span></span><span style=display:flex><span>            _data.push(encode(x));
</span></span><span style=display:flex><span>            _max <span style=color:#f92672>=</span> x
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            _data.push(x);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pop</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (_data.empty()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>; 
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> top <span style=color:#f92672>=</span> _data.top();
</span></span><span style=display:flex><span>        _data.pop();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (top <span style=color:#f92672>&gt;</span> _max) {
</span></span><span style=display:flex><span>            _max <span style=color:#f92672>=</span> decode(top);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>top</span>() <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (_data.empty()) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ... throw Exception();
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> top <span style=color:#f92672>=</span> _data.top();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> top <span style=color:#f92672>&gt;</span> _max <span style=color:#f92672>?</span> _max : top;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>peekMax</span>() <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (_data.empty()) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ... throw Exception();
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> _max;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> encode(<span style=color:#66d9ef>int</span> x) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> x <span style=color:#f92672>-</span> _max;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>decode</span>(<span style=color:#66d9ef>int</span> top) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> _max <span style=color:#f92672>-</span> top;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> _Container <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>stack<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>    _Container _data;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> _max <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=leetcode-roadmap>LeetCode Roadmap</h2><p>Reference: <a href=https://neetcode.io/roadmap>neetcode</a></p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>graph TD;
    A(Array &amp; Hashing)--&gt;B(Two Pointers);
    A--&gt;C(Stack);
    B--&gt;D(Binary Search);
    B--&gt;E(Sliding Window);
    B--&gt;F(Linked List);
    D--&gt;G(Tree);
    F--&gt;G;
    G--&gt;H(Trie);
    G--&gt;I(Heap/Priority Queue);
    G--&gt;J(Backtracking)
    I--&gt;K(Intervals);
    I--&gt;L(Greedy);
    I--&gt;M(Advanced Graph);
    J--&gt;O(Graph);
    J--&gt;P(1D DP);
    O--&gt;Q(2D DP);
    P--&gt;Q;
    P--&gt;R(Bit Manipulation);
    R--&gt;S(Math &amp; Geometry);
    O--&gt;S;
    O--&gt;M
</code></pre><h2 id=leetcode-learn-by-roi>LeetCode Learn by ROI</h2><table><thead><tr><th style=text-align:center>Topic</th><th style=text-align:center>Difficulty</th><th style=text-align:center>ROI</th></tr></thead><tbody><tr><td style=text-align:center>Basic</td><td style=text-align:center>Easy</td><td style=text-align:center>Very High</td></tr><tr><td style=text-align:center>Two Pointers</td><td style=text-align:center>Easy</td><td style=text-align:center>High</td></tr><tr><td style=text-align:center>Sliding Window</td><td style=text-align:center>Easy</td><td style=text-align:center>High</td></tr><tr><td style=text-align:center>BFS</td><td style=text-align:center>Easy</td><td style=text-align:center>High</td></tr><tr><td style=text-align:center>DFS</td><td style=text-align:center>Medium</td><td style=text-align:center>High</td></tr><tr><td style=text-align:center>Backtracking</td><td style=text-align:center>High</td><td style=text-align:center>High</td></tr><tr><td style=text-align:center>Heap</td><td style=text-align:center>Medium</td><td style=text-align:center>Medium</td></tr><tr><td style=text-align:center>Binary Search</td><td style=text-align:center>Easy</td><td style=text-align:center>Medium</td></tr><tr><td style=text-align:center>Dynamic Programming</td><td style=text-align:center>High</td><td style=text-align:center>Medium</td></tr><tr><td style=text-align:center>Divide and Conquer</td><td style=text-align:center>Medium</td><td style=text-align:center>Low</td></tr><tr><td style=text-align:center>Trie</td><td style=text-align:center>Medium</td><td style=text-align:center>Low</td></tr><tr><td style=text-align:center>Union Find</td><td style=text-align:center>Medium</td><td style=text-align:center>Low</td></tr><tr><td style=text-align:center>Greedy</td><td style=text-align:center>Medium</td><td style=text-align:center>Low</td></tr></tbody></table><h2 id=useful-templates>Useful Templates</h2><p>Reference: <a href=https://algo.monster/templates>AlgoMonster</a></p><h3 id=backtracking---aggregation>Backtracking - Aggregation</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> startIndex, std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&amp;</span> target) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (isValid(target[startIndex:])) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> edge : getEdges(startIndex, [...additional states])) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (additional states) {
</span></span><span style=display:flex><span>            update([...additional states]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ans <span style=color:#f92672>=</span> aggregate(ans, dfs(startIndex <span style=color:#f92672>+</span> edge.length(), [...additional states]));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (additional states) {
</span></span><span style=display:flex><span>            revert([...additional states]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=backtracking---basic>Backtracking - Basic</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> startIndex, std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&amp;</span> target) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (isValid(target[startIndex:])) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> edge : getEdges(startIndex, [...additional states])) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (additional states) {
</span></span><span style=display:flex><span>            update([...additional states]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ans <span style=color:#f92672>=</span> aggregate(ans, dfs(startIndex <span style=color:#f92672>+</span> edge.length(), [...additional states]));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (additional states) {
</span></span><span style=display:flex><span>            revert([...additional states]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=binary-search-1>Binary Search</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>binary_search</span>(std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> arr, <span style=color:#66d9ef>int</span> target) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> right <span style=color:#f92672>=</span> arr.size() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> firstTrueIndex <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (left <span style=color:#f92672>&lt;=</span> right) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> left <span style=color:#f92672>+</span> (right <span style=color:#f92672>-</span> left) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (feasible(mid)) {
</span></span><span style=display:flex><span>            firstTrueIndex <span style=color:#f92672>=</span> mid;
</span></span><span style=display:flex><span>            right <span style=color:#f92672>=</span> mid <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            left <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> firstTrueIndex;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=bfs-on-tree>BFS on Tree</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;*</span> bfs(Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;*</span> root) {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>queue<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;*&gt;</span> q;
</span></span><span style=display:flex><span>    q.push(root);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (q.size() <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;*</span> node <span style=color:#f92672>=</span> queue.front();
</span></span><span style=display:flex><span>        q.pop();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;*</span> child : node<span style=color:#f92672>-&gt;</span>children) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (is_goal(child)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>FOUND</span>(child);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            q.push(child);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> NOT_FOUND;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=dfs-on-tree>DFS on Tree</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;*</span> dfs(Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;*</span> root, <span style=color:#66d9ef>int</span> target) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (root<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>==</span> target) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> root;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;*</span> left <span style=color:#f92672>=</span> dfs(root<span style=color:#f92672>-&gt;</span>left, target);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (left) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> left;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dfs(root<span style=color:#f92672>-&gt;</span>right, target)  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=bfs-on-graph>BFS on Graph</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>bfs</span>(Node<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;*</span> root) {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>queue<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;*&gt;</span> q;
</span></span><span style=display:flex><span>    q.push(root);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>unordered_set<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;*&gt;</span> visited;
</span></span><span style=display:flex><span>    visited.emplace(root);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (q.size() <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;*</span> node <span style=color:#f92672>=</span> q.front();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (Node<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;*</span> neighbor : get_neighbors(node)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (visited.count(neighbor)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            q.push(neighbor);
</span></span><span style=display:flex><span>            visited.emplace(neighbor);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        q.pop();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=dfs-on-graph>DFS on Graph</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dfs</span>(Node<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;*</span> root, std<span style=color:#f92672>::</span>unordered_set<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;*&gt;&amp;</span> visited) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (Node<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;*</span> neighbor : node<span style=color:#f92672>-&gt;</span>neighbors) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (visited.count(neighbor)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        visited.emplace(neighbor);
</span></span><span style=display:flex><span>        dfs(neighbor, visited);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=bfs-on-matrix>BFS on Matrix</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> num_rows <span style=color:#f92672>=</span> grid.size();
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> num_cols <span style=color:#f92672>=</span> grid[<span style=color:#ae81ff>0</span>].size();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Coordinate<span style=color:#f92672>&gt;</span> get_neighbors(Coordinate coord) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> row <span style=color:#f92672>=</span> coord.row;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> col <span style=color:#f92672>=</span> coord.col;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> delta_row[<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> {<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> delta_col[<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Coordinate<span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> neighbor_row <span style=color:#f92672>=</span> row <span style=color:#f92672>+</span> delta_row[i];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> neighbor_col <span style=color:#f92672>=</span> col <span style=color:#f92672>+</span> delta_col[i];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#ae81ff>0</span> <span style=color:#f92672>&lt;=</span> neighbor_row <span style=color:#f92672>&amp;&amp;</span> neighbor_row <span style=color:#f92672>&lt;</span> num_rows <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>0</span> <span style=color:#f92672>&lt;=</span> neighbor_col <span style=color:#f92672>&amp;&amp;</span> neighbor_col <span style=color:#f92672>&lt;</span> num_cols) {
</span></span><span style=display:flex><span>            res.emplace_back(Coordinate(neighbor_row, neighbor_col));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>bfs</span>(Coordinate starting_node) {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>queue<span style=color:#f92672>&lt;</span>Coordinate<span style=color:#f92672>&gt;</span> q;
</span></span><span style=display:flex><span>    q.push(starting_node);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>unordered_set<span style=color:#f92672>&lt;</span>Coordinate<span style=color:#f92672>&gt;</span> visited;
</span></span><span style=display:flex><span>    visited.emplace(starting_node);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (q.size() <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        Coordinate node <span style=color:#f92672>=</span> q.front();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (Coordinate neighbor : get_neighbors(node)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (visited.count(neighbor)) <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Do stuff with the node if required
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            q.push(neighbor);
</span></span><span style=display:flex><span>            visited.emplace(neighbor);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        q.pop();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=prefix-sum>Prefix Sum</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> BuildPrefixSum(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> arr) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> arr.size();
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> prefixSum(n);
</span></span><span style=display:flex><span>    prefixSum[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> arr[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        prefixSum[i] <span style=color:#f92672>=</span> prefixSum[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> arr[i];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> prefixSum;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Query sum of range [left, right] (inclusive)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>QueryRange</span>(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> prefixSum, <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (left <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> prefixSum[right];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> prefixSum[right] <span style=color:#f92672>-</span> prefixSum[left<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=sliding-window---fixed-size>Sliding Window - Fixed Size</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>W <span style=color:#a6e22e>SlidingWindowFixed</span>(std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> input, <span style=color:#66d9ef>int</span> window_size) {
</span></span><span style=display:flex><span>    W ans <span style=color:#f92672>=</span> window <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(input.begin(), input.begin() <span style=color:#f92672>+</span> window_size);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> right <span style=color:#f92672>=</span> window_size; right <span style=color:#f92672>&lt;</span> input.size(); <span style=color:#f92672>++</span>right) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> left <span style=color:#f92672>=</span> right <span style=color:#f92672>-</span> window_size;
</span></span><span style=display:flex><span>        remove input[left] from window
</span></span><span style=display:flex><span>        append input[right] to window
</span></span><span style=display:flex><span>        ans <span style=color:#f92672>=</span> optimal(ans, window);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=sliding-window---longest>Sliding Window - Longest</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>W <span style=color:#a6e22e>SlidingWindowLongest</span>(std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> input) {
</span></span><span style=display:flex><span>    initialize window, ans
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> right <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; right <span style=color:#f92672>&lt;</span> input.size(); <span style=color:#f92672>++</span>right) {
</span></span><span style=display:flex><span>        append input[right] to window
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (invalid(window)) {
</span></span><span style=display:flex><span>            remove input[left] from window
</span></span><span style=display:flex><span>            <span style=color:#f92672>++</span>left;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        ans <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>max(ans, window);       <span style=color:#75715e>// window is guaranteed to be valid here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=sliding-window---shortest>Sliding Window - Shortest</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>W <span style=color:#a6e22e>SlidingWindowShortest</span>(std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> input) {
</span></span><span style=display:flex><span>    initialize window, ans
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> right <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; right <span style=color:#f92672>&lt;</span> input.size(); <span style=color:#f92672>++</span>right) {
</span></span><span style=display:flex><span>        append input[right] to window
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (valid(window)) {
</span></span><span style=display:flex><span>            ans <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>min(ans, window);   <span style=color:#75715e>// window is guaranteed to be valid here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            remove input[left] from window
</span></span><span style=display:flex><span>            <span style=color:#f92672>++</span>left;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=two-pointers---opposite-direction>Two Pointers - Opposite Direction</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>TwoPointersOppositeDirection</span>(std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> arr) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, right <span style=color:#f92672>=</span> arr.size() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (left <span style=color:#f92672>&lt;</span> right) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Process current elements
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> current <span style=color:#f92672>=</span> process(arr[left], arr[right]);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Update pointers based on condition
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (condition(arr[left], arr[right])) {
</span></span><span style=display:flex><span>            left<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            right<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=two-pointers---same-direction>Two Pointers - Same Direction</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>TwoPointersSameDirection</span>(std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> arr) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> slow <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, fast <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (fast <span style=color:#f92672>&lt;</span> arr.size()) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Process current elements
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> current <span style=color:#f92672>=</span> process(arr[slow], arr[fast]);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Update pointers based on condition
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (condition(arr[slow], arr[fast])) {
</span></span><span style=display:flex><span>            slow<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Fast pointer always moves forward
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        fast<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=how-to-answer-coding-questions-in-interview>How to Answer Coding Questions in Interview</h2><p>This approach can be used for many company interviews. So here it goes:</p><ul><li>When asked to provide a solution, first <strong>define and frame the problem</strong> as you see it.</li><li>If you don’t understand — ask for help or clarification.</li><li>If you need to assume something — verbally check its a correct assumption!</li><li>Always let your interviewer know what you are thinking as he/she will be as interested in your process of thought as your solution.</li><li>Also, if you’re stuck, they may provide hints if they know what you’re doing.</li><li>Finally, listen — don’t miss a hint if your interviewer is trying to assist you!</li></ul><p>Interviewers will be looking at the approach to questions as much as the answer:</p><ul><li>Does the candidate listen carefully and comprehend the question?</li><li>Are the correct questions asked before proceeding? (important!)</li><li>Is brute force used to solve a problem? (not good!)</li><li>Are things assumed without first checking? (not good!)</li><li>Are hints heard and needed?</li><li>Is the candidate slow to comprehend / solve problems? (not good!)</li><li>Does the candidate enjoy finding multiple solutions before choosing the best one?</li><li>Are new ideas and methods of tackling a problem sought?</li><li>Is the candidate inventive and flexible in their solutions and open to new ideas?</li><li>Can questioning move up to more complex problem solving?</li></ul><h2 id=binary-search-2>Binary Search</h2><h3 id=most-generalize-binary-search>Most Generalize Binary Search</h3><p>Suppose we have a search space. It could be an array, a range, etc. Usually it&rsquo;s sorted in ascending order. For most tasks, we can transform the requirement into the following generalized form:</p><p>Minimize k , s.t. condition(k) is True</p><p>The following code is the most generalized binary search template:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>binary_search</span>(array) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>condition</span>(value) <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    left, right <span style=color:#f92672>=</span> min(search_space), max(search_space) <span style=color:#75715e># could be [0, n], [1, n] etc. Depends on problem</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> left <span style=color:#f92672>&lt;</span> right:
</span></span><span style=display:flex><span>        mid <span style=color:#f92672>=</span> left <span style=color:#f92672>+</span> (right <span style=color:#f92672>-</span> left) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> condition(mid):
</span></span><span style=display:flex><span>            right <span style=color:#f92672>=</span> mid
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            left <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> left
</span></span></code></pre></div><p>What&rsquo;s really nice of this template is that, for most of the binary search problems, we only need to modify three parts after copy-pasting this template, and never need to worry about corner cases and bugs in code any more:</p><ul><li>Correctly initialize the boundary variables left and right to specify search space. Only one rule: set up the boundary to <strong>include all possible elements</strong>;</li><li>Decide return value. Is it return left or return left - 1? Remember this: <strong>after exiting the while loop, left is the minimal k​ satisfying the condition function</strong>;</li><li>Design the condition function. This is the most difficult and most beautiful part. Needs lots of practice.</li></ul><h3 id=advanced-application>Advanced Application</h3><p>The above problems are quite easy to solve, because they already give us the array to be searched. We&rsquo;d know that we should use binary search to solve them at first glance. However, more often are the situations where the search space and search target are not so readily available. Sometimes we won&rsquo;t even realize that the problem should be solved with binary search &ndash; we might just turn to dynamic programming or DFS and get stuck for a very long time.</p><p>As for the question &ldquo;When can we use binary search?&rdquo;, my answer is that, If we can discover some kind of monotonicity, for example, if condition(k) is True then condition(k + 1) is True, then we can consider binary search.</p></article></div></div><div class="col-sm-12 col-md-12 col-lg-3"><div id=stickySideBar class=sticky-sidebar><aside class=toc><h5>Table Of Contents</h5><div class=toc-content><nav id=TableOfContents><ul><li><a href=#array--hashing>Array & Hashing</a><ul><li></li></ul></li><li><a href=#intervals>Intervals</a><ul><li></li></ul></li><li><a href=#stack>Stack</a></li><li><a href=#binary-tree-general>Binary Tree General</a><ul><li></li><li><a href=#graph-general>Graph General</a></li></ul></li><li><a href=#binary-operation>Binary Operation</a><ul><li></li></ul></li><li><a href=#binary-tree>Binary Tree</a><ul><li></li></ul></li><li><a href=#binary-search-treebst>Binary Search Tree(BST)</a><ul><li></li></ul></li><li><a href=#binary-search>Binary Search</a><ul><li></li></ul></li><li><a href=#string>String</a><ul><li></li><li><a href=#two-sums>Two Sums</a></li><li><a href=#graph>Graph</a></li></ul></li><li><a href=#dynamic-programming>Dynamic Programming</a><ul><li></li><li><a href=#bit-manipulation>Bit Manipulation</a></li></ul></li><li><a href=#leetcode-roadmap>LeetCode Roadmap</a></li><li><a href=#leetcode-learn-by-roi>LeetCode Learn by ROI</a></li><li><a href=#useful-templates>Useful Templates</a><ul><li><a href=#backtracking---aggregation>Backtracking - Aggregation</a></li><li><a href=#backtracking---basic>Backtracking - Basic</a></li><li><a href=#binary-search-1>Binary Search</a></li><li><a href=#bfs-on-tree>BFS on Tree</a></li><li><a href=#dfs-on-tree>DFS on Tree</a></li><li><a href=#bfs-on-graph>BFS on Graph</a></li><li><a href=#dfs-on-graph>DFS on Graph</a></li><li><a href=#bfs-on-matrix>BFS on Matrix</a></li><li><a href=#prefix-sum>Prefix Sum</a></li><li><a href=#sliding-window---fixed-size>Sliding Window - Fixed Size</a></li><li><a href=#sliding-window---longest>Sliding Window - Longest</a></li><li><a href=#sliding-window---shortest>Sliding Window - Shortest</a></li><li><a href=#two-pointers---opposite-direction>Two Pointers - Opposite Direction</a></li><li><a href=#two-pointers---same-direction>Two Pointers - Same Direction</a></li></ul></li><li><a href=#how-to-answer-coding-questions-in-interview>How to Answer Coding Questions in Interview</a></li><li><a href=#binary-search-2>Binary Search</a><ul><li><a href=#most-generalize-binary-search>Most Generalize Binary Search</a></li><li><a href=#advanced-application>Advanced Application</a></li></ul></li></ul></nav></div></aside><aside class=social><h5>Social</h5><div class=social-content><ul class=list-inline><li class="list-inline-item text-center"><a target=_blank href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fbobblelaw.github.io%2ftopics%2finterview%2fleetcode-top-interview%2f"><i class="fab fa-linkedin"></i></a></li><li class="list-inline-item text-center"><a target=_blank href="https://twitter.com/share?text=&url=https%3a%2f%2fbobblelaw.github.io%2ftopics%2finterview%2fleetcode-top-interview%2f"><i class="fab fa-twitter"></i></a></li><li class="list-inline-item text-center"><a target=_blank href="https://api.whatsapp.com/send?text=: https%3a%2f%2fbobblelaw.github.io%2ftopics%2finterview%2fleetcode-top-interview%2f"><i class="fab fa-whatsapp"></i></a></li><li class="list-inline-item text-center"><a target=_blank href='mailto:?subject=&amp;body=Check%20out%20this%20site https%3a%2f%2fbobblelaw.github.io%2ftopics%2finterview%2fleetcode-top-interview%2f'><i class="fa fa-envelope"></i></a></li></ul></div></aside></div></div></div><div class=row><div class="col-sm-12 col-md-12 col-lg-9 p-4"></div></div></div><button class="p-2 px-3" onclick=topFunction() id=topScroll>
<i class="fas fa-angle-up"></i></button></section><div class=progress><div id=scroll-progress-bar class=progress-bar role=progressbar aria-valuenow=0 aria-valuemin=0 aria-valuemax=100></div></div><script src=/js/scrollProgressBar.js></script><script>var topScroll=document.getElementById("topScroll");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?topScroll.style.display="block":topScroll.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}let stickySideBarElem=document.getElementById("stickySideBar"),stickyNavBar=!0;if(stickyNavBar){let e=document.getElementById("profileHeader"),t=e.offsetHeight+15;stickySideBarElem.style.top=t+"px"}else stickySideBarElem.style.top="50px"</script><script src=/js/readingTime.js></script></div><footer><div class="text-center pt-2"><span class=px-1><a href=https://github.com/BobbleLaw aria-label=github><svg width="2.7em" height="2.7em" viewBox="0 0 1792 1792"><path id="footer-socialNetworks-github-svg-path" d="M522 1352q-8 9-20-3-13-11-4-19 8-9 20 3 12 11 4 19zm-42-61q9 12 0 19-8 6-17-7t0-18q9-7 17 6zm-61-60q-5 7-13 2-10-5-7-12 3-5 13-2 10 5 7 12zm31 34q-6 7-16-3-9-11-2-16 6-6 16 3 9 11 2 16zm129 112q-4 12-19 6-17-4-13-15t19-7q16 5 13 16zm63 5q0 11-16 11-17 2-17-11 0-11 16-11 17-2 17 11zm58-10q2 10-14 14t-18-8 14-15q16-2 18 9zm964-956v960q0 119-84.5 203.5T1376 1664h-224q-16 0-24.5-1t-19.5-5-16-14.5-5-27.5v-239q0-97-52-142 57-6 102.5-18t94-39 81-66.5 53-105T1386 856q0-121-79-206 37-91-8-204-28-9-81 11t-92 44l-38 24q-93-26-192-26t-192 26q-16-11-42.5-27T578 459.5 492 446q-44 113-7 204-79 85-79 206 0 85 20.5 150t52.5 105 80.5 67 94 39 102.5 18q-40 36-49 103-21 10-45 15t-57 5-65.5-21.5T484 1274q-19-32-48.5-52t-49.5-24l-20-3q-21 0-29 4.5t-5 11.5 9 14 13 12l7 5q22 10 43.5 38t31.5 51l10 23q13 38 44 61.5t67 30 69.5 7 55.5-3.5l23-4q0 38 .5 103t.5 68q0 22-11 33.5t-22 13-33 1.5H416q-119 0-203.5-84.5T128 1376V416q0-119 84.5-203.5T416 128h960q119 0 203.5 84.5T1664 416z"/></svg>
</a></span><span class=px-1><a href=https://www.linkedin.com/in/boblzy aria-label=linkedin><svg width="2.4em" height="2.4em" fill="#fff" aria-label="LinkedIn" viewBox="0 0 512 512"><rect width="512" height="512" fill="#0077b5" rx="15%"/><circle cx="142" cy="138" r="37"/><path stroke="#fff" stroke-width="66" d="M244 194v198M142 194v198"/><path d="M276 282c0-20 13-40 36-40 24 0 33 18 33 45v105h66V279c0-61-32-89-76-89-34 0-51 19-59 32"/></svg></a></span></div><div class="container py-4"><div class="row justify-content-center"><div class="col-md-4 text-center"><div class=pb-2><a href=https://bobblelaw.github.io/ title="Bobble Law"><img alt="Footer logo" src=/logo.png height=40px width=40px></a></div>&copy; 2025 All rights reserved<div class=text-secondary>Made with
<span class=text-danger>&#10084;
</span>and
<a href=https://github.com/gurusabarish/hugo-profile target=_blank title="Designed and developed by gurusabarish">Hugo Profile</a></div></div></div></div></footer><script src=/bootstrap-5/js/bootstrap.bundle.min.js></script><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))});var tooltipTriggerList=[].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]')),tooltipList=tooltipTriggerList.map(function(e){return new bootstrap.Tooltip(e)})</script><script src=/js/search.js></script><section id=search-content class=py-2><div class=container id=search-results></div></section></body></html>