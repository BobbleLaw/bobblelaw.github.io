<!doctype html><html lang=en dir=ltr class=dark><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Sort Multiple Ranges | Bobble Law</title><meta name=generator content="Hugo Eureka 0.9.3"><link rel=stylesheet href=https://bobblelaw.github.io/css/eureka.min.9cec6350e37e534b0338fa9a085bf06855de3b0f2dcf857e792e5e97b07ea905d4d5513db554cbc26a9c3da622bae92d.css><script defer src=https://bobblelaw.github.io/js/eureka.min.fa9a6bf6d7a50bb635b4cca7d2ba5cf3dfb095ae3798773f1328f7950028b48c17d06276594e1b5f244a25a6c969a705.js></script>
<link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap" as=style onload='this.onload=null,this.rel="stylesheet"'><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/styles/base16/solarized-light.min.css media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/highlight.min.js crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/cpp,%20swift,%20python.min.js crossorigin></script>
<link rel=stylesheet href=https://bobblelaw.github.io/css/highlightjs.min.2958991528e43eb6fc9b8c4f2b8e052f79c4010718e1d1e888a777620e9ee63021c2c57ec7417a3108019bb8c41943e6.css media=print onload='this.media="all",this.onload=null'><script defer type=text/javascript src=https://bobblelaw.github.io/js/fontawesome.min.a975d08212c5439f29e6074e7ad58e159ae1ef5efb6a31962fa3b6885557e794dd9315f4a8a16d705066d023f4eaaf07.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><script defer src=https://cdn.jsdelivr.net/npm/mermaid@8.14.0/dist/mermaid.min.js integrity=sha384-atOyb0FxAgN9LyAc6PEf9BjgwLISyansgdH8/VXQH8p2o5vfrRgmGIJ2Sg22L0A0 crossorigin></script>
<link rel=icon type=image/png sizes=32x32 href=https://bobblelaw.github.io/images/icon_hucb7ee3c6385b6f166198d69440e1110c_52330_32x32_fill_box_center_3.png><link rel=apple-touch-icon sizes=180x180 href=https://bobblelaw.github.io/images/icon_hucb7ee3c6385b6f166198d69440e1110c_52330_180x180_fill_box_center_3.png><meta name=description content="Sorting a range of keys while keeping a range of values in sync."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bobblelaw.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Sort Multiple Ranges","item":"https://bobblelaw.github.io/posts/sort-multiple-range/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://bobblelaw.github.io/posts/sort-multiple-range/"},"headline":"Sort Multiple Ranges | Bobble Law","datePublished":"2020-11-28T09:45:32+08:00","dateModified":"2022-11-20T22:52:56+08:00","wordCount":1778,"author":{"@type":"Person","name":["host"]},"publisher":{"@type":"Person","name":"Bob Law","logo":{"@type":"ImageObject","url":"https://bobblelaw.github.io/images/icon.png"}},"description":"Sorting a range of keys while keeping a range of values in sync."}</script><meta property="og:title" content="Sort Multiple Ranges | Bobble Law"><meta property="og:type" content="article"><meta property="og:image" content="https://bobblelaw.github.io/images/icon.png"><meta property="og:url" content="https://bobblelaw.github.io/posts/sort-multiple-range/"><meta property="og:description" content="Sorting a range of keys while keeping a range of values in sync."><meta property="og:locale" content="en"><meta property="og:site_name" content="Bobble Law"><meta property="article:published_time" content="2020-11-28T09:45:32+08:00"><meta property="article:modified_time" content="2022-11-20T22:52:56+08:00"><meta property="article:section" content="posts"><meta property="article:tag" content="C++"><meta property="og:see_also" content="https://bobblelaw.github.io/posts/range-ref/"><meta property="og:see_also" content="https://bobblelaw.github.io/posts/recursive-lambda-function/"><meta property="og:see_also" content="https://bobblelaw.github.io/posts/floating-point-optimizations/"><body class="flex min-h-screen flex-col"><header class="min-h-16 pl-scrollbar bg-secondary-bg fixed z-50 flex w-full items-center shadow-sm"><div class="mx-auto w-full max-w-screen-xl"><script>let storageColorScheme=localStorage.getItem("lightDarkMode");(storageColorScheme=="Auto"&&window.matchMedia("(prefers-color-scheme: light)").matches||storageColorScheme=="Light")&&document.getElementsByTagName("html")[0].classList.remove("dark")</script><nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0"><a href=/ class="me-6 text-primary-text text-xl font-bold">Bobble Law</a>
<button id=navbar-btn class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
<i class="fas fa-bars"></i></button><div id=target class="hidden block md:flex md:grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20"><div class="md:flex md:h-16 text-sm md:grow pb-4 md:pb-0 border-b md:border-b-0"><a href=/#about class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">About</a>
<a href=/posts/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 selected-menu-item me-4">Posts</a>
<a href=/docs/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">Topics</a></div><div class=flex><div class="relative pt-4 md:pt-0"><div class="cursor-pointer hover:text-eureka" id=lightDarkMode><i class="fas fa-moon"></i></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id=is-open></div><div class="absolute flex flex-col start-0 md:start-auto end-auto md:end-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40" id=lightDarkOptions><span class="px-4 py-1 hover:text-eureka" name=Light>Light</span>
<span class="px-4 py-1 hover:text-eureka" name=Dark>Dark</span>
<span class="px-4 py-1 hover:text-eureka" name=Auto>Auto</span></div></div></div></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id=is-open-mobile></div></nav><script>let element=document.getElementById("lightDarkMode");storageColorScheme=="Auto"?(element.firstElementChild.classList.remove("fa-moon"),element.firstElementChild.setAttribute("data-icon","adjust"),element.firstElementChild.classList.add("fa-adjust"),document.addEventListener("DOMContentLoaded",()=>{window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",switchDarkMode)})):storageColorScheme=="Light"&&(element.firstElementChild.classList.remove("fa-moon"),element.firstElementChild.setAttribute("data-icon","sun"),element.firstElementChild.classList.add("fa-sun")),document.addEventListener("DOMContentLoaded",()=>{getcolorscheme(),switchBurger()})</script></div></header><main class="grow pt-16"><div class=pl-scrollbar><div class="mx-auto w-full max-w-screen-xl lg:px-4 xl:px-8"><div class="grid grid-cols-2 gap-4 lg:grid-cols-8 lg:pt-12"><div class="lg:col-start-2 bg-secondary-bg col-span-2 rounded px-6 py-8 lg:col-span-6"><article class=prose><h1 class=mb-4>Sort Multiple Ranges</h1><div class="text-tertiary-text not-prose mt-2 flex flex-row flex-wrap items-center"><div class="me-6 my-2"><i class="fas fa-calendar me-1"></i>
<span>2020-11-28</span></div><div class="me-6 my-2"><i class="fas fa-clock me-1"></i>
<span>9 min read</span></div></div><p><code>std::sort</code> is a great utility.
You can easily sort subranges and provide custom comparison functions.
However, it struggles with the following scenario:</p><pre><code class=language-cpp>std::vector&lt;int&gt; keys = ...;
std::vector&lt;std::string&gt; values = ...;

std::sort(...); // ???
</code></pre><p>We want to sort by <code>keys</code> but keep the 1-on-1 correspondence with <code>values</code>, i.e. keep the ranges &ldquo;in sync&rdquo; during sorting.
A common solution is to allocate a vector of indices, sort these indices, and then apply the resulting permutation.
However, the need for an additional allocation and bad cache locality due to indirection make this a suboptimal solution.</p><p>In this post, we will design a custom iterator that allows us to sort the two ranges directly without allocation overhead.
The final usage will be:</p><pre><code class=language-cpp>std::sort(sort_it{          0, keys.data(), values.data()},
          sort_it{keys.size(), keys.data(), values.data()});
</code></pre><p>For clarity of exposition, we will assume <code>int</code> keys, <code>string</code> values, and contiguous ranges for this post.
Making the technique generic, variadic, and support all random access iterators is left as an exercise for the reader (or an additional blog post).</p><h2 id=the-index-solution>The Index Solution</h2><p>Before we start, let&rsquo;s take a quick look at the mentioned index-based solution:</p><pre><code class=language-cpp>// make indices = {0, 1, 2, ...}
auto indices = std::vector&lt;int&gt;(keys.size());
std::iota(indices.begin(), indices.end(), 0);

// sort indices while comparing keys
std::sort(indices.begin(), indices.end(), [&amp;keys](int a, int b) {
    return keys[a] &lt; keys[b];
});

// apply permutation
auto old_keys = keys; // copy
auto old_values = values; // copy
for (size_t i = 0; i &lt; keys.size(); ++i) 
{
    keys[i] = old_keys[indices[i]];
    values[i] = old_values[indices[i]];
}
</code></pre><p>The first allocation is needed for the temporary <code>indices</code> vector.
Slightly more non-obvious is the need for copies of <code>keys</code> and <code>values</code> before applying the permutation.
A simple <code>keys[i] = keys[indices[i]];</code> would yield the wrong result (imagine what happens if <code>keys[indices[i]]</code> was already overwritten in a previous loop iteration).</p><p>There are ways to avoid the key/value copies but they are quite a bit more involved.
Permutations can be decomposed into disjoint cycles and then applied via a cycling swap for each cycle.
Alternatively, permutations can also be decomposed into a series of transpositions, i.e. a sequence of <code>std::swap(keys[i], keys[j])</code>.</p><h2 id=a-custom-iterator>A Custom Iterator</h2><p>Ok, let&rsquo;s design a non-allocating &ldquo;multi-sort&rdquo; solution.</p><p><code>std::sort</code> accepts any random access iterator (technically, the iterator must satisfy the <a href=https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator>LegacyRandomAccessIterator</a> and <a href=https://en.cppreference.com/w/cpp/named_req/ValueSwappable>ValueSwappable</a> concepts).
Thus, we should be able to write an iterator that basically &ldquo;bundles&rdquo; iterators into <code>keys</code> and <code>values</code>, compares <code>keys</code>, and swaps both, thus keeping the ranges in sync.</p><pre><code class=language-cpp>struct sort_it
{
    size_t index;
    int* keys;
    std::string* values;
};
</code></pre><p>The idea is that the iterator only updates <code>index</code> and keeps the pointers to <code>keys</code> and <code>values</code> unchanged.
Iterators need to provide a certain set of operations, <a href=https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator>LegacyRandomAccessIterator</a> a whole zoo of them.</p><p>First, we define some types in our <code>sort_it</code>:</p><pre><code class=language-cpp>using iterator_category = std::random_access_iterator_tag;
using difference_type = int64_t;
using value_type = ???;
using pointer = value_type*;
using reference = ???;
</code></pre><h2 id=the-reference-and-value-problem>The Reference and Value Problem</h2><p>Usually, <code>value_type</code> is some type <code>T</code> and we would choose <code>reference</code> to be <code>T&</code>.
However, in our case, this doesn&rsquo;t work.
<code>value_type</code> would be something like <code>pair&lt;int, string></code>.
But <code>reference</code> cannot be <code>pair&lt;int, string>&</code>, as we have two separate arrays, not a single array of pairs.
Thus, we have to roll our own, separate types for them.
Let&rsquo;s call these <code>val</code> and <code>ref</code>:</p><pre><code class=language-cpp>struct val
{
    int key;
    std::string value;
};

struct ref
{
    int* key;
    std::string* value;
};

struct sort_it 
{
    ...
    using value_type = val;
    using reference = ref;
    ...
};
</code></pre><p><code>std::sort</code> uses more than one sorting algorithm in most implementations.
Usually, we see some <code>O(n log n)</code> algorithm (e.g. quicksort) for large ranges and an <code>O(n^2)</code> algorithm (like insertion sort) for small ranges, as they tend to be faster for small <code>n</code> in practice.
Some of these use <code>swap</code>, some do not.
When reading the gcc implementation, I found that we need to support the following uses:</p><pre><code class=language-cpp>// case A:
std::iter_swap(it_a, it_b);
// ... which calls:
swap(*it_a, *it_b);

// case B:
value_type v = std::move(*it);
*it = std::move(*other_it);
*other_it = std::move(v);
</code></pre><p>Our iterator returns <code>ref</code> via <code>sort_it::operator*()</code>.
This is used directly in <code>swap</code>, so we need to provide a <code>swap(ref, ref)</code>.
Note that <code>ref</code> is passed by value and cannot be <code>ref&</code> as <code>*it</code> is not an lvalue.
The desired semantic is, of course, to swap where <code>ref</code> points to, not the pointers in <code>ref</code> themselves.
We provide <code>swap</code> via <a href=https://en.cppreference.com/w/cpp/language/friend>(hidden) friend</a> in <code>ref</code>:</p><pre><code class=language-cpp>struct ref
{
    ...

    friend void swap(ref a, ref b)
    {
        using std::swap;
        swap(*a.key, *b.key);
        swap(*a.value, *b.value);
    }
};
</code></pre><p>That solves case A.</p><p>Case B needs a bit more attention.</p><p>First, we have <code>value_type v = std::move(*it);</code>, where <code>val</code> has to be implicitly constructible from <code>ref&&</code>.
The intention is to move a value temporarily out of the range and later &ldquo;return&rdquo; it via <code>*other_it = std::move(v);</code>.
This implicit conversion can be simply provided by a <a href=https://en.cppreference.com/w/cpp/language/cast_operator>user-defined conversion operator</a>:</p><pre><code class=language-cpp>struct ref
{
    ...

    operator val() &amp;&amp; { return {std::move(*key), std::move(*value)}; }
};
</code></pre><p>Note the <code>&&</code> at the end of the signature.
This is a <a href=https://en.cppreference.com/w/cpp/language/member_functions#ref-qualified_member_functions>ref-qualified member function</a> and basically means that the <code>ref</code> to <code>val</code> conversion is only allowed for rvalue <code>ref&&</code>s.
Thus, we can safely move <code>key</code> and <code>value</code> into our <code>val</code> and no <code>std::string</code> was copied in the process.</p><p>Alternatively, we could have added a <code>val(ref&&)</code> constructor to <code>val</code>.</p><p>The &ldquo;inverse&rdquo; operator of <code>ref&&</code> to <code>val</code> is done at <code>*other_it = std::move(v);</code>.
This is a <a href=https://en.cppreference.com/w/cpp/language/operator_assignment>simple assignment operator</a>, accepting <code>val&&</code>:</p><pre><code class=language-cpp>struct ref
{
    ...

    ref&amp; operator=(val&amp;&amp; v)
    {
        *key = std::move(v.key);
        *value = std::move(v.value);
        return *this;
    }
};
</code></pre><p>There is one, slightly weird assignment left: <code>*it = std::move(*other_it);</code>.
Here, we assign <code>ref&&</code> to <code>ref</code> and the semantics is to move what <code>*other_it</code> points to into what <code>*it</code> points to.
Implementation-wise, this is another simple assignment:</p><pre><code class=language-cpp>struct ref
{
    ...

    ref&amp; operator=(ref&amp;&amp; r)
    {
        *key = std::move(*r.key);
        *value = std::move(*r.value);
        return *this;
    }
};
</code></pre><p>And with this, we have finally modelled the &ldquo;reference semantics&rdquo; of <code>ref</code> and proper interactions with <code>val</code>.</p><h2 id=remaining-operators>Remaining Operators</h2><p>There are two classes of operators missing.</p><p>First, we want properly defined default comparison, i.e. by default, <code>std::sort</code> should sort by <code>operator&lt;</code> of our keys.
Unfortunately, almost all combinations are <code>ref</code> and <code>val</code> are actually used.
We have <code>*it_a &lt; *it_b</code>, <code>v &lt; *it</code>, and <code>*it &lt; v</code>.
The only missing combination is <code>val &lt; val</code>.
Our implicit conversion from <code>ref&&</code> to <code>val</code> is moving values, which we obviously don&rsquo;t want for a comparison.
Thus, we simply define all needed combinations:</p><pre><code class=language-cpp>bool operator&lt;(ref const&amp; a, val const&amp; b)
{
    return *a.key &lt; b.key;
}

bool operator&lt;(val const&amp; a, ref const&amp; b)
{
    return a.key &lt; *b.key;
}

bool operator&lt;(ref const&amp; a, ref const&amp; b)
{
    return *a.key &lt; *b.key;
}
</code></pre><p>Secondly, we need the previously mentioned zoo of random access iterator operators.
The only slightly interesting one in our case is <code>operator*</code> for producing <code>ref</code>:</p><pre><code class=language-cpp>struct sort_it
{
    ...

    ref operator*() { return {keys + index, values + index}; }
};
</code></pre><p>All the others are the typical <code>==</code>, <code>!=</code>, <code>+</code>, <code>-</code>, <code>++</code>, <code>--</code>, <code>&lt;</code>, etc. that you&rsquo;d expect of a random access iterator.
I was too lazy to implement all of them and only did what I needed for <code>std::sort</code> on gcc:</p><pre><code class=language-cpp>struct sort_it
{
    ...

    bool operator==(sort_it const&amp; r) const { return index == r.index; }
    bool operator!=(sort_it const&amp; r) const { return index != r.index; }

    sort_it operator+(difference_type i) const { return {index + i, keys, values}; }
    sort_it operator-(difference_type i) const { return {index - i, keys, values}; }

    difference_type operator-(sort_it const&amp; r) const 
    { 
        return difference_type(index) - difference_type(r.index); 
    }

    sort_it&amp; operator++()
    {
        ++index;
        return *this;
    }
    sort_it&amp; operator--()
    {
        --index;
        return *this;
    }

    bool operator&lt;(sort_it const&amp; r) const { return index &lt; r.index; }
};
</code></pre><p>In C++20, we would need to implement all operators as the <a href=https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator>associated concept</a> would be checked.
Of course, in a production-grade implementation, we would also implement them all.</p><p>And with this, we&rsquo;re done.</p><p>Now, the example in the introduction works:</p><pre><code class=language-cpp>std::vector&lt;int&gt; keys = ...;
std::vector&lt;std::string&gt; values = ...;

std::sort(sort_it{          0, keys.data(), values.data()},
          sort_it{keys.size(), keys.data(), values.data()});
</code></pre><h2 id=final-version>Final Version</h2><p>A fully working example can be found <a href=https://godbolt.org/z/fb76e1>here on godbolt</a>.
I&rsquo;ve added a <code>main</code> function, so be sure to check the output.</p><p>Our custom iterator, value, and reference type is below 100 LOC, so it&rsquo;s almost a compact solution!</p><pre><code class=language-cpp>struct val
{
    int key;
    std::string value;
};

struct ref
{
    int* key;
    std::string* value;

    ref&amp; operator=(ref&amp;&amp; r)
    {
        *key = std::move(*r.key);
        *value = std::move(*r.value);
        return *this;
    }

    ref&amp; operator=(val&amp;&amp; r)
    {
        *key = std::move(r.key);
        *value = std::move(r.value);
        return *this;
    }

    friend void swap(ref a, ref b)
    {
        std::swap(*a.key, *b.key);
        std::swap(*a.value, *b.value);
    }

    operator val() &amp;&amp; { return {std::move(*key), std::move(*value)}; }
};

bool operator&lt;(ref const&amp; a, val const&amp; b)
{
    return *a.key &lt; b.key;
}

bool operator&lt;(val const&amp; a, ref const&amp; b)
{
    return a.key &lt; *b.key;
}

bool operator&lt;(ref const&amp; a, ref const&amp; b)
{
    return *a.key &lt; *b.key;
}

struct sort_it
{
    using iterator_category = std::random_access_iterator_tag;
    using difference_type = int64_t;
    using value_type = val;
    using pointer = value_type*;
    using reference = ref;

    size_t index;
    int* keys;
    std::string* values;

    bool operator==(sort_it const&amp; r) const { return index == r.index; }
    bool operator!=(sort_it const&amp; r) const { return index != r.index; }

    sort_it operator+(difference_type i) const { return {index + i, keys, values}; }
    sort_it operator-(difference_type i) const { return {index - i, keys, values}; }
    
    difference_type operator-(sort_it const&amp; r) const 
    { 
        return difference_type(index) - difference_type(r.index); 
    }
    
    sort_it&amp; operator++()
    {
        ++index;
        return *this;
    }
    sort_it&amp; operator--()
    {
        --index;
        return *this;
    }

    bool operator&lt;(sort_it const&amp; r) const { return index &lt; r.index; }

    ref operator*() { return {keys + index, values + index}; }
};
</code></pre><h2 id=summary>Summary</h2><p>We set out to write a custom iterator that is able to sort two ranges in parallel, treating one as the &ldquo;key&rdquo; and the other as &ldquo;value&rdquo; that has to be kept in sync.
<code>swap</code> alone was not sufficient to get the correct behavior, as some parts of the <code>std::sort</code> implementation operate on <code>value_type</code> and <code>reference</code> directly.
Thus, we created custom <code>ref</code> and <code>val</code> structs and implemented all required operators to model the proper semantics.
Note that we could not use <code>val&</code> as the reference type because our ranges are independent and do not store elements of type <code>val</code>.</p><p>The result is a custom random access iterator <code>sort_it</code> that keeps the two ranges in sync, as can be seen in <a href=https://godbolt.org/z/fb76e1>this example on godbolt</a>.</p><p>For a production-grade implementation, there are a few additional concerns:</p><ul><li>all required operators for the <a href=https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator>random access iterator</a> should be implemented</li><li><code>sort_it</code>, <code>ref</code>, and <code>val</code> should be templated on key and value type</li><li><code>sort_it</code> and <code>ref</code> should not use pointers, but other random access iterators</li><li>the whole system could be made variadic and support arbitrary many value ranges</li></ul></article><div class=my-4><a href=https://bobblelaw.github.io/tags/c++/ class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#C++</a></div><div class=py-2><div class="my-8 flex flex-col items-center md:flex-row"><a href=https://bobblelaw.github.io/authors/host/ class="md:me-4 text-primary-text h-24 w-24"><img src=https://bobblelaw.github.io/images/cartoon_me.png class="bg-primary-bg w-full rounded-full" alt=Avatar></a><div class="mt-4 w-full md:mt-0 md:w-auto"><a href=https://bobblelaw.github.io/authors/host/ class="mb-2 block border-b pb-1 text-lg font-bold"><h3>Lo, Tszwan</h3></a><span class="block pb-2"></span>
<a href=mailto:bobble2579@hotmail.com class=me-2><i class="fas fa-envelope"></i></a>
<a href=https://github.com/BobbleLaw class=me-2><i class="fab fa-github"></i></a></div></div></div><div class="-mx-2 mt-4 flex flex-col border-t px-2 pt-4 md:flex-row md:justify-between"><div><span class="text-primary-text block font-bold">Previous</span>
<a href=https://bobblelaw.github.io/posts/unordered-map-usage-and-performance/ class=block>std::unordered_map Performance and Usage</a></div><div class="mt-4 md:mt-0 md:text-right"><span class="text-primary-text block font-bold">Next</span>
<a href=https://bobblelaw.github.io/posts/range-ref/ class=block>range_ref&lt;T></a></div></div></div><div class="lg:col-start-2 bg-secondary-bg prose col-span-2 rounded p-6 lg:col-span-6"><h3>See Also</h3><a href=https://bobblelaw.github.io/posts/range-ref/ class=no-underline>range_ref&lt;T></a><br><a href=https://bobblelaw.github.io/posts/recursive-lambda-function/ class=no-underline>Recursive Lambdas</a><br><a href=https://bobblelaw.github.io/posts/floating-point-optimizations/ class=no-underline>Basic Floating Point Optimizations</a><br></div></div><script>document.addEventListener("DOMContentLoaded",()=>{hljs.highlightAll()})</script></div></div></main><footer class=pl-scrollbar><div class="mx-auto w-full max-w-screen-xl"><div class="text-center p-6 pin-b"><p class="text-sm text-tertiary-text">&copy; 2022 <a href=#>Bobble Law</a> and <a href=#>Stay Inc.</a>
&#183; Powered by the <a href=https://github.com/wangchucheng/hugo-eureka class=hover:text-eureka>Eureka</a> theme for <a href=https://gohugo.io class=hover:text-eureka>Hugo</a></p></div></div></footer></body></html>