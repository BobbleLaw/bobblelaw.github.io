<!doctype html><html lang=en dir=ltr class=dark><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Moves in Returns | Bobble Law</title><meta name=generator content="Hugo Eureka 0.9.3"><link rel=stylesheet href=https://bobblelaw.github.io/css/eureka.min.9cec6350e37e534b0338fa9a085bf06855de3b0f2dcf857e792e5e97b07ea905d4d5513db554cbc26a9c3da622bae92d.css><script defer src=https://bobblelaw.github.io/js/eureka.min.fa9a6bf6d7a50bb635b4cca7d2ba5cf3dfb095ae3798773f1328f7950028b48c17d06276594e1b5f244a25a6c969a705.js></script>
<link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap" as=style onload='this.onload=null,this.rel="stylesheet"'><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/styles/base16/solarized-light.min.css media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/highlight.min.js crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/cpp,%20swift,%20python.min.js crossorigin></script>
<link rel=stylesheet href=https://bobblelaw.github.io/css/highlightjs.min.2958991528e43eb6fc9b8c4f2b8e052f79c4010718e1d1e888a777620e9ee63021c2c57ec7417a3108019bb8c41943e6.css media=print onload='this.media="all",this.onload=null'><script defer type=text/javascript src=https://bobblelaw.github.io/js/fontawesome.min.a975d08212c5439f29e6074e7ad58e159ae1ef5efb6a31962fa3b6885557e794dd9315f4a8a16d705066d023f4eaaf07.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><script defer src=https://cdn.jsdelivr.net/npm/mermaid@8.14.0/dist/mermaid.min.js integrity=sha384-atOyb0FxAgN9LyAc6PEf9BjgwLISyansgdH8/VXQH8p2o5vfrRgmGIJ2Sg22L0A0 crossorigin></script>
<link rel=icon type=image/png sizes=32x32 href=https://bobblelaw.github.io/images/icon_hucb7ee3c6385b6f166198d69440e1110c_52330_32x32_fill_box_center_3.png><link rel=apple-touch-icon sizes=180x180 href=https://bobblelaw.github.io/images/icon_hucb7ee3c6385b6f166198d69440e1110c_52330_180x180_fill_box_center_3.png><meta name=description content="Mini guide to 'when is my return a move?'"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bobblelaw.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Moves in Returns","item":"https://bobblelaw.github.io/posts/moves-in-return/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://bobblelaw.github.io/posts/moves-in-return/"},"headline":"Moves in Returns | Bobble Law","datePublished":"2020-12-19T14:39:20+08:00","dateModified":"2022-11-20T22:52:56+08:00","wordCount":1736,"author":{"@type":"Person","name":["host"]},"publisher":{"@type":"Person","name":"Bob Law","logo":{"@type":"ImageObject","url":"https://bobblelaw.github.io/images/icon.png"}},"description":"Mini guide to \u0027when is my return a move?\u0027"}</script><meta property="og:title" content="Moves in Returns | Bobble Law"><meta property="og:type" content="article"><meta property="og:image" content="https://bobblelaw.github.io/images/icon.png"><meta property="og:url" content="https://bobblelaw.github.io/posts/moves-in-return/"><meta property="og:description" content="Mini guide to 'when is my return a move?'"><meta property="og:locale" content="en"><meta property="og:site_name" content="Bobble Law"><meta property="article:published_time" content="2020-12-19T14:39:20+08:00"><meta property="article:modified_time" content="2022-11-20T22:52:56+08:00"><meta property="article:section" content="posts"><meta property="article:tag" content="C++"><meta property="og:see_also" content="https://bobblelaw.github.io/posts/unordered-map-usage-and-performance/"><meta property="og:see_also" content="https://bobblelaw.github.io/posts/sort-multiple-range/"><meta property="og:see_also" content="https://bobblelaw.github.io/posts/range-ref/"><meta property="og:see_also" content="https://bobblelaw.github.io/posts/recursive-lambda-function/"><meta property="og:see_also" content="https://bobblelaw.github.io/posts/floating-point-optimizations/"><body class="flex min-h-screen flex-col"><header class="min-h-16 pl-scrollbar bg-secondary-bg fixed z-50 flex w-full items-center shadow-sm"><div class="mx-auto w-full max-w-screen-xl"><script>let storageColorScheme=localStorage.getItem("lightDarkMode");(storageColorScheme=="Auto"&&window.matchMedia("(prefers-color-scheme: light)").matches||storageColorScheme=="Light")&&document.getElementsByTagName("html")[0].classList.remove("dark")</script><nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0"><a href=/ class="me-6 text-primary-text text-xl font-bold">Bobble Law</a>
<button id=navbar-btn class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
<i class="fas fa-bars"></i></button><div id=target class="hidden block md:flex md:grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20"><div class="md:flex md:h-16 text-sm md:grow pb-4 md:pb-0 border-b md:border-b-0"><a href=/#about class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">About</a>
<a href=/posts/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 selected-menu-item me-4">Posts</a>
<a href=/docs/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">Topics</a></div><div class=flex><div class="relative pt-4 md:pt-0"><div class="cursor-pointer hover:text-eureka" id=lightDarkMode><i class="fas fa-moon"></i></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id=is-open></div><div class="absolute flex flex-col start-0 md:start-auto end-auto md:end-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40" id=lightDarkOptions><span class="px-4 py-1 hover:text-eureka" name=Light>Light</span>
<span class="px-4 py-1 hover:text-eureka" name=Dark>Dark</span>
<span class="px-4 py-1 hover:text-eureka" name=Auto>Auto</span></div></div></div></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id=is-open-mobile></div></nav><script>let element=document.getElementById("lightDarkMode");storageColorScheme=="Auto"?(element.firstElementChild.classList.remove("fa-moon"),element.firstElementChild.setAttribute("data-icon","adjust"),element.firstElementChild.classList.add("fa-adjust"),document.addEventListener("DOMContentLoaded",()=>{window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",switchDarkMode)})):storageColorScheme=="Light"&&(element.firstElementChild.classList.remove("fa-moon"),element.firstElementChild.setAttribute("data-icon","sun"),element.firstElementChild.classList.add("fa-sun")),document.addEventListener("DOMContentLoaded",()=>{getcolorscheme(),switchBurger()})</script></div></header><main class="grow pt-16"><div class=pl-scrollbar><div class="mx-auto w-full max-w-screen-xl lg:px-4 xl:px-8"><div class="grid grid-cols-2 gap-4 lg:grid-cols-8 lg:pt-12"><div class="lg:col-start-2 bg-secondary-bg col-span-2 rounded px-6 py-8 lg:col-span-6"><article class=prose><h1 class=mb-4>Moves in Returns</h1><div class="text-tertiary-text not-prose mt-2 flex flex-row flex-wrap items-center"><div class="me-6 my-2"><i class="fas fa-calendar me-1"></i>
<span>2020-12-19</span></div><div class="me-6 my-2"><i class="fas fa-clock me-1"></i>
<span>9 min read</span></div></div><p>Today we&rsquo;ll discuss code of the form:</p><pre><code class=language-cpp>T work(/* ... */)
{
    /* ... */
    return x;
}
</code></pre><p>This is a classical &ldquo;return-by-value&rdquo; and (wrongfully) associated with copies and overhead.</p><p>In many cases, this will actually <code>move</code> the result instead of copying it.
For modern C++, one could even argue that this will move in <em>most</em> cases (or, as we will see, completely <em>elide</em> the copy and directly construct in the result memory).</p><p>This post discusses several common patterns and if they are moved, copies, or elided.</p><blockquote><p>Side note: <em>technically</em> a move is a type of copy.
For example, <code>T x = &lt;expr></code> performs a <a href=https://en.cppreference.com/w/cpp/language/copy_initialization>copy initialization</a>, which might select the move constructor during overload resolution.
The rest of this post will use the colloquial &ldquo;move&rdquo; for &ldquo;calls move ctor or assignment&rdquo; and &ldquo;copy&rdquo; for &ldquo;calls copy ctor or assignment&rdquo;.</p></blockquote><h1 id=tracking-construction-and-assignment>Tracking Construction and Assignment</h1><p>Reading the C++ standard (or cppreference) to reason about your code is valuable, but given the flood of information, it can be difficult to draw the correct inferences.
Thus, in addition to this <em>theoretical</em> understanding, I love to validate my findings on <a href=https://godbolt.org/>godbolt</a>.</p><p>The following examples always use a type <code>T</code>, defined as:</p><pre><code class=language-cpp>struct T
{
    T();                    // ctor
    ~T();                   // dtor
    T(T&amp;&amp;);                 // move ctor
    T(T const&amp;);            // copy ctor
    T&amp; operator=(T&amp;&amp;);      // move assignment
    T&amp; operator=(T const&amp;); // copy assignment
};
</code></pre><p>These functions are not implemented on purpose, so we will see the corresponding calls in the assembly.
Furthermore, I&rsquo;ll mark the <code>work</code> functions as <code>__attribute__((noinline))</code> so that we can see which special function calls belong where (caller or callee).</p><h1 id=constructing-objects-in-return>Constructing Objects in Return</h1><pre><code class=language-cpp>T work()
{
    return T();
}

void use()
{
    auto obj = work();
}
</code></pre><p>Since C++17, this invokes <strong>mandatory</strong> <a href=https://en.cppreference.com/w/cpp/language/copy_elision>copy elision</a>.
No copy or move constructor is called, even if they have side effects.</p><p><a href=https://godbolt.org/z/sYx6h8Mq7>Assembly</a>:</p><pre><code class=language-cpp>work():
  ...
  call T::T() [complete object constructor]
  ...
  ret
use():
  ...
  call work()
  ...
  call T::~T() [complete object destructor]
  ...
  ret
</code></pre><p><code>T</code> is constructed in <code>work</code> in a memory location that is provided by the caller <code>use</code>.
At the end of <code>use</code>, <code>T</code> is destructed.
No temporary copies are created, nothing is moved.</p><p>This &ldquo;chains&rdquo; in the sense that it also applies to <code>return other_work();</code> where <code>other_work</code> also returns a <code>T</code> by value.</p><p>With <code>return T();</code>, <code>work</code> will always call exactly one constructor and nothing else from <code>T</code>.
However, <code>use</code> is only this simple because we initialize <code>obj</code> with the result of <code>work()</code>.
If we assign it to an existing object, we get a temporary:</p><pre><code class=language-cpp>T work()
{
    return T();
}

void use(T&amp; obj)
{
    obj = work();
}
</code></pre><p><a href=https://godbolt.org/z/Whcro3vno>Assembly</a>:</p><pre><code class=language-cpp>work():
  ...
  call T::T() [complete object constructor]
  ...
  ret
use(T&amp;):
  ...
  call work()
  ...
  call T::operator=(T&amp;&amp;)
  ...
  call T::~T() [complete object destructor]
  ...
  ret
</code></pre><p><code>work</code> constructs a <code>T</code> for which <code>use</code> provides the stack space.
This temporary <code>T</code> is then <em>moved</em> into <code>obj</code> using <code>T::operator=(T&&)</code>.
Finally, the temporary <code>T</code> is destroyed.</p><p>Before C++17, this type of optimization was allowed, but optional.
In particular, if your object is neither copyable nor movable, you could run into compile errors depending on if this optimization was applied or not (e.g. debug vs. release).</p><blockquote><p>Note: In C++17, this direct creation of the result in space provided by the caller has the fancy name &ldquo;unmaterialized value passing&rdquo;.</p></blockquote><h1 id=returning-a-local-variable>Returning a Local Variable</h1><pre><code class=language-cpp>T work()
{
    T obj;
    // ...
    return obj;
}

void use()
{
    auto obj = work();
}
</code></pre><p>Interestingly enough, this results in the same <a href=https://godbolt.org/z/nq6zTPKEo>assembly</a> as our previous case:</p><pre><code class=language-cpp>work():
  ...
  call T::T() [complete object constructor]
  ...
  ret
use():
  ...
  call work()
  ...
  call T::~T() [complete object destructor]
  ...
  ret
</code></pre><p>No temporary object is created, nothing is moved or copied.
However, this form of <a href=https://en.cppreference.com/w/cpp/language/copy_elision>copy elision</a> is not mandatory.
This is also known as &ldquo;named return value optimization&rdquo; or NRVO.
Note that in this case, in contrast to the previous case, <code>T</code> must be copyable or movable, even if the actual copy or move constructor is not called in the end.</p><p>It gets more interesting if we have other ways out of the function:</p><pre><code class=language-cpp>T work()
{
    if (some_condition())
        return T();

    T obj;
    return obj;
}
</code></pre><p><a href=https://godbolt.org/z/o7Ws33fj1>Assembly</a>:</p><pre><code class=language-cpp>work():
  ...
  call some_condition()
  if:
    call T::T() [complete object constructor]
    ...
    ret
  else:
    ...
    call T::T() [complete object constructor]
    ...
    call T::T(T&amp;&amp;) [complete object constructor]
    ...
    call T::~T() [complete object destructor]
    ...
    ret
</code></pre><p>If the condition is <code>true</code>, we construct the result directly as before.
However, the second case now creates a temporary <code>T</code>.
This temporary is then move-constructed into the return value.
Afterwards, the temporary is destructed.</p><p>No copy elision was performed for <code>obj</code> (though I am not 100% sure why. It should be allowed and possible here.)
Still, the result is a <em>move</em>, not a <em>copy</em>.
This is a feature of the <a href=https://en.cppreference.com/w/cpp/language/return>return statement</a>:
Since C++11, <code>return x</code> (or <code>return (x)</code> or <code>return ((x))</code> for that matter) will try to use the move constructor if <code>x</code> is a local variable or a function parameter.</p><blockquote><p>Note: the actual rule has a few nuances, but this is a good first-order approximation.</p></blockquote><h1 id=moving-from-a-local-variable>Moving from a Local Variable</h1><p>You might have seen the following:</p><pre><code class=language-cpp>T work()
{
    T obj;
    return std::move(obj);
}
</code></pre><p>Many compilers, IDEs, and linters warn about this.
GCC might say &ldquo;moving a local object in a return statement prevents copy elision&rdquo;.
And indeed, the <a href=https://godbolt.org/z/q6cbzWzrx>assembly</a> is now:</p><pre><code class=language-cpp>work():
  ...
  call T::T() [complete object constructor]
  ...
  call T::T(T&amp;&amp;) [complete object constructor]
  ...
  call T::~T() [complete object destructor]
  ...
  ret
</code></pre><p>A temporary that is move-constructed into the return value.
Without the <code>std::move</code>, we had no move construction at all.</p><h1 id=returning-a-function-parameter>Returning a Function Parameter</h1><p>Local variables and function parameters have slightly different behavior.</p><pre><code class=language-cpp>T work(T obj)
{
    return obj;
}

void use()
{
    auto obj = work(T());
}
</code></pre><p>When <code>obj</code> was a local variable, we had the freedom to change <em>where</em> it is allocated.
If all paths through the function end in <code>return obj</code>, the compiler could use the caller-provided space for the return value, thus <em>eliding</em> any move into the result.</p><p>However, function parameters are already allocated by the caller and distinct from the return value.
Luckily, the rules for <code>return</code> statements still apply and we get a move in the <a href=https://godbolt.org/z/xj3Wqo8Wb>assembly</a>:</p><pre><code class=language-cpp>work(T):
  ...
  call T::T(T&amp;&amp;) [complete object constructor]
  ...
  ret
use():
  ...
  call T::T() [complete object constructor]
  ...
  call work(T)
  ...
  call T::~T() [complete object destructor]
  ...
  call T::~T() [complete object destructor]
  ...
  ret
</code></pre><p>Even passed-by-value, no <code>T</code> is copied in this whole example.
The caller (<code>use</code>) creates a <code>T</code> where <code>work</code> will expect it.
<code>work</code> itself only move-constructs <code>T</code> in the return value.
<code>use</code> then destructs the argument <code>T</code> (&ldquo;at the end of the statement&rdquo;), followed by destruction of the result of <code>work</code> (&ldquo;at the end of the scope&rdquo;).</p><h1 id=non-matching-types>Non-Matching Types</h1><p>Copy elision only works if the result type matches what we want to return.
This might not always be the case.
Something I find myself writing with decent frequency:</p><pre><code class=language-cpp>std::optional&lt;T&gt; work()
{
    if (some_condition())
        return std::nullopt;

    return T();
}
</code></pre><p>And the obvious question is if the second <code>return</code> <em>copies</em> or <em>moves</em> the <code>T</code> into the <code>optional&lt;T></code>.</p><p>More general, let&rsquo;s say we have a second type <code>U</code> and <code>T</code> has implicit conversions:</p><pre><code class=language-cpp>struct T
{
    ...
    T(U&amp;&amp;) noexcept;      // &quot;move-convert&quot;
    T(U const&amp;) noexcept; // &quot;copy-convert&quot;
};
</code></pre><p>Now we can ask the question what the following code will call:</p><pre><code class=language-cpp>T work()
{
    return U();
}
</code></pre><p>or</p><pre><code class=language-cpp>T work()
{
    U obj;
    return obj;
}
</code></pre><p>Both result in the <a href=https://godbolt.org/z/cW5f1K65b>same</a> <a href=https://godbolt.org/z/5jsbcWeKz>assembly</a>:</p><pre><code class=language-cpp>work():
  ...
  call U::U() [complete object constructor]
  ...
  call T::T(U&amp;&amp;) [complete object constructor]
  ...
  call U::~U() [complete object destructor]
  ...
  ret
</code></pre><p>A temporary <code>U</code> is created, move-&ldquo;converted&rdquo; into the result <code>T</code>, and then destructed.
No copy involved.</p><blockquote><p>Fun fact: in &ldquo;vanilla&rdquo; C++11, this created a copy.
The behavior was fixed in C++14 and back-ported via <a href=https://wg21.cmeerw.net/cwg/issue1579>defect report</a>.
Thus, most compiler with C++14 support will emit the move, even if you explicitly compile for C++11.
However, pre-C++14 compiler might emit the copy.</p></blockquote><h1 id=where-copy>Where Copy??</h1><p>It delights me to see so many cases where the default (without any <code>std::move</code> involved) will result in either move construction or even complete elision of copy or move.</p><p>So, when will return-by-value actually copy?
A small collection of patterns to look out for:</p><pre><code class=language-cpp>T work()
{
    struct { T t; } v;
    return v.t; // COPY! returning a member
}

T work()
{
    static T globalT;
    return globalT; // COPY! not a local var
}

T work(T&amp; obj)
{
    return obj; // COPY! T&amp; matches T const&amp;, not T&amp;&amp; 
}

T work(T const&amp; obj)
{
    return obj; // COPY!
}

T work(T&amp;&amp; obj)
{
    return obj; // COPY! &quot;inside&quot; work, obj is an lvalue
                // NOTE: careful with lifetimes here
                // NOTE: is a move in C++20
}

T work(T const obj)
{
    return obj; // COPY! T const cannot be moved
                // NOTE: const is ignored for the signature,
                //       which is work(T) and not work(T const)
                //       but has &quot;effect&quot; inside the function
}
</code></pre><p>Maybe unexpectedly, the following <a href=https://godbolt.org/z/heveTn3EW>is elided</a>:</p><pre><code class=language-cpp>T work()
{
    T const obj;
    return obj; // no copy or move involved
}
</code></pre><p>Because while we cannot move <code>T const</code>, we can still allocate it directly &ldquo;in&rdquo; the return value.
Still, this is a bit brittle, as a slightly more complex function will create a copy:</p><pre><code class=language-cpp>T work()
{
    if (some_condition())
        return T();

    T const obj;
    return obj; // now it's a copy
}

T work()
{
    T const obj;
    return std::move(obj); // also a copy
                           // T const&amp;&amp; matches T const&amp;, not T&amp;&amp;
}
</code></pre><h1 id=conclusion>Conclusion</h1><p>We saw many examples where modern C++ now naturally creates moves instead of copies or even elides them altogether and directly constructs the return value &ldquo;in the proper location&rdquo;.
As the last section showed, you still have to look out for references or non-local variables.
This is probably a good thing, because those tend to have multiple aliases, which might take offense if their data suddenly moved away.</p><p>Most of the explanations in this post are somewhat simplified to make them palatable.
In particular, exceptions and <code>volatile</code> variables can complicate the situation a lot.
Also, keep in mind that inside a lambda, captures are not considered local variables.</p><p>The assembly shown in the examples can be considered a kind of worst case scenario, as the compiler has no access to the special member functions of <code>T</code>.
When these functions are visible, they can often be inlined and further optimized.</p><p>(<em>Title image from <a href=https://unsplash.com/photos/3vlGNkDep4E>unsplash</a></em>)</p></article><div class=my-4><a href=https://bobblelaw.github.io/tags/c++/ class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#C++</a></div><div class=py-2><div class="my-8 flex flex-col items-center md:flex-row"><a href=https://bobblelaw.github.io/authors/host/ class="md:me-4 text-primary-text h-24 w-24"><img src=https://bobblelaw.github.io/images/cartoon_me.png class="bg-primary-bg w-full rounded-full" alt=Avatar></a><div class="mt-4 w-full md:mt-0 md:w-auto"><a href=https://bobblelaw.github.io/authors/host/ class="mb-2 block border-b pb-1 text-lg font-bold"><h3>Lo, Tszwan</h3></a><span class="block pb-2"></span>
<a href=mailto:bobble2579@hotmail.com class=me-2><i class="fas fa-envelope"></i></a>
<a href=https://github.com/BobbleLaw class=me-2><i class="fab fa-github"></i></a></div></div></div><div class="-mx-2 mt-4 flex flex-col border-t px-2 pt-4 md:flex-row md:justify-between"><div><span class="text-primary-text block font-bold">Previous</span>
<a href=https://bobblelaw.github.io/posts/understanding-automatic-differentiation/ class=block>Understanding Automatic Differentiation</a></div><div class="mt-4 md:mt-0 md:text-right"><span class="text-primary-text block font-bold">Next</span>
<a href=https://bobblelaw.github.io/posts/unordered-map-usage-and-performance/ class=block>std::unordered_map Performance and Usage</a></div></div></div><div class="lg:col-start-2 bg-secondary-bg prose col-span-2 rounded p-6 lg:col-span-6"><h3>See Also</h3><a href=https://bobblelaw.github.io/posts/unordered-map-usage-and-performance/ class=no-underline>std::unordered_map Performance and Usage</a><br><a href=https://bobblelaw.github.io/posts/sort-multiple-range/ class=no-underline>std::sort Multiple Ranges</a><br><a href=https://bobblelaw.github.io/posts/range-ref/ class=no-underline>range_ref&lt;T></a><br><a href=https://bobblelaw.github.io/posts/recursive-lambda-function/ class=no-underline>Recursive Lambdas in C++</a><br><a href=https://bobblelaw.github.io/posts/floating-point-optimizations/ class=no-underline>Basic Floating Point Optimizations</a><br></div></div><script>document.addEventListener("DOMContentLoaded",()=>{hljs.highlightAll()})</script></div></div></main><footer class=pl-scrollbar><div class="mx-auto w-full max-w-screen-xl"><div class="text-center p-6 pin-b"><p class="text-sm text-tertiary-text">&copy; 2022 <a href=#>Bobble Law</a> and <a href=#>Stay Inc.</a>
&#183; Powered by the <a href=https://github.com/wangchucheng/hugo-eureka class=hover:text-eureka>Eureka</a> theme for <a href=https://gohugo.io class=hover:text-eureka>Hugo</a></p></div></div></footer></body></html>