<!doctype html><html lang=en dir=ltr class=dark><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Optimization without Inlining | Bobble Law</title><meta name=generator content="Hugo Eureka 0.9.3"><link rel=stylesheet href=https://bobblelaw.github.io/css/eureka.min.9cec6350e37e534b0338fa9a085bf06855de3b0f2dcf857e792e5e97b07ea905d4d5513db554cbc26a9c3da622bae92d.css><script defer src=https://bobblelaw.github.io/js/eureka.min.fa9a6bf6d7a50bb635b4cca7d2ba5cf3dfb095ae3798773f1328f7950028b48c17d06276594e1b5f244a25a6c969a705.js></script>
<link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap" as=style onload='this.onload=null,this.rel="stylesheet"'><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/styles/base16/solarized-light.min.css media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/highlight.min.js crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/cpp,%20swift,%20python.min.js crossorigin></script>
<link rel=stylesheet href=https://bobblelaw.github.io/css/highlightjs.min.2958991528e43eb6fc9b8c4f2b8e052f79c4010718e1d1e888a777620e9ee63021c2c57ec7417a3108019bb8c41943e6.css media=print onload='this.media="all",this.onload=null'><script defer type=text/javascript src=https://bobblelaw.github.io/js/fontawesome.min.a975d08212c5439f29e6074e7ad58e159ae1ef5efb6a31962fa3b6885557e794dd9315f4a8a16d705066d023f4eaaf07.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><script defer src=https://cdn.jsdelivr.net/npm/mermaid@8.14.0/dist/mermaid.min.js integrity=sha384-atOyb0FxAgN9LyAc6PEf9BjgwLISyansgdH8/VXQH8p2o5vfrRgmGIJ2Sg22L0A0 crossorigin></script>
<link rel=icon type=image/png sizes=32x32 href=https://bobblelaw.github.io/images/icon_hucb7ee3c6385b6f166198d69440e1110c_52330_32x32_fill_box_center_3.png><link rel=apple-touch-icon sizes=180x180 href=https://bobblelaw.github.io/images/icon_hucb7ee3c6385b6f166198d69440e1110c_52330_180x180_fill_box_center_3.png><meta name=description content="Even without inlining, the compiler does not always has to assume the worst case."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bobblelaw.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Optimization without Inlining","item":"https://bobblelaw.github.io/posts/inline-optimization/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://bobblelaw.github.io/posts/inline-optimization/"},"headline":"Optimization without Inlining | Bobble Law","datePublished":"2021-10-17T02:00:00+00:00","dateModified":"2020-11-20T22:52:56+08:00","wordCount":1062,"author":{"@type":"Person","name":["host"]},"publisher":{"@type":"Person","name":"Bob Law","logo":{"@type":"ImageObject","url":"https://bobblelaw.github.io/images/icon.png"}},"description":"Even without inlining, the compiler does not always has to assume the worst case."}</script><meta property="og:title" content="Optimization without Inlining | Bobble Law"><meta property="og:type" content="article"><meta property="og:image" content="https://bobblelaw.github.io/images/icon.png"><meta property="og:url" content="https://bobblelaw.github.io/posts/inline-optimization/"><meta property="og:description" content="Even without inlining, the compiler does not always has to assume the worst case."><meta property="og:locale" content="en"><meta property="og:site_name" content="Bobble Law"><meta property="article:published_time" content="2021-10-17T02:00:00+00:00"><meta property="article:modified_time" content="2020-11-20T22:52:56+08:00"><meta property="article:section" content="posts"><meta property="article:tag" content="C++"><meta property="og:see_also" content="https://bobblelaw.github.io/posts/unordered-map-usage-and-performance/"><meta property="og:see_also" content="https://bobblelaw.github.io/posts/sort-multiple-range/"><meta property="og:see_also" content="https://bobblelaw.github.io/posts/multi-level-break/"><meta property="og:see_also" content="https://bobblelaw.github.io/posts/range-ref/"><meta property="og:see_also" content="https://bobblelaw.github.io/posts/recursive-lambda-function/"><meta property="og:see_also" content="https://bobblelaw.github.io/posts/delete-rvalue-ref-assignment/"><body class="flex min-h-screen flex-col"><header class="min-h-16 pl-scrollbar bg-secondary-bg fixed z-50 flex w-full items-center shadow-sm"><div class="mx-auto w-full max-w-screen-xl"><script>let storageColorScheme=localStorage.getItem("lightDarkMode");(storageColorScheme=="Auto"&&window.matchMedia("(prefers-color-scheme: light)").matches||storageColorScheme=="Light")&&document.getElementsByTagName("html")[0].classList.remove("dark")</script><nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0"><a href=/ class="me-6 text-primary-text text-xl font-bold">Bobble Law</a>
<button id=navbar-btn class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
<i class="fas fa-bars"></i></button><div id=target class="hidden block md:flex md:grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20"><div class="md:flex md:h-16 text-sm md:grow pb-4 md:pb-0 border-b md:border-b-0"><a href=/#about class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">About</a>
<a href=/posts/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 selected-menu-item me-4">Posts</a>
<a href=/docs/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">Topics</a></div><div class=flex><div class="relative pt-4 md:pt-0"><div class="cursor-pointer hover:text-eureka" id=lightDarkMode><i class="fas fa-moon"></i></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id=is-open></div><div class="absolute flex flex-col start-0 md:start-auto end-auto md:end-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40" id=lightDarkOptions><span class="px-4 py-1 hover:text-eureka" name=Light>Light</span>
<span class="px-4 py-1 hover:text-eureka" name=Dark>Dark</span>
<span class="px-4 py-1 hover:text-eureka" name=Auto>Auto</span></div></div></div></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id=is-open-mobile></div></nav><script>let element=document.getElementById("lightDarkMode");storageColorScheme=="Auto"?(element.firstElementChild.classList.remove("fa-moon"),element.firstElementChild.setAttribute("data-icon","adjust"),element.firstElementChild.classList.add("fa-adjust"),document.addEventListener("DOMContentLoaded",()=>{window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",switchDarkMode)})):storageColorScheme=="Light"&&(element.firstElementChild.classList.remove("fa-moon"),element.firstElementChild.setAttribute("data-icon","sun"),element.firstElementChild.classList.add("fa-sun")),document.addEventListener("DOMContentLoaded",()=>{getcolorscheme(),switchBurger()})</script></div></header><main class="grow pt-16"><div class=pl-scrollbar><div class="mx-auto w-full max-w-screen-xl lg:px-4 xl:px-8"><div class="grid grid-cols-2 gap-4 lg:grid-cols-8 lg:pt-12"><div class="lg:col-start-2 bg-secondary-bg col-span-2 rounded px-6 py-8 lg:col-span-6"><article class=prose><h1 class=mb-4>Optimization without Inlining</h1><div class="text-tertiary-text not-prose mt-2 flex flex-row flex-wrap items-center"><div class="me-6 my-2"><i class="fas fa-calendar me-1"></i>
<span>2021-10-17</span></div><div class="me-6 my-2"><i class="fas fa-clock me-1"></i>
<span>5 min read</span></div></div><p><a href=https://en.wikipedia.org/wiki/Inline_expansion>Inlining</a> is one of the most important compiler optimizations.
We can often write abstractions and thin wrapper functions without incurring any performance penalty, because the compiler will expand the method for us at call site.</p><p>If a function is not inlined, conventional wisdom says that the compiler has to assume that the method can modify any global state and change the memory behind any pointer or reference that might have &ldquo;escaped&rdquo;.</p><p>In this short post, I&rsquo;ll demonstrate exactly this effect.
Furthermore, we will see that even if a function is not inlined, as long as the implementation is visible, some optimizations are still performed and sometimes to great effect.</p><h1 id=example>Example</h1><p>Let us consider this simple <code>test</code> function,</p><pre><code class=language-cpp>// implemented in different TU or otherwise linked in
int foo(int n);

int test(int const&amp; n) 
{
    auto sum = 0;
    sum += foo(n);
    sum += foo(n);
    return sum;
}
</code></pre><p>which results in the following <a href=https://godbolt.org/z/oE5ozq1b4>assembly</a>:</p><pre><code class=language-cpp>test(int const&amp;):
  push rbp
  push rbx
  push rax
  mov rbx, rdi
  mov edi, dword ptr [rdi] // load n from memory
  call foo(int)            // call foo
  mov ebp, eax
  mov edi, dword ptr [rbx] // load n from memory _again_
  call foo(int)            // call foo
  add eax, ebp
  add rsp, 8
  pop rbx
  pop rbp
  ret
</code></pre><p>Unsurprising, <code>foo</code> is called twice.
For all we know, it has important side effects that have to be executed twice.
Maybe a bit more subtle: <code>n</code> had to be reloaded from memory, because the first call to <code>foo</code> might have changed the memory.
(For example, <code>n</code> might be a reference to a global <code>int</code> that <code>foo</code> happens to increment.)</p><p>This is really the worst case for the compiler.
Nothing about the inner workings of <code>foo</code> is known.</p><p>On the other end of the spectrum, we have a small, known <code>foo</code>:</p><pre><code class=language-cpp>int foo(int n)
{
    return n * n;
}

int test(int const&amp; n) 
{
    auto sum = 0;
    sum += foo(n);
    sum += foo(n);
    return sum;
}
</code></pre><p>which results in the following <a href=https://godbolt.org/z/6T6qsd79x>assembly</a>:</p><pre><code class=language-cpp>test(int const&amp;):
  mov eax, dword ptr [rdi] // load n from memory
  imul eax, eax            // tmp = n*n
  add eax, eax             // return tmp + tmp
  ret
</code></pre><p>Not only is the call to <code>foo</code> inlined, further optimizations made sure that <code>n * n</code> is not computed twice.</p><h1 id=to-inline-or-not-to-inline>To Inline or not to Inline</h1><p>If <code>foo</code> is part of a different TU, the compiler can obviously not inline the call.
Should you have enough patience, <a href=https://en.wikipedia.org/wiki/Interprocedural_optimization>link-time optimization</a> might come to the rescue.
(It&rsquo;s usually really expensive, so I can only really recommend it for CI building release versions.)</p><p>However, there are many other reasons why <code>foo</code> is not inlined.
In general, inlining is a double-edged sword.
Each inlined function increases the pressure on the <a href=https://en.wikipedia.org/wiki/CPU_cache>instruction cache</a> and makes the parent function harder to analyze.
More local variables mean more <a href=https://en.wikipedia.org/wiki/Register_allocation>register spills</a>.
All these can negatively affect performance and compilers have various heuristic to try to make good decisions.</p><p>Most small functions will get inlined by default.
As the complexity of the function body rises, this will stop at some point.
Recursion <em>usually</em> prevents inlining, though <a href=https://godbolt.org/z/Ehdqcq37c>compilers are definitely able to inline recursive functions</a> via <a href=https://en.wikipedia.org/wiki/Tail_call>tail-call elimination</a>.</p><p>We can artificially prevent inlining by declaring the function <code>__declspec(noinline)</code> (for msvc) or <code>__attribute__((noinline))</code> (for gcc/clang):</p><pre><code class=language-cpp>__attribute__((noinline)) int foo(int n)
{
    return n * n;
}

int test(int const&amp; n) 
{
    auto sum = 0;
    sum += foo(n);
    sum += foo(n);
    return sum;
}
</code></pre><p>which results in the following <a href=https://godbolt.org/z/v5bPd99bo>assembly</a>:</p><pre><code class=language-cpp>test(int const&amp;):
  mov edi, dword ptr [rdi] // load n from memory
  call foo(int)            // tmp = foo(n)
  add eax, eax             // return tmp + tmp
  ret
</code></pre><p>So, obviously <code>foo</code> was not inlined.
However, the compiler could still see and analyze it.
It came to the conclusion that <code>foo</code> does not read or modify global state.
<code>foo</code> was flagged as a <a href=https://en.wikipedia.org/wiki/Pure_function>pure function</a>.</p><p>Pure functions are nice.
Pure functions return the same result if given the same input.
Pure functions do not modify global state, they work solely on their input values.
Thus, <code>foo(n) + foo(n)</code> was simplified to <code>tmp = foo(n); tmp + tmp</code>, even without inlining.</p><h1 id=fun-with-loops>Fun with Loops</h1><p>The difference becomes even larger with loops:</p><pre><code class=language-cpp>// different TU
int foo(int n);

int test(int const&amp; n) 
{
    auto sum = 0;
    for (auto i = 0; i &lt;= n; ++i)
        sum += foo(n);
    return sum;
}
</code></pre><p>which results in the following <a href=https://godbolt.org/z/4ErEvzecE>assembly</a>:</p><pre><code class=language-cpp>test(int const&amp;):
  push rbp
  push r14
  push rbx
  mov r14, rdi
  mov edi, dword ptr [rdi]
  xor ebp, ebp
  test edi, edi // n &lt; 0 case
  js .LBB0_3
  mov ebx, -1
.LBB0_2:         // loop body begin
  call foo(int)            // call foo
  add ebp, eax
  mov edi, dword ptr [r14] // reload n from memory
  inc ebx
  cmp ebx, edi
  jl .LBB0_2     // loop body end
.LBB0_3:
  mov eax, ebp
  pop rbx
  pop r14
  pop rbp
  ret
</code></pre><p>With no information, the compiler has to call <code>foo</code> (and load <code>n</code> from memory) in each iteration.
Contrast this with:</p><pre><code class=language-cpp>__attribute__((noinline)) int foo(int n)
{
    return n * n;
}

int test(int const&amp; n) 
{
    auto sum = 0;
    for (auto i = 0; i &lt;= n; ++i)
        sum += foo(n);
    return sum;
}
</code></pre><p>which results in the following <a href=https://godbolt.org/z/96Mxvsv9b>assembly</a>:</p><pre><code class=language-cpp>test(int const&amp;):
  mov edx, dword ptr [rdi]
  test edx, edx
  js .L5 // special case n &lt; 0
  mov edi, edx
  call foo(int)  // tmp1 = foo(n)
  imul edx, eax  // tmp2 = tmp1 * n
  add eax, edx   // return tmp2 + n
  ret
.L5:
  xor eax, eax // return 0
  ret
</code></pre><p>So gcc is able to optimize the whole thing to basically <code>foo(n) * (n + 1)</code>, without inlining.
Funnily enough, clang tries (and fails) to be clever with lots of SIMD.</p><h1 id=conclusion>Conclusion</h1><p>This is not a long post, but it shows that while inlining is a very important optimization, a non-inlined function is not the end of <del>the world</del> optimization.
As long as the function implementation is visible, compilers can and will analyze them so that they don&rsquo;t have to assume the worst case.
This, in turn, re-enables many optimizations such as <a href=https://en.wikipedia.org/wiki/Value_numbering>value numbering</a>, <a href=https://en.wikipedia.org/wiki/Common_subexpression_elimination>common subexpression elimination</a>, and <a href=https://en.wikipedia.org/wiki/Loop-invariant_code_motion>loop-invariant code motion</a>.</p><p>PS: gcc and clang have a variety of <a href=https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html>function attributes</a> that can be used to enable optimizations, even if the implementation is in a different TU.
The two most important ones are <code>__attribute__((const))</code> and <code>__attribute__((pure))</code>.</p><p>(<em>Title image from <a href=https://unsplash.com/photos/Y-VYK0SDLxs>unsplash</a></em>)</p></article><div class=my-4><a href=https://bobblelaw.github.io/tags/c++/ class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#C++</a></div><div class=py-2><div class="my-8 flex flex-col items-center md:flex-row"><a href=https://bobblelaw.github.io/authors/host/ class="md:me-4 text-primary-text h-24 w-24"><i class="fas fa-user-circle fa-6x"></i></a><div class="mt-4 w-full md:mt-0 md:w-auto"><a href=https://bobblelaw.github.io/authors/host/ class="mb-2 block border-b pb-1 text-lg font-bold"><h3>Bobble Law</h3></a><span class="block pb-2">Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos.</span>
<a href=mailto:bobble2579@hotmail.com class=me-2><i class="fas fa-envelope"></i></a>
<a href=https://github.com/bobblelaw class=me-2><i class="fab fa-github"></i></a></div></div></div><div class="-mx-2 mt-4 flex flex-col border-t px-2 pt-4 md:flex-row md:justify-between"><div><span class="text-primary-text block font-bold">Previous</span>
<a href=https://bobblelaw.github.io/posts/moves-in-return/ class=block>Moves in Returns</a></div><div class="mt-4 md:mt-0 md:text-right"><span class="text-primary-text block font-bold">Next</span>
<a href=https://bobblelaw.github.io/posts/unordered-map-usage-and-performance/ class=block>std::unordered_map Performance and Usage</a></div></div></div><div class="lg:col-start-2 bg-secondary-bg prose col-span-2 rounded p-6 lg:col-span-6"><h3>See Also</h3><a href=https://bobblelaw.github.io/posts/unordered-map-usage-and-performance/ class=no-underline>std::unordered_map Performance and Usage</a><br><a href=https://bobblelaw.github.io/posts/sort-multiple-range/ class=no-underline>std::sort multiple ranges</a><br><a href=https://bobblelaw.github.io/posts/multi-level-break/ class=no-underline>Multi-Level Break in C++ via IIFE</a><br><a href=https://bobblelaw.github.io/posts/range-ref/ class=no-underline>range_ref&lt;T></a><br><a href=https://bobblelaw.github.io/posts/recursive-lambda-function/ class=no-underline>Recursive Lambdas in C++</a><br><a href=https://bobblelaw.github.io/posts/delete-rvalue-ref-assignment/ class=no-underline>Consider deleting your rvalue ref-qualified assignment operators</a><br></div></div><script>document.addEventListener("DOMContentLoaded",()=>{hljs.highlightAll()})</script></div></div></main><footer class=pl-scrollbar><div class="mx-auto w-full max-w-screen-xl"><div class="text-center p-6 pin-b"><p class="text-sm text-tertiary-text">&copy; 2022 <a href=#>Bobble Law</a> and <a href=#>Stay Inc.</a>
&#183; Powered by the <a href=https://github.com/wangchucheng/hugo-eureka class=hover:text-eureka>Eureka</a> theme for <a href=https://gohugo.io class=hover:text-eureka>Hugo</a></p></div></div></footer></body></html>