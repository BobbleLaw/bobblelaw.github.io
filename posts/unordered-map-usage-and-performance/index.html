<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta http-equiv=Accept-CH content="DPR, Viewport-Width, Width"><link rel=icon href=/logo.png type=image/gif><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" media=print onload='this.media="all"'><noscript><link href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel=stylesheet></noscript><link rel=stylesheet href=/css/font.css media=all><script async src="https://www.googletagmanager.com/gtag/js?id=G-7GMTK23CS7"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7GMTK23CS7")}</script><meta property="og:url" content="https://bobblelaw.github.io/posts/unordered-map-usage-and-performance/"><meta property="og:site_name" content="Bobble Law"><meta property="og:title" content="std::unordered_map Performance and Usage"><meta property="og:description" content="How well is your hashmap?"><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-12-11T09:36:58+08:00"><meta property="article:modified_time" content="2022-11-20T22:52:56+08:00"><meta property="article:tag" content="C++"><meta name=twitter:card content="summary"><meta name=twitter:title content="std::unordered_map Performance and Usage"><meta name=twitter:description content="How well is your hashmap?"><script async src="https://www.googletagmanager.com/gtag/js?id=G-7GMTK23CS7"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7GMTK23CS7")</script><link rel=stylesheet href=/bootstrap-5/css/bootstrap.min.css media=all><link rel=stylesheet href=/css/header.css media=all><link rel=stylesheet href=/css/footer.css media=all><link rel=stylesheet href=/css/theme.css media=all><style>:root{--text-color:#343a40;--text-secondary-color:#6c757d;--text-link-color:#007bff;--background-color:#eaedf0;--secondary-background-color:#64ffda1a;--primary-color:#007bff;--secondary-color:#f8f9fa;--text-color-dark:#e4e6eb;--text-secondary-color-dark:#b0b3b8;--text-link-color-dark:#ffffff;--background-color-dark:#18191a;--secondary-background-color-dark:#212529;--primary-color-dark:#ffffff;--secondary-color-dark:#212529}body{font-size:1rem;font-weight:400;line-height:1.5;text-align:left}html{background-color:var(--background-color) !important}body::-webkit-scrollbar{height:0;width:8px;background-color:var(--background-color)}::-webkit-scrollbar-track{border-radius:1rem}::-webkit-scrollbar-thumb{border-radius:1rem;background:#b0b0b0;outline:1px solid var(--background-color)}#search-content::-webkit-scrollbar{width:.5em;height:.1em;background-color:var(--background-color)}</style><meta name=description content="How well is your hashmap?"><link rel=stylesheet href=/css/single.css><script defer src=/fontawesome-6/all-6.4.2.js></script><title>std::unordered_map Performance and Usage | Bobble Law</title></head><body class=light><script>let localStorageValue=localStorage.getItem("pref-theme"),mediaQuery=window.matchMedia("(prefers-color-scheme: dark)").matches;switch(localStorageValue){case"dark":document.body.classList.add("dark");break;case"light":document.body.classList.remove("dark");break;default:mediaQuery&&document.body.classList.add("dark");break}</script><script>var prevScrollPos=window.pageYOffset;window.addEventListener("scroll",function(){let s=document.getElementById("profileHeader"),t=window.pageYOffset,n=!1,o=!0,i=o?prevScrollPos>t:t>0;i?s.classList.add("showHeaderOnTop"):n=!0,t===0&&(n=!0),n&&s.classList.remove("showHeaderOnTop"),prevScrollPos=t})</script><header id=profileHeader><nav class="pt-3 navbar navbar-expand-lg animate"><div class="container-fluid mx-xs-2 mx-sm-5 mx-md-5 mx-lg-5"><a class="navbar-brand primary-font text-wrap" href=/><img src=/logo.png width=30 height=30 class="d-inline-block align-top">
Bob Law</a><div><input id=search autocomplete=off class="form-control mr-sm-2 d-none d-md-block" placeholder=Search... aria-label=Search oninput=searchOnChange(event)></div><button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarContent aria-controls=navbarContent aria-expanded=false aria-label="Toggle navigation">
<svg aria-hidden="true" height="24" viewBox="0 0 16 16" width="24" data-view-component="true"><path fill-rule="evenodd" d="M1 2.75A.75.75.0 011.75 2h12.5a.75.75.0 110 1.5H1.75A.75.75.0 011 2.75zm0 5A.75.75.0 011.75 7h12.5a.75.75.0 110 1.5H1.75A.75.75.0 011 7.75zM1.75 12a.75.75.0 100 1.5h12.5a.75.75.0 100-1.5H1.75z"/></svg></button><div class="collapse navbar-collapse text-wrap primary-font" id=navbarContent><ul class="navbar-nav ms-auto text-center"><li class="nav-item navbar-text d-block d-md-none"><div class=nav-link><input id=search autocomplete=off class="form-control mr-sm-2" placeholder=Search... aria-label=Search oninput=searchOnChange(event)></div></li><li class="nav-item navbar-text"><a class=nav-link href=/#about aria-label=about>About</a></li><li class="nav-item navbar-text"><a class=nav-link href=/#experience aria-label=experience>Experience</a></li><li class="nav-item navbar-text"><a class=nav-link href=/#education aria-label=education>Education</a></li><li class="nav-item navbar-text"><a class=nav-link href=/posts title>Posts</a></li><li class="nav-item navbar-text"><a class=nav-link href=/tags title>Tags</a></li><li class="nav-item navbar-text"><a class=nav-link href=/topics title>Topics</a></li><li class="nav-item navbar-text"><div class=text-center><button id=theme-toggle>
<svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></li></ul></div></div></nav></header><div id=content><section id=single><div class=container><div class="row justify-content-center"><div class="col-sm-12 col-md-12 col-lg-9"><div class=pr-lg-4><div class="title mb-5"><h1 class="text-center mb-4">std::unordered_map Performance and Usage</h1><div class=text-center>Dec 11, 111158
<span id=readingTime>min read</span></div></div><article class="page-content p-2"><h1 id=origin-story>Origin Story</h1><p>We have always been told that hashmap is the best associative container that offer O(1) insert, delete, and lookup. However, the customization space of it is quite large and depending on the use case, the trade-off space can change radically.<br><code>std::unordered_map</code> is (in)famous for having an API that basically forces implementers to use &ldquo;buckets with linked lists&rdquo;, also known as <em>separate chaining</em>.<br>Many performance-critical applications swear on <em>open addressing</em>, often storing keys and values directly in arrays (either together or separate).<br>These are often called <code>flat_</code>maps.<br>Many requirements and quality attributes influence which particular type is &ldquo;best&rdquo;:</p><ul><li>Is pointer stability required? (often rules out <code>flat_</code> versions, unless only stability of <em>value</em> is required)</li><li>Can entries be deleted individually? (often not required, removing tombstone handling)</li><li>How big are the keys and values? (I&rsquo;ve seen all combinations, even huge-key-small-value is occasionally useful)</li><li>What are the relative frequencies of insert, delete, lookup-with-success, and lookup-without-success?</li><li>Is robustness against adversarial attacks required? (e.g. DoS attacks based on enforced collisions)</li><li>Is the hash collision-free? (keys might share the same bucket, but same hash implies same key)</li></ul><p>There is already a large corpus of constructive (and not so constructive) discussion on all these particulars.<br>Many excellent general-purpose and special-purpose hash map implementations are available.<br>I&rsquo;ve added a few links at the end of this post.</p><p>However, before choosing a certain hash map implementation, there is a certain elephant in the room that I found myself investigating.<br>You see, hash maps require &ldquo;good hashes&rdquo;.<br>Everyone knows that.<br>Benchmarks often work on random input data, which easily map to &ldquo;good hashes&rdquo;.</p><p>I have written a few bad hashes over the years and they are really not an issue.<br>A really bad hash elevates O(1) to O(n).<br>If simply inserting 100k entries into a hashmap takes half an hour, the problem basically detects itself.</p><p>No, &ldquo;almost bad hashes&rdquo; and &ldquo;less-than-optimal hashes&rdquo; are the real issue, the silent killers.<br>I recently investigated a piece of code that was too slow for my tastes, but not critically so.<br>You know, code that works on a few hundred thousand elements and takes a few seconds.<br>Not suspicious per se, but it happened to be the next chunk I investigated.<br>A napkin calculation later, the runtime cost was roughly 2000 CPU cycles per element.<br>It <em>felt</em> too much for some simple floating point arithmetic, but knowing that a cold read from memory can take 200 cycles, I argued to myself that it might be an issue with <code>std::unordered_map</code> as we probably all heard that it&rsquo;s &ldquo;badly designed&rdquo; and &ldquo;too slow&rdquo;.</p><p>I was half-way into pulling some Google-grade <code>flat_map</code> into the project when, on a whim, I slightly modified my hash function.<br>Instead of the three <code>float</code>s whose bit pattern I scrambled together via <code>boost::hash_combine</code>, I discretized the <code>float</code>s into <code>int</code>s before passing them to <code>hash_combine</code>.</p><p>The result: 50x improved performance.</p><h1 id=hash-vs-bucket-collisions>Hash vs. Bucket Collisions</h1><p>I did not need more evidence that something with the hash was wrong.<br>Just to provide the context, these were my hash functions:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hash_add</span>(size_t<span style=color:#f92672>&amp;</span> hash, size_t new_hash)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// taken from boost::hash_combine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    hash <span style=color:#f92672>^=</span> new_hash <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x9e3779b9</span> <span style=color:#f92672>+</span> (hash <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>6</span>) <span style=color:#f92672>+</span> (hash <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>size_t <span style=color:#a6e22e>myhash_float</span>(<span style=color:#66d9ef>float</span> x, <span style=color:#66d9ef>float</span> y, <span style=color:#66d9ef>float</span> z)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    size_t h <span style=color:#f92672>=</span> <span style=color:#75715e>/* some fixed seed */</span>;
</span></span><span style=display:flex><span>    hash_add(h, std<span style=color:#f92672>::</span>bit_cast<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint32_t</span><span style=color:#f92672>&gt;</span>(x));
</span></span><span style=display:flex><span>    hash_add(h, std<span style=color:#f92672>::</span>bit_cast<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint32_t</span><span style=color:#f92672>&gt;</span>(y));
</span></span><span style=display:flex><span>    hash_add(h, std<span style=color:#f92672>::</span>bit_cast<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint32_t</span><span style=color:#f92672>&gt;</span>(z));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> h;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>size_t <span style=color:#a6e22e>myhash_int</span>(<span style=color:#66d9ef>float</span> x, <span style=color:#66d9ef>float</span> y, <span style=color:#66d9ef>float</span> z)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    size_t h <span style=color:#f92672>=</span> <span style=color:#75715e>/* some fixed seed */</span>;
</span></span><span style=display:flex><span>    hash_add(h, <span style=color:#66d9ef>int32_t</span>(<span style=color:#ae81ff>256</span> <span style=color:#f92672>*</span> x));
</span></span><span style=display:flex><span>    hash_add(h, <span style=color:#66d9ef>int32_t</span>(<span style=color:#ae81ff>256</span> <span style=color:#f92672>*</span> y));
</span></span><span style=display:flex><span>    hash_add(h, <span style=color:#66d9ef>int32_t</span>(<span style=color:#ae81ff>256</span> <span style=color:#f92672>*</span> z));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> h;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>So, 50x performance difference between <code>myhash_int</code> and <code>myhash_float</code>, eh?</p><p>First, let me note that <code>myhash_float</code> is not a bad hash per se and it is definitely the more versatile one.<br><code>myhash_int</code> has many collisions if the inputs are too small or if different keys differ by only a small amount.<br>In my case, it worked due to the nature of the input data.</p><p>I don&rsquo;t know the complete history and rationale of <code>boost::hash_combine</code> but I guess it was not designed with <code>float</code>s in mind and probably comes from the 32 bit era.<br>On my real-world data set with 90000 entries, I had 3% hash collisions with <code>myhash_float</code> and only 0.2% with <code>myhash_int</code>.<br>While a &ldquo;real&rdquo; hash like <a href=https://github.com/Cyan4973/xxHash><code>xxHash</code></a> realistically produces no collisions for this number of entries, a few collisions do not explain the large performance gap.</p><blockquote><p>Side note: <code>xxHash</code> and similar hash functions are mainly designed for high throughput when processing larger amounts of data, like complete files or buffers.<br>That being said, they still often try to guarantee good performance on small data, like keys for hash maps.<br><code>xxHash</code> is also explicitly optimized for good throughput and latency on data consisting of only a few bytes.<br>However, its higher hash quality is not free and the overhead can be an order of magnitude slowdown when compared to ad-hoc special-purpose hashes for hash maps, like <code>myhash_xyz</code> above.</p></blockquote><p>Back to my issue.<br>Where do we lose 50x performance if the number of collisions is way too low to justify the difference?</p><p>On a 64 bit desktop, hash maps tend to use 64 bit hashes, like a <code>size_t</code>.<br>However, the number of buckets is significantly less, typically within factor 2 of the number of entries.<br>Thus, each hash map has a way to map a hash <code>h</code> to a bucket index <code>i</code>.</p><p>The naive mapping would be <code>i = h % bucket_count</code>.<br>Full 64 bit division and modulo is quite expensive, requiring 25-40 cycles on typical desktops.<br>If <code>bucket_count</code> is a power of two, we can optimize the mapping to <code>i = h & (bucket_count - 1)</code>, which is effectively free.</p><p>The discerning reader might already see the problem:<br>This mapping now amounts to throwing away most of the bits of <code>h</code>.</p><p>Imagine your key consists of <code>uint32_t a, b</code> and your hash is <code>(a &lt;&lt; 32) | b</code>.<br>This hash is completely free of collisions.<br>However, if you have less than 4 billion buckets, then the bucket index will completely ignore <code>a</code>, leading to tons of actual collisions for keys that differ only in <code>a</code>.</p><p>As said earlier, these obvious cases are usually trivial to detect.<br>In my case, I witnessed a partial quality degradation of the <code>key -> hash -> idx</code> mapping.<br>The input <code>float</code>s came from decompressed 3D positions, so they only had a small range of exponents and a few mantissa patterns that really appeared.<br>With <code>boost::hash_combine</code>, this was <em>somehow</em> assembled into a 64 bit hash.<br>The 3% <em>hash</em> collision rate probably means that <code>hash_combine</code> did a less-than-perfect job scrambling the <code>float</code> patterns.<br>However, the real killer came from <code>std::unordered_map</code>, mapping the hash to a bucket index.<br>It turned out that more than 98.6% of the keys had &ldquo;bucket collisions&rdquo;, i.e. had to share their bucket with other keys.<br>With <code>myhash_int</code>, this was still 86.2%.</p><h1 id=optimal-behavior>Optimal Behavior</h1><p>Before trying to quantify how bad my first hash was, let&rsquo;s briefly talk about what is the best-case scenario.<br>Zero bucket collisions are the realm of perfect hashes, which require heavy precomputation and in general only work with known input data.</p><p>If only the input distribution (not the actual data) is known, we want a <code>key -> idx</code> mapping that is <em>uniform</em>.<br>Without getting too fancy in the math: if someone hands you a <code>key</code> drawn from the input distribution, you want to hand back an <code>idx</code> that has a roughly uniform distribution over <code>0 .. bucket_count-1</code>.</p><p>In reality, the user is responsible for the <code>key -> hash</code> mapping, while the hash map provides the <code>hash -> idx</code> mapping.<br>Some cooperation is required to make the total mapping high-quality.<br>In theory, the hash map could always provide a strong <code>hash -> idx</code> mapping, e.g. via <code>xxHash</code>, but that is usually considered net-negative for performance.<br>If the input data is already sufficiently uniform, always paying for this extra hashing is extremely wasteful.</p><p>So, assuming a uniform mapping, what is the expected number of bucket collisions?</p><p>Well, that depends on the <a href=https://en.cppreference.com/w/cpp/container/unordered_map/load_factor>load_factor</a>, i.e. the ratio of input keys to buckets.<br>If the <code>load_factor</code> is 1, then we have an equal number of keys and buckets.<br>Here, on average, 37% of buckets are empty, another 37% of buckets have exactly 1 key, 18% have 2 keys, 6% have 3, and 2% have 4 or more keys.<br>This follows a <a href=https://en.wikipedia.org/wiki/Poisson_distribution>Poisson distribution</a> where the load factor is lambda.</p><p>What load factor is optimal is a different discussion, but given a fixed load factor (typically between 0.5 and 1.0), if our hash function produces roughly the same number of collisions as the corresponding Poisson distribution predicts, I would consider it &ldquo;optimal enough&rdquo;.</p><h1 id=measuring-badness>Measuring Badness</h1><p>So, how does my hash compare to an optimal one?<br>How do we measure that?</p><p>It turns out that <code>std::unordered_map</code> has a <a href=https://en.cppreference.com/w/cpp/container/unordered_map#Bucket_interface>bucket API</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>unordered_map<span style=color:#f92672>&lt;</span>Key, Value, Hasher<span style=color:#f92672>&gt;</span> my_map;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// number of buckets
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>size_t bcnt <span style=color:#f92672>=</span> my_map.bucket_count();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// bucket index from key
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>size_t bi <span style=color:#f92672>=</span> my_map.bucket(some_key);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// number of keys in this bucket
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>size_t bsize <span style=color:#f92672>=</span> my_map.bucket_size(bi);
</span></span></code></pre></div><p>With this API, we can measure how close (or far away) we are from the Poisson distribution.<br>For each key in the map, we sum up the corresponding <code>bucket_size</code>.<br>Divided by the number of keys, this is the average bucket size from the perspective of a key.<br>Half of this is the expected number of comparisons needed when looking up the key.</p><p>In the optimal case, <code>load_factor</code> is the average number of keys in a bucket (the expected value of the Poisson distribution).<br>However, when we know that a given key is part of the map, this average increases to <code>1 + load_factor</code>.</p><p>The result is this little snippet:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Map</span><span style=color:#f92672>&gt;</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>double</span> unordered_map_badness(Map <span style=color:#66d9ef>const</span><span style=color:#f92672>&amp;</span> map)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> <span style=color:#66d9ef>const</span> lambda <span style=color:#f92672>=</span> map.size() <span style=color:#f92672>/</span> <span style=color:#66d9ef>double</span>(map.bucket_count());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> cost <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#66d9ef>const</span><span style=color:#f92672>&amp;</span> [k, _] <span style=color:#f92672>:</span> map)
</span></span><span style=display:flex><span>        cost <span style=color:#f92672>+=</span> map.bucket_size(map.bucket(k));
</span></span><span style=display:flex><span>    cost <span style=color:#f92672>/=</span> map.size();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>max(<span style=color:#ae81ff>0.</span>, cost <span style=color:#f92672>/</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> lambda) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I was too lazy to template it on all 5 types required for <code>std::unordered_map</code>.<br>Officially, I call that a feature because now it supports all types with a compatible bucket API.</p><p>The return value is slightly remapped.<br><code>cost / (1 + lambda)</code> is the relative cost factor to the optimal distribution.<br>We subtract 1 and clamp it to 0 from below so it&rsquo;s a bit easier to read:<br>A badness of roughly 0 means that the current bucket distribution is close to optimal.<br>1 means that on average 100% more comparisons than optimal are required.</p><h1 id=fixing-my-issue>&ldquo;Fixing&rdquo; my Issue</h1><p>Turns out, <code>myhash_float</code> has a badness of 550 on my data. Ouch.</p><p>Of course, this does not mean that the performance gap to the optimal case is a factor of 550.<br>Similar to <a href=https://en.wikipedia.org/wiki/Amdahl%27s_law>Amdahl&rsquo;s law</a>, this factor is only realized if the program literally does nothing else (and we ignore caching and other effects that reality pesters us with).</p><p><code>myhash_int</code> still has a badness of 1.3.</p><p>Not optimal, but so much better that my program sped up by a factor of 50+.</p><p><code>xxHash</code> directly on my 3 input <code>float</code>s has a badness of 0.</p><p>Interestingly enough, using the result of <code>myhash_float</code> as a seed for a single round of <a href=https://en.wikipedia.org/wiki/Xorshift>xorshift</a> has a badness of 0.04.<br>So, even if <code>myhash_float</code> has 3% innate collision rate, a cheap scrambling at the end is all it takes to get near optimal hash distribution.</p><p>Xorshift consists of a state update and an output scramble.<br>As only the second step is needed, you can funnily enough fix most suboptimal hashes by simply calling:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>size_t <span style=color:#a6e22e>fix_my_hash</span>(size_t h)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> h <span style=color:#f92672>*</span> <span style=color:#ae81ff>0xd989bcacc137dcd5ull</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>32u</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=conclusion>Conclusion</h1><p>In my opinion, hash maps are among the most interesting data structures.<br>The only container that is more useful is the array, but apart from abstractions like <code>vector</code> and <code>span</code>, arrays are quite compact in design space.<br>Hash maps have a plethora of useful variants and tradeoffs.</p><p>This post is about the practical quality of hash functions and how to measure them.<br>With the bucket API of <code>std::unordered_map</code>, we can actually quantify how far from optimal our concrete map is.</p><p>My little snipped can be adapted to hash maps with open addressing by measuring the number of comparisons needed until a key is found.<br>This is usually not an exposed metric, though I suppose one could simply write a counting equality comparer for that.</p><h1 id=further-reading>Further Reading</h1><ul><li><a href=https://tessil.github.io/2016/08/29/benchmark-hopscotch-map.html>Benchmark of major hash maps implementations (2016)</a></li><li><a href=https://probablydance.com/2017/02/26/i-wrote-the-fastest-hashtable/>I Wrote The Fastest Hashtable (2017)</a></li><li><a href=https://martin.ankerl.com/2019/04/01/hashmap-benchmarks-01-overview/>Hashmaps Benchmarks - Overview (2019)</a></li></ul><p>Additional discussion and comments on <a href=https://www.reddit.com/r/cpp/comments/q551zg/measuring_stdunordered_map_hash_badness/>reddit</a>.</p></article></div></div><div class="col-sm-12 col-md-12 col-lg-3"><div id=stickySideBar class=sticky-sidebar><aside class=toc><h5>Table Of Contents</h5><div class=toc-content><nav id=TableOfContents></nav></div></aside><aside class=tags><h5>Tags</h5><ul class="tags-ul list-unstyled list-inline"><li class=list-inline-item><a href=https://bobblelaw.github.io/tags/c++ target=_blank>C++</a></li></ul></aside><aside class=social><h5>Social</h5><div class=social-content><ul class=list-inline><li class="list-inline-item text-center"><a target=_blank href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fbobblelaw.github.io%2fposts%2funordered-map-usage-and-performance%2f"><i class="fab fa-linkedin"></i></a></li><li class="list-inline-item text-center"><a target=_blank href="https://twitter.com/share?text=std%3a%3aunordered_map%20Performance%20and%20Usage&url=https%3a%2f%2fbobblelaw.github.io%2fposts%2funordered-map-usage-and-performance%2f"><i class="fab fa-twitter"></i></a></li><li class="list-inline-item text-center"><a target=_blank href="https://api.whatsapp.com/send?text=std%3a%3aunordered_map%20Performance%20and%20Usage: https%3a%2f%2fbobblelaw.github.io%2fposts%2funordered-map-usage-and-performance%2f"><i class="fab fa-whatsapp"></i></a></li><li class="list-inline-item text-center"><a target=_blank href='mailto:?subject=std%3a%3aunordered_map%20Performance%20and%20Usage&amp;body=Check%20out%20this%20site https%3a%2f%2fbobblelaw.github.io%2fposts%2funordered-map-usage-and-performance%2f'><i class="fa fa-envelope"></i></a></li></ul></div></aside></div></div></div><div class=row><div class="col-sm-12 col-md-12 col-lg-9 p-4"></div></div></div><button class="p-2 px-3" onclick=topFunction() id=topScroll>
<i class="fas fa-angle-up"></i></button></section><div class=progress><div id=scroll-progress-bar class=progress-bar role=progressbar aria-valuenow=0 aria-valuemin=0 aria-valuemax=100></div></div><script src=/js/scrollProgressBar.js></script><script>var topScroll=document.getElementById("topScroll");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?topScroll.style.display="block":topScroll.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}let stickySideBarElem=document.getElementById("stickySideBar"),stickyNavBar=!0;if(stickyNavBar){let e=document.getElementById("profileHeader"),t=e.offsetHeight+15;stickySideBarElem.style.top=t+"px"}else stickySideBarElem.style.top="50px"</script><script src=/js/readingTime.js></script></div><footer><div class="text-center pt-2"><span class=px-1><a href=https://github.com/BobbleLaw aria-label=github><svg width="2.7em" height="2.7em" viewBox="0 0 1792 1792"><path id="footer-socialNetworks-github-svg-path" d="M522 1352q-8 9-20-3-13-11-4-19 8-9 20 3 12 11 4 19zm-42-61q9 12 0 19-8 6-17-7t0-18q9-7 17 6zm-61-60q-5 7-13 2-10-5-7-12 3-5 13-2 10 5 7 12zm31 34q-6 7-16-3-9-11-2-16 6-6 16 3 9 11 2 16zm129 112q-4 12-19 6-17-4-13-15t19-7q16 5 13 16zm63 5q0 11-16 11-17 2-17-11 0-11 16-11 17-2 17 11zm58-10q2 10-14 14t-18-8 14-15q16-2 18 9zm964-956v960q0 119-84.5 203.5T1376 1664h-224q-16 0-24.5-1t-19.5-5-16-14.5-5-27.5v-239q0-97-52-142 57-6 102.5-18t94-39 81-66.5 53-105T1386 856q0-121-79-206 37-91-8-204-28-9-81 11t-92 44l-38 24q-93-26-192-26t-192 26q-16-11-42.5-27T578 459.5 492 446q-44 113-7 204-79 85-79 206 0 85 20.5 150t52.5 105 80.5 67 94 39 102.5 18q-40 36-49 103-21 10-45 15t-57 5-65.5-21.5T484 1274q-19-32-48.5-52t-49.5-24l-20-3q-21 0-29 4.5t-5 11.5 9 14 13 12l7 5q22 10 43.5 38t31.5 51l10 23q13 38 44 61.5t67 30 69.5 7 55.5-3.5l23-4q0 38 .5 103t.5 68q0 22-11 33.5t-22 13-33 1.5H416q-119 0-203.5-84.5T128 1376V416q0-119 84.5-203.5T416 128h960q119 0 203.5 84.5T1664 416z"/></svg>
</a></span><span class=px-1><a href=https://www.linkedin.com/in/boblzy aria-label=linkedin><svg width="2.4em" height="2.4em" fill="#fff" aria-label="LinkedIn" viewBox="0 0 512 512"><rect width="512" height="512" fill="#0077b5" rx="15%"/><circle cx="142" cy="138" r="37"/><path stroke="#fff" stroke-width="66" d="M244 194v198M142 194v198"/><path d="M276 282c0-20 13-40 36-40 24 0 33 18 33 45v105h66V279c0-61-32-89-76-89-34 0-51 19-59 32"/></svg></a></span></div><div class="container py-4"><div class="row justify-content-center"><div class="col-md-4 text-center"><div class=pb-2><a href=https://bobblelaw.github.io/ title="Bobble Law"><img alt="Footer logo" src=/logo.png height=40px width=40px></a></div>&copy; 2025 All rights reserved<div class=text-secondary>Made with
<span class=text-danger>&#10084;
</span>and
<a href=https://github.com/gurusabarish/hugo-profile target=_blank title="Designed and developed by gurusabarish">Hugo Profile</a></div></div></div></div></footer><script src=/bootstrap-5/js/bootstrap.bundle.min.js></script><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))});var tooltipTriggerList=[].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]')),tooltipList=tooltipTriggerList.map(function(e){return new bootstrap.Tooltip(e)})</script><script src=/js/search.js></script><section id=search-content class=py-2><div class=container id=search-results></div></section></body></html>