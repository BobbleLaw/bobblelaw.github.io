<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ on Bobble Law</title><link>https://bobblelaw.github.io/tags/c++/</link><description>Recent content in C++ on Bobble Law</description><generator>Hugo</generator><language>en-US</language><lastBuildDate>Sun, 22 Aug 2021 14:53:21 +0800</lastBuildDate><atom:link href="https://bobblelaw.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>rvalue ref-qualified assignment operators</title><link>https://bobblelaw.github.io/posts/delete-rvalue-ref-assignment/</link><pubDate>Sun, 22 Aug 2021 14:53:21 +0800</pubDate><guid>https://bobblelaw.github.io/posts/delete-rvalue-ref-assignment/</guid><description>&lt;p>The title might sound like an incantation to summon some mid-tier C++ god but it addresses a very real everyday pitfall:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span> { ... };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>foo &lt;span style="color:#a6e22e">get_my_foo&lt;/span>() { ... }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// .. some code later:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>foo f;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>get_my_foo() &lt;span style="color:#f92672">=&lt;/span> f;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This &lt;a href="https://godbolt.org/z/oh3vFA">compiles&lt;/a> &amp;hellip; and does nothing useful.&lt;/p>
&lt;p>We&amp;rsquo;ve assigned &lt;code>f&lt;/code> to a temporary &lt;code>foo&lt;/code>.&lt;br>
No error, no warning.&lt;/p>
&lt;h2 id="a-real-life-example">A Real-Life Example&lt;/h2>
&lt;p>In the math library I&amp;rsquo;m writing we have a &lt;code>mat&lt;/code> struct for matrices and &lt;code>vec&lt;/code> for vectors.&lt;br>
Matrices are stored column-major, i.e. as an array of column vectors.&lt;br>
Now, sometimes you want to get the row of such matrix and thus &lt;code>mat&lt;/code> has a function &lt;code>vec mat::row(int)&lt;/code> that returns the specified row.&lt;br>
It has to return the &lt;code>vec&lt;/code> per value because only columns are stored contiguously in &lt;code>mat&lt;/code>:&lt;/p></description></item><item><title>Inlining Optimization</title><link>https://bobblelaw.github.io/posts/inline-optimization/</link><pubDate>Wed, 19 May 2021 17:29:41 +0800</pubDate><guid>https://bobblelaw.github.io/posts/inline-optimization/</guid><description>&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Inline_expansion">Inlining&lt;/a> is one of the most important compiler optimizations.&lt;br>
We can often write abstractions and thin wrapper functions without incurring any performance penalty, because the compiler will expand the method for us at call site.&lt;/p>
&lt;p>If a function is not inlined, conventional wisdom says that the compiler has to assume that the method can modify any global state and change the memory behind any pointer or reference that might have &amp;ldquo;escaped&amp;rdquo;.&lt;/p></description></item><item><title>Multi-Level Loop Break</title><link>https://bobblelaw.github.io/posts/multi-level-break/</link><pubDate>Wed, 12 May 2021 09:57:09 +0800</pubDate><guid>https://bobblelaw.github.io/posts/multi-level-break/</guid><description>&lt;p>I guess we all have been at this point.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">auto&lt;/span> i : ...)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">auto&lt;/span> j : ...)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (condition(i, j))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span> outer&lt;span style="color:#f92672">???&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You want to search something, and for one reason or another you end up with a nested loop.&lt;br>
You find what you searched for and now want to &lt;code>break&lt;/code> all the way to the outer loop.&lt;/p>
&lt;p>If only we had multi-level &lt;code>breaks&lt;/code>.&lt;/p></description></item><item><title>Moves in Returns</title><link>https://bobblelaw.github.io/posts/moves-in-return/</link><pubDate>Sat, 19 Dec 2020 14:39:20 +0800</pubDate><guid>https://bobblelaw.github.io/posts/moves-in-return/</guid><description>&lt;p>Today we&amp;rsquo;ll discuss code of the form:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>T &lt;span style="color:#a6e22e">work&lt;/span>(&lt;span style="color:#75715e">/* ... */&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* ... */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This is a classical &amp;ldquo;return-by-value&amp;rdquo; and (wrongfully) associated with copies and overhead.&lt;/p>
&lt;p>In many cases, this will actually &lt;code>move&lt;/code> the result instead of copying it.&lt;br>
For modern C++, one could even argue that this will move in &lt;em>most&lt;/em> cases (or, as we will see, completely &lt;em>elide&lt;/em> the copy and directly construct in the result memory).&lt;/p></description></item><item><title>std::unordered_map Performance and Usage</title><link>https://bobblelaw.github.io/posts/unordered-map-usage-and-performance/</link><pubDate>Fri, 11 Dec 2020 09:36:58 +0800</pubDate><guid>https://bobblelaw.github.io/posts/unordered-map-usage-and-performance/</guid><description>&lt;h2 id="origin-story">Origin Story&lt;/h2>
&lt;p>We have always been told that hashmap is the best associative container that offer O(1) insert, delete, and lookup. However, the customization space of it is quite large and depending on the use case, the trade-off space can change radically.&lt;br>
&lt;code>std::unordered_map&lt;/code> is (in)famous for having an API that basically forces implementers to use &amp;ldquo;buckets with linked lists&amp;rdquo;, also known as &lt;em>separate chaining&lt;/em>.&lt;br>
Many performance-critical applications swear on &lt;em>open addressing&lt;/em>, often storing keys and values directly in arrays (either together or separate).&lt;br>
These are often called &lt;code>flat_&lt;/code>maps.&lt;br>
Many requirements and quality attributes influence which particular type is &amp;ldquo;best&amp;rdquo;:&lt;/p></description></item><item><title>Sort Multiple Ranges</title><link>https://bobblelaw.github.io/posts/sort-multiple-range/</link><pubDate>Sat, 28 Nov 2020 09:45:32 +0800</pubDate><guid>https://bobblelaw.github.io/posts/sort-multiple-range/</guid><description>&lt;p>&lt;code>std::sort&lt;/code> is a great utility.&lt;br>
You can easily sort subranges and provide custom comparison functions.&lt;br>
However, it struggles with the following scenario:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> keys &lt;span style="color:#f92672">=&lt;/span> ...;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&lt;/span> values &lt;span style="color:#f92672">=&lt;/span> ...;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>sort(...); &lt;span style="color:#75715e">// ???
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We want to sort by &lt;code>keys&lt;/code> but keep the 1-on-1 correspondence with &lt;code>values&lt;/code>, i.e. keep the ranges &amp;ldquo;in sync&amp;rdquo; during sorting.&lt;br>
A common solution is to allocate a vector of indices, sort these indices, and then apply the resulting permutation.&lt;br>
However, the need for an additional allocation and bad cache locality due to indirection make this a suboptimal solution.&lt;/p></description></item><item><title>range_ref&lt;T></title><link>https://bobblelaw.github.io/posts/range-ref/</link><pubDate>Thu, 12 Nov 2020 19:37:43 +0800</pubDate><guid>https://bobblelaw.github.io/posts/range-ref/</guid><description>&lt;p>Passing references to functions is great.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">some_user_type&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>(some_user_type &lt;span style="color:#66d9ef">const&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> v)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// freely read from v
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Memory management and lifetime handling is done by the caller.&lt;br>
Users of your function / API have a liberating amount of freedom how they organize their data: on the stack, on the heap, in smart pointers, in vectors, it doesn&amp;rsquo;t matter.&lt;br>
They can pass a reference to your function.&lt;br>
No (potentially expensive) copy is performed.&lt;/p></description></item><item><title>Recursive Lambdas</title><link>https://bobblelaw.github.io/posts/recursive-lambda-function/</link><pubDate>Sun, 08 Nov 2020 13:41:36 +0800</pubDate><guid>https://bobblelaw.github.io/posts/recursive-lambda-function/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">auto&lt;/span> fib &lt;span style="color:#f92672">=&lt;/span> [](&lt;span style="color:#66d9ef">int&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (n &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> n;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">fib&lt;/span>(n &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> fib(n &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">auto&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> fib(&lt;span style="color:#ae81ff">7&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If only it were that simple.&lt;/p>
&lt;p>Obviously, any performance-conscious programmer will compute Fibonacci numbers iteratively (or even &lt;a href="https://en.wikipedia.org/wiki/Fibonacci_number#Closed-form_expression">explicitly&lt;/a>), but this solution will serve as an example for an underappreciated tool: &lt;em>recursive lambdas&lt;/em>.&lt;/p>
&lt;p>Lambdas are one of my favorite features in any programming language and while I long for a &lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0573r1.html">shorter syntax in C++&lt;/a>, I still use them quite ubiquitously, especially for local functions.&lt;br>
They allow us to abstract behavior into a function while still accessing local variables (through captures) and without leaking new names into the surrounding namespace.&lt;br>
While already plenty powerful, sometimes we might want to call a lambda recursively.&lt;/p></description></item><item><title>Basic Floating Point Optimizations</title><link>https://bobblelaw.github.io/posts/floating-point-optimizations/</link><pubDate>Wed, 07 Aug 2019 09:08:11 +0800</pubDate><guid>https://bobblelaw.github.io/posts/floating-point-optimizations/</guid><description>&lt;p>Ever seen some people write &lt;code>f * 0.5&lt;/code> when they mean &lt;code>f / 2&lt;/code>?&lt;/p>
&lt;p>Or if the compiler is able to optimize the &lt;code>f * 1.0&lt;/code> that you added for clarity?&lt;/p>
&lt;p>Maybe you wrote &lt;code>f + f&lt;/code> instead of &lt;code>f * 2&lt;/code> as a clever optimization?&lt;/p>
&lt;p>Modern compilers are basically magic, &lt;em>but do they actually perform these optimizations?&lt;/em>&lt;br>
And, more importantly, &lt;em>why is &lt;code>f + 0.0&lt;/code> slower than &lt;code>f - 0.0&lt;/code>?&lt;/em>&lt;/p></description></item></channel></rss>