<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ Tips on Bobble Law</title><link>https://bobblelaw.github.io/series/c++-tips/</link><description>Recent content in C++ Tips on Bobble Law</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2022 &lt;a href="#">Bobble Law&lt;/a> and &lt;a href="#">Stay Inc.&lt;/a></copyright><lastBuildDate>Mon, 03 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://bobblelaw.github.io/series/c++-tips/index.xml" rel="self" type="application/rss+xml"/><item><title>std::unordered_map Performance and Usage</title><link>https://bobblelaw.github.io/posts/unordered-map-usage-and-performance/</link><pubDate>Mon, 03 May 2021 00:00:00 +0000</pubDate><guid>https://bobblelaw.github.io/posts/unordered-map-usage-and-performance/</guid><description>Origin Story We have always been told that hashmap is the best associative container that offer O(1) insert, delete, and lookup. However, the customization space of it is quite large and depending on the use case, the trade-off space can change radically. std::unordered_map is (in)famous for having an API that basically forces implementers to use &amp;ldquo;buckets with linked lists&amp;rdquo;, also known as separate chaining. Many performance-critical applications swear on open addressing, often storing keys and values directly in arrays (either together or separate).</description></item></channel></rss>